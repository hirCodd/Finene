(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{547:function(a,e,t){"use strict";t.r(e);var v=t(1),_=Object(v.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"集合关系图谱"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集合关系图谱"}},[a._v("#")]),a._v(" 集合关系图谱")]),a._v(" "),t("blockquote",[t("p",[a._v("Java集合框架包括Collection和Map，Collection主要用于存储对象，Map主要用用于存储键值对数据。\n"),t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Java-collection-cheat-sheet.PNG",alt:"Java-Collection"}})])]),a._v(" "),t("h2",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[a._v("#")]),a._v(" 介绍")]),a._v(" "),t("p",[a._v("容器，就是可以容纳其他Java对象的对象。*Java Collections Framework(JCF)*为Java开发者提供了通用的容器，其始于JDK 1.2，优点是:")]),a._v(" "),t("ul",[t("li",[a._v("降低编程难度")]),a._v(" "),t("li",[a._v("提高程序性能")]),a._v(" "),t("li",[a._v("提高API间的互操作性")]),a._v(" "),t("li",[a._v("降低学习难度")]),a._v(" "),t("li",[a._v("降低设计和实现相关API的难度")]),a._v(" "),t("li",[a._v("增加程序的重用性\nJava容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。")])]),a._v(" "),t("h2",{attrs:{id:"collection"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#collection"}},[a._v("#")]),a._v(" Collection")]),a._v(" "),t("h3",{attrs:{id:"list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[a._v("#")]),a._v(" List")]),a._v(" "),t("h4",{attrs:{id:"arraylist简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arraylist简介"}},[a._v("#")]),a._v(" ArrayList简介")]),a._v(" "),t("p",[a._v("1.ArrayList继承自"),t("code",[a._v("AbstractList")]),a._v("，实现了"),t("code",[a._v("List")]),a._v("、"),t("code",[a._v("RandomAccess")]),a._v("、"),t("code",[a._v("Cloneable")]),a._v("、"),t("code",[a._v("Serializable")]),a._v("接口。")]),a._v(" "),t("p",[a._v("2.底层基于动态数组实现容量大小动态变化（容量可自动增长）。")]),a._v(" "),t("p",[a._v("3.允许"),t("code",[a._v("null")]),a._v("的存在。")]),a._v(" "),t("p",[a._v("4.ArrayList是支持快速访问、复制、序列化的。基于动态数组实现，支持。")]),a._v(" "),t("p",[a._v("5.ArrayList是非同步的。")]),a._v(" "),t("p",[a._v("6.ArrayList的iterator和listIterator方法返回的迭代器是fail-fast的。")]),a._v(" "),t("h4",{attrs:{id:"linkedlist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[a._v("#")]),a._v(" LinkedList")]),a._v(" "),t("p",[a._v("1.LinkedList继承自"),t("code",[a._v("AbstractSequentialList")]),a._v("，实现了"),t("code",[a._v("List")]),a._v("、"),t("code",[a._v("Deque")]),a._v("、"),t("code",[a._v("Cloneable")]),a._v("、"),t("code",[a._v("Serializable")]),a._v("接口，LinkedList是基于链表实现的，只能顺序访问。")]),a._v(" "),t("p",[a._v("2."),t("code",[a._v("LinkedList")]),a._v("插入和删除方面要优于"),t("code",[a._v("ArrayList")]),a._v("。")]),a._v(" "),t("p",[a._v("3.LinkedList是非同步的。")]),a._v(" "),t("p",[a._v("4.LinkedList的iterator和listIterator方法返回的迭代器是fail-fast的。")]),a._v(" "),t("h3",{attrs:{id:"set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[a._v("#")]),a._v(" Set")]),a._v(" "),t("h4",{attrs:{id:"hashset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashset"}},[a._v("#")]),a._v(" Hashset")]),a._v(" "),t("p",[a._v("1.HashSet继承自"),t("code",[a._v("AbstractSet")]),a._v(",实现了"),t("code",[a._v("Set")]),a._v("、"),t("code",[a._v("Cloneable")]),a._v("、"),t("code",[a._v("Serializable")]),a._v("接口,底层是一个HashMap。")]),a._v(" "),t("p",[a._v("2.HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。")]),a._v(" "),t("p",[a._v("3.HashSet中元素都是无序的(即存取顺序不一致)；")]),a._v(" "),t("p",[a._v("4.HashSet没有下标选取，只能通过增强for循环或者迭代器取出元素；")]),a._v(" "),t("p",[a._v("5.HashSet是非同步的；")]),a._v(" "),t("p",[a._v("6.HashSet的iterator方法返回的迭代器是fail-fast的。")]),a._v(" "),t("h4",{attrs:{id:"linkedhashset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashset"}},[a._v("#")]),a._v(" LinkedHashSet")]),a._v(" "),t("p",[a._v("1.LinkedHashSet继承自"),t("code",[a._v("HashSet")]),a._v("，实现了"),t("code",[a._v("Set")]),a._v("、"),t("code",[a._v("Cloneable")]),a._v("接口，底层其实是一个LinkedHashMap。")]),a._v(" "),t("p",[a._v("2.不能保证插入和输出的顺序一致。")]),a._v(" "),t("p",[a._v("3.不允许重复的元素插入，可以插入null。")]),a._v(" "),t("p",[a._v("4.HashSet的iterator方法返回的迭代器是fail-fast的。")]),a._v(" "),t("h4",{attrs:{id:"treeset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#treeset"}},[a._v("#")]),a._v(" TreeSet")]),a._v(" "),t("p",[a._v("1.TreeSet继承自"),t("code",[a._v("AbstractSet")]),a._v("，实现了NavigableSet、Cloneable、Serializable接口。")]),a._v(" "),t("p",[a._v("2.一种基于"),t("code",[a._v("TreeMap")]),a._v("的"),t("code",[a._v("NavigableSet")]),a._v("实现,意味着它支持一系列的导航方法。")]),a._v(" "),t("p",[a._v("3.TreeSet是有序的Set集合,通过"),t("code",[a._v("TreeMap")]),a._v("实现的一个有序的、不可重复的集合，底层维护的是红黑树结构。")]),a._v(" "),t("p",[a._v("4.TreeSet的iterator方法返回的迭代器是fail-fast的。")]),a._v(" "),t("h3",{attrs:{id:"queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[a._v("#")]),a._v(" Queue")]),a._v(" "),t("h4",{attrs:{id:"arraydeque"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arraydeque"}},[a._v("#")]),a._v(" ArrayDeque")]),a._v(" "),t("p",[a._v("1.ArrayDeque是Deque接口的一个实现，使用了可变数组，所以没有容量上的限制。")]),a._v(" "),t("p",[a._v("2.ArrayDeque是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。")]),a._v(" "),t("p",[a._v("3.ArrayDeque是Deque的实现类，可以作为栈来使用，效率高于Stack；\n也可以作为队列来使用，效率高于LinkedList。")]),a._v(" "),t("p",[a._v("4.ArrayDeque不支持null值。")]),a._v(" "),t("p",[a._v("5.ArrayDeque的iterator方法返回的迭代器是fail-fast的。")]),a._v(" "),t("p",[a._v("6.ArrayDeque两端都可以操作,支持双向迭代器遍历。")]),a._v(" "),t("h4",{attrs:{id:"priorityqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#priorityqueue"}},[a._v("#")]),a._v(" PriorityQueue")]),a._v(" "),t("p",[a._v("1.PriorityQueue继承自"),t("code",[a._v("AbstractQueue")]),a._v("，实现了"),t("code",[a._v("Serializable")]),a._v("接口。")]),a._v(" "),t("p",[a._v("2.PriorityQueue队列元素根据自然排序或者根据具体的比较器排序。")]),a._v(" "),t("p",[a._v("3.PriorityQueue实例化时若未指定初始容量，默认容量为11。")]),a._v(" "),t("p",[a._v("4.PriorityQueue自动扩容。如果容量小于64，两倍增长扩容；否则增长50%,PriorityQueue是无边界容器。")]),a._v(" "),t("p",[a._v("5.PriorityQueue的迭代器不具有以特定顺序访问队列元素。")]),a._v(" "),t("p",[a._v("6.PriorityQueue不支持"),t("code",[a._v("null")]),a._v("元素。")]),a._v(" "),t("p",[a._v("7.PriorityQueue入队出队的时间复杂度O(log(n))")]),a._v(" "),t("h2",{attrs:{id:"map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[a._v("#")]),a._v(" Map")]),a._v(" "),t("h3",{attrs:{id:"hashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),t("p",[a._v("1.HashMap继承自"),t("code",[a._v("AbstractMap")]),a._v(",实现"),t("code",[a._v("Map")]),a._v("、"),t("code",[a._v("Cloneable")]),a._v("、"),t("code",[a._v("Serializable")]),a._v("接口。")]),a._v(" "),t("p",[a._v("2.HashMap 基于哈希表的Map接口实现，是以 key-value 存储形式存在，即主要用来存放键值对。")]),a._v(" "),t("p",[a._v("3.HashMap 的实现不是同步的，这意味着它不是线程安全的。")]),a._v(" "),t("p",[a._v("4.HashMap 中的映射不是有序的(即存取顺序不一致)。")]),a._v(" "),t("p",[a._v("5.JDK1.5-JDK1.7实现的结果是数组+链表，JDK1.8实现结构是数组+链表+红黑树。")]),a._v(" "),t("p",[a._v("6.HashMap key值能为null,value值可以为null，且key值不允许重复。")]),a._v(" "),t("p",[a._v("7.HashMap的iterator方法返回的迭代器是fail-fastl的。")]),a._v(" "),t("h3",{attrs:{id:"linkedhashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashmap"}},[a._v("#")]),a._v(" LinkedHashMap")]),a._v(" "),t("p",[a._v("1.LinkedHashMap继承自"),t("code",[a._v("HashMap")]),a._v(",实现了"),t("code",[a._v("Map")]),a._v("接口。")]),a._v(" "),t("p",[a._v("2.LinkedHashMap维护了一个Entry的双向链表，保证了插入的Entry中的顺序。")]),a._v(" "),t("p",[a._v("3.使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。")]),a._v(" "),t("p",[a._v("4.LinkedHashMap的iterator方法返回的迭代器是fail-fastl的。")]),a._v(" "),t("h3",{attrs:{id:"treemap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[a._v("#")]),a._v(" TreeMap")]),a._v(" "),t("p",[a._v("1.TreeMap 继承自AbstractMap，实现了"),t("code",[a._v("NavigableMap")]),a._v("、"),t("code",[a._v("Cloneable")]),a._v("、"),t("code",[a._v("Serializable接口")]),a._v("。")]),a._v(" "),t("p",[a._v("2.TreeMap不允许出现重复的key。")]),a._v(" "),t("p",[a._v("3.TreeMap可以插入null键，null值。")]),a._v(" "),t("p",[a._v("4.TreeMap可以对元素进行排序。")]),a._v(" "),t("p",[a._v("5.TreeMap无序集合（插入和遍历顺序不一致）。")]),a._v(" "),t("p",[a._v("6.TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的Comparator进行排序，具体取决于使用的构造方法。")]),a._v(" "),t("p",[a._v("7.TreeMap的iterator方法返回的迭代器是fail-fastl的。")]),a._v(" "),t("h3",{attrs:{id:"hashtable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashtable"}},[a._v("#")]),a._v(" HashTable")]),a._v(" "),t("p",[a._v("1.与HashMap一样，Hashtable也是一个散列表，是以key-value存储形式存在，即主要用来存放键值对；")]),a._v(" "),t("p",[a._v("2.与HashMap不同，Hashtable的函数都是同步的，这意味着它是线程安全的；")]),a._v(" "),t("p",[a._v("3.Hashtable的key、value都不可以为null，并且，Hashtable中的映射不是有序的；")]),a._v(" "),t("p",[a._v("4.实现结构是数组+单向链表。")])])}),[],!1,null,null,null);e.default=_.exports}}]);