(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{553:function(s,a,t){"use strict";t.r(a);var e=t(1),n=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"_1-jvm终结篇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-jvm终结篇"}},[s._v("#")]),s._v(" 1 JVM终结篇")]),s._v(" "),t("h2",{attrs:{id:"_1-1-重新认知jvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-重新认知jvm"}},[s._v("#")]),s._v(" 1.1 重新认知JVM")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232017105.png",alt:"image-20220310232017105"}})]),s._v(" "),t("h2",{attrs:{id:"_1-2-gc优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-gc优化"}},[s._v("#")]),s._v(" 1.2 GC优化")]),s._v(" "),t("blockquote",[t("p",[s._v("内存被使用了之后，难免会有不够用或者达到设定值的时候，就需要对内存空间进行垃圾回收。")])]),s._v(" "),t("h3",{attrs:{id:"_1-2-1-垃圾收集发生的时机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-垃圾收集发生的时机"}},[s._v("#")]),s._v(" 1.2.1 垃圾收集发生的时机")]),s._v(" "),t("blockquote",[t("p",[s._v("GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。 当然，我们可以手动进行垃圾回收， 比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是说 System.gc()只是通知要回收，什么时候回收由JVM决定。 但是不建议手动调用该方法，因为消耗的资源比较 大。")])]),s._v(" "),t("p",[s._v("一般以下几种情况会发生垃圾回收:")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("（1）当Eden区或者S区不够用了\n（2）老年代空间不够用了\n（3）方法区空间不够用了\n（4）System.gc()\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("h3",{attrs:{id:"_1-2-2-实验环境准备"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-2-实验环境准备"}},[s._v("#")]),s._v(" 1.2.2 实验环境准备")]),s._v(" "),t("h3",{attrs:{id:"_1-2-3-gc日志文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-gc日志文件"}},[s._v("#")]),s._v(" 1.2.3 GC日志文件")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232235655.png",alt:"image-20220310232235655"}})]),s._v(" "),t("blockquote",[t("p",[s._v("要想分析日志的信息，得先拿到GC日志文件才行，所以得先配置一下，之前也看过这些参数。")])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps\n-Xloggc:gc.log\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[s._v("然后启动项目，可以看到默认使用的是ParallelGC")]),s._v(" "),t("h4",{attrs:{id:"_1-2-3-1-parallel-gc日志"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-1-parallel-gc日志"}},[s._v("#")]),s._v(" 1.2.3.1 Parallel GC日志")]),s._v(" "),t("blockquote",[t("p",[s._v("【吞吐量优先】")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("2019-06-10T23:21:53.305+0800: 1.303:\n[GC (Allocation Failure) [PSYoungGen: 65536K[Young区回收前]->10748K[Young区回收后]\n(76288K[Young区总大小])] 65536K[整个堆回收前]->15039K[整个堆回收后](251392K[整个堆总大小]),\n0.0113277 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[s._v("注意 如果回收的差值中间有出入，说明这部分空间是Old区释放出来的")])]),s._v(" "),t("h4",{attrs:{id:"_1-2-3-2-cms日志"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-2-cms日志"}},[s._v("#")]),s._v(" 1.2.3.2 CMS日志")]),s._v(" "),t("blockquote",[t("p",[s._v("【停顿时间优先】")]),s._v(" "),t("p",[s._v("参数设置：-XX:+UseConcMarkSweepGC -Xloggc:cms-gc.log")])]),s._v(" "),t("h4",{attrs:{id:"_1-2-3-3-g1日志"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-3-g1日志"}},[s._v("#")]),s._v(" 1.2.3.3 G1日志")]),s._v(" "),t("blockquote",[t("p",[s._v("【停顿时间优先】")]),s._v(" "),t("p",[s._v("参数设置：-XX:+UseG1GC -Xloggc:g1-gc.log")]),s._v(" "),t("p",[s._v("理解G1日志格式：https://blogs.oracle.com/poonam/understanding-g1-gc-logs")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("-XX:+UseG1GC "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 使用了G1垃圾收集器")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 什么时候发生的GC，相对的时间刻，GC发生的区域young，总共花费的时间，0.00478s，")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# It is a stop-the-world activity and all")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# the application threads are stopped at a safepoint during this time.")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2019")]),s._v("-12-18T16:06:46.508+0800: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.458")]),s._v(": "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("GC pause "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("G1 Evacuation Pause"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("young"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(",\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.0047804")]),s._v(" secs"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 多少个垃圾回收线程，并行的时间")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("Parallel Time: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3.0")]),s._v(" ms, GC Workers: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# GC线程开始相对于上面的0.458的时间刻")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("GC Worker Start "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("ms"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(": Min: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("458.5")]),s._v(", Avg: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("458.5")]),s._v(", Max: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("458.5")]),s._v(", Diff: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# This gives us the time spent by each worker thread scanning the roots")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# (globals, registers, thread stacks and VM data structures).")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("Ext Root Scanning "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("ms"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(": Min: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.2")]),s._v(", Avg: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.4")]),s._v(", Max: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.7")]),s._v(", Diff: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.5")]),s._v(", Sum: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1.7")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# Update RS gives us the time each thread spent in updating the Remembered Sets.")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("Update RS "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("ms"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(": Min: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.0")]),s._v(", Avg: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.0")]),s._v(", Max: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.0")]),s._v(", Diff: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.0")]),s._v(", Sum: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br")])])]),s._v(" "),t("h3",{attrs:{id:"_1-2-4-gc日志文件分析工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-4-gc日志文件分析工具"}},[s._v("#")]),s._v(" 1.2.4 GC日志文件分析工具")]),s._v(" "),t("h4",{attrs:{id:"_1-2-4-1-gceasy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-4-1-gceasy"}},[s._v("#")]),s._v(" 1.2.4.1 gceasy")]),s._v(" "),t("blockquote",[t("p",[s._v("官网 ：https://gceasy.io")]),s._v(" "),t("p",[s._v("可以比较不同的垃圾收集器的吞吐量和停顿时间")]),s._v(" "),t("p",[s._v("比如打开cms-gc.log和g1-gc.log")])]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232816712.png",alt:"image-20220310232816712"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232830568.png",alt:"image-20220310232830568"}})]),s._v(" "),t("h4",{attrs:{id:"_1-2-4-2-gcviewer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-4-2-gcviewer"}},[s._v("#")]),s._v(" 1.2.4.2 GCViewer")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232844104.png",alt:"image-20220310232844104"}})]),s._v(" "),t("h3",{attrs:{id:"_1-2-5-g1调优与最佳指南"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-5-g1调优与最佳指南"}},[s._v("#")]),s._v(" 1.2.5 G1调优与最佳指南")]),s._v(" "),t("h4",{attrs:{id:"_1-2-5-1-调优"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-5-1-调优"}},[s._v("#")]),s._v(" 1.2.5.1 调优")]),s._v(" "),t("blockquote",[t("p",[s._v("是否选用G1垃圾收集器的判断依据")]),s._v(" "),t("p",[s._v("https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html#use_cases")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("（1）50%以上的堆被存活对象占用\n（2）对象分配和晋升的速度变化非常大\n（3）垃圾回收时间比较长\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[s._v("思考 ：https://blogs.oracle.com/poonam/increased-heap-usage-with-g1-gc")])]),s._v(" "),t("p",[s._v("(1)使用G1GC垃圾收集器: -XX:+UseG1GC")]),s._v(" "),t("p",[s._v("修改配置参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310233115552.png",alt:"image-20220310233115552"}})]),s._v(" "),t("p",[s._v("(2)调整内存大小再获取gc日志分析")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("-XX:MetaspaceSize=100M\n-Xms300M\n-Xmx300M\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[s._v("比如设置堆内存的大小，获取到gc日志，使用GCViewer分析吞吐量和响应时间")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310233227857.png",alt:"image-20220310233227857"}})]),s._v(" "),t("p",[s._v("(3)调整最大停顿时间")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("-XX:MaxGCPauseMillis=20 设置最大GC停顿时间指标\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("比如设置最大停顿时间，获取到gc日志，使用GCViewer分析吞吐量和响应时间")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310233319130.png",alt:"image-20220310233319130"}})]),s._v(" "),t("p",[s._v("(4)启动并发GC时堆内存占用百分比")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("-XX:InitiatingHeapOccupancyPercent=45 G1用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比例。值为 0 则表示“一直执行GC循环)'. 默认值为 45 (例如, 全部的 45% 或者使用了45%).\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("比如设置该百分比参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310233428017.png",alt:"image-20220310233428017"}})]),s._v(" "),t("h4",{attrs:{id:"_1-2-5-2-最佳指南"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-5-2-最佳指南"}},[s._v("#")]),s._v(" 1.2.5.2 最佳指南")]),s._v(" "),t("blockquote",[t("p",[s._v("官网建议 ：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations")])]),s._v(" "),t("p",[t("strong",[s._v("(1)不要手动设置新生代和老年代的大小，只要设置整个堆的大小")])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("G1收集器在运行过程中，会自己调整新生代和老年代的大小其实是通过adapt代的大小来调整对象晋升的速度和年龄，从而达到为收集器设置的暂停时间目标\n\n如果手动设置了大小就意味着放弃了G1的自动调优\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[t("strong",[s._v("(2)不断调优暂停时间目标")])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("一般情况下这个值设置到100ms或者200ms都是可以的(不同情况下会不一样)，但如果设置成50ms就不太合理。暂停时间设置的太短，就会导致出现G1跟不上垃圾产生的速度。最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。暂停时间只是一个目标，并不能总是得到满足。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[t("strong",[s._v("(3)使用-XX:ConcGCThreads=n来增加标记线程的数量")])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("IHOP如果阀值设置过高，可能会遇到转移失败的风险，比如对象进行转移时空间不足。如果阀值设置过低，就会使标记周期运行过于频繁，并且有可能混合收集期回收不到空间。\n\nIHOP值如果设置合理，但是在并发周期时间过长时，可以尝试增加并发线程数，调高ConcGCThreads。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[t("strong",[s._v("(4)MixedGC调优")])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("-XX:InitiatingHeapOccupancyPercent\n-XX:G1MixedGCLiveThresholdPercent\n-XX:G1MixedGCCountTarger\n-XX:G1OldCSetRegionThresholdPercent\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[s._v("(5)适当增加堆内存大小")]),s._v(" "),t("h2",{attrs:{id:"_1-3-高并发场景分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-高并发场景分析"}},[s._v("#")]),s._v(" 1.3 高并发场景分析")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311001043190.png",alt:"image-20220311001043190"}})]),s._v(" "),t("h2",{attrs:{id:"_1-4-jvm性能优化指南"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-jvm性能优化指南"}},[s._v("#")]),s._v(" 1.4 JVM性能优化指南")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311001107369.png",alt:"image-20220311001107369"}})]),s._v(" "),t("h2",{attrs:{id:"_1-5-常见问题思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-常见问题思考"}},[s._v("#")]),s._v(" 1.5 常见问题思考")]),s._v(" "),t("p",[t("strong",[s._v("（1）内存泄漏与内存溢出的区别")])]),s._v(" "),t("p",[s._v("内存泄漏：对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。")]),s._v(" "),t("p",[s._v("内存溢出：内存泄漏到一定的程度就会导致内存溢出，但是内存溢出也有可能是大对象导致的。")]),s._v(" "),t("p",[t("strong",[s._v("（2）young gc会有stw吗？")])]),s._v(" "),t("p",[s._v("不管什么 GC，都会有 stop-the-world，只是发生时间的长短。")]),s._v(" "),t("p",[t("strong",[s._v("（3）major gc和full gc的区别")])]),s._v(" "),t("p",[t("strong",[s._v("major gc指的是老年代的gc，而full gc等于young+old+metaspace的gc。")])]),s._v(" "),t("p",[t("strong",[s._v("（4）G1与CMS的区别是什么")])]),s._v(" "),t("p",[s._v("CMS 用于老年代的回收，而 G1 用于新生代和老年代的回收。 G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的产生。")]),s._v(" "),t("p",[t("strong",[s._v("（5）什么是直接内存")])]),s._v(" "),t("p",[s._v("直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于Java堆。因此出于性能的考 虑，读写频繁的场合可能会考虑使用直接内存。")]),s._v(" "),t("p",[t("strong",[s._v("（6）不可达的对象一定要被回收吗？")])]),s._v(" "),t("p",[s._v("即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对 象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此 对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机 将这两种情况视为没有必要执行。 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关 联，否则就会被真的回收。")]),s._v(" "),t("p",[t("strong",[s._v("（7）方法区中的无用类回收")])]),s._v(" "),t("p",[s._v("方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满 足下面 3 个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然 被回收。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311003339439.png",alt:"image-20220311003339439"}})]),s._v(" "),t("p",[t("strong",[s._v("（8）不同的引用")])]),s._v(" "),t("p",[s._v("JDK1.2以后，Java对引用进行了扩充：强引用、软引用、弱引用和虚引用")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311002742261.png",alt:"image-20220311002742261"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311002930038.png",alt:"image-20220311002930038"}})]),s._v(" "),t("p",[t("img",{attrs:{src:"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311003005058.png",alt:"image-20220311003005058"}})])])}),[],!1,null,null,null);a.default=n.exports}}]);