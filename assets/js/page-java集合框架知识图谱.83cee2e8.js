(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{543:function(a,t,e){"use strict";e.r(t);var s=e(1),v=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"集合关系图谱"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集合关系图谱"}},[a._v("#")]),a._v(" 集合关系图谱")]),a._v(" "),e("blockquote",[e("p",[a._v("Java集合框架包括Collection和Map，Collection主要用于存储对象，Map主要用用于存储键值对数据。\n"),e("img",{attrs:{src:"https://gitee.com/forge-logic/images-lib/raw/master/img/Java-collection-cheat-sheet.PNG",alt:"Java-Collection"}})])]),a._v(" "),e("h2",{attrs:{id:"介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[a._v("#")]),a._v(" 介绍")]),a._v(" "),e("p",[a._v("容器，就是可以容纳其他Java对象的对象。*Java Collections Framework(JCF)*为Java开发者提供了通用的容器，其始于JDK 1.2，优点是:")]),a._v(" "),e("ul",[e("li",[a._v("降低编程难度")]),a._v(" "),e("li",[a._v("提高程序性能")]),a._v(" "),e("li",[a._v("提高API间的互操作性")]),a._v(" "),e("li",[a._v("降低学习难度")]),a._v(" "),e("li",[a._v("降低设计和实现相关API的难度")]),a._v(" "),e("li",[a._v("增加程序的重用性\nJava容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。")])]),a._v(" "),e("h2",{attrs:{id:"collection"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#collection"}},[a._v("#")]),a._v(" Collection")]),a._v(" "),e("h3",{attrs:{id:"list"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[a._v("#")]),a._v(" List")]),a._v(" "),e("h4",{attrs:{id:"arraylist简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#arraylist简介"}},[a._v("#")]),a._v(" ArrayList简介")]),a._v(" "),e("p",[a._v("1.ArrayList继承自"),e("code",[a._v("AbstractList")]),a._v("，实现了"),e("code",[a._v("List")]),a._v("、"),e("code",[a._v("RandomAccess")]),a._v("、"),e("code",[a._v("Cloneable")]),a._v("、"),e("code",[a._v("Serializable")]),a._v("接口。")]),a._v(" "),e("p",[a._v("2.底层基于动态数组实现容量大小动态变化（容量可自动增长）。")]),a._v(" "),e("p",[a._v("3.允许"),e("code",[a._v("null")]),a._v("的存在。")]),a._v(" "),e("p",[a._v("4.ArrayList是支持快速访问、复制、序列化的。基于动态数组实现，支持。")]),a._v(" "),e("p",[a._v("5.ArrayList是非同步的。")]),a._v(" "),e("p",[a._v("6.ArrayList的iterator和listIterator方法返回的迭代器是fail-fast的。")]),a._v(" "),e("h4",{attrs:{id:"linkedlist"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[a._v("#")]),a._v(" LinkedList")]),a._v(" "),e("p",[a._v("1.LinkedList继承自"),e("code",[a._v("AbstractSequentialList")]),a._v("，实现了"),e("code",[a._v("List")]),a._v("、"),e("code",[a._v("Deque")]),a._v("、"),e("code",[a._v("Cloneable")]),a._v("、"),e("code",[a._v("Serializable")]),a._v("接口，LinkedList是基于链表实现的，只能顺序访问。")]),a._v(" "),e("p",[a._v("2."),e("code",[a._v("LinkedList")]),a._v("插入和删除方面要优于"),e("code",[a._v("ArrayList")]),a._v("。")]),a._v(" "),e("p",[a._v("3.LinkedList是非同步的。")]),a._v(" "),e("p",[a._v("4.LinkedList的iterator和listIterator方法返回的迭代器是fail-fast的。")]),a._v(" "),e("h3",{attrs:{id:"set"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[a._v("#")]),a._v(" Set")]),a._v(" "),e("h4",{attrs:{id:"hashset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashset"}},[a._v("#")]),a._v(" Hashset")]),a._v(" "),e("p",[a._v("1.HashSet继承自"),e("code",[a._v("AbstractSet")]),a._v(",实现了"),e("code",[a._v("Set")]),a._v("、"),e("code",[a._v("Cloneable")]),a._v("、"),e("code",[a._v("Serializable")]),a._v("接口,底层是一个HashMap。")]),a._v(" "),e("p",[a._v("2.HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。")]),a._v(" "),e("p",[a._v("3.HashSet中元素都是无序的(即存取顺序不一致)；")]),a._v(" "),e("p",[a._v("4.HashSet没有下标选取，只能通过增强for循环或者迭代器取出元素；")]),a._v(" "),e("p",[a._v("5.HashSet是非同步的；")]),a._v(" "),e("p",[a._v("6.HashSet的iterator方法返回的迭代器是fail-fast的。")]),a._v(" "),e("h4",{attrs:{id:"linkedhashset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashset"}},[a._v("#")]),a._v(" LinkedHashSet")]),a._v(" "),e("p",[a._v("1.LinkedHashSet继承自"),e("code",[a._v("HashSet")]),a._v("，实现了"),e("code",[a._v("Set")]),a._v("、"),e("code",[a._v("Cloneable")]),a._v("接口，底层其实是一个LinkedHashMap。")]),a._v(" "),e("p",[a._v("2.不能保证插入和输出的顺序一致。")]),a._v(" "),e("p",[a._v("3.不允许重复的元素插入，可以插入null。")]),a._v(" "),e("p",[a._v("4.HashSet的iterator方法返回的迭代器是fail-fast的。")]),a._v(" "),e("h4",{attrs:{id:"treeset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#treeset"}},[a._v("#")]),a._v(" TreeSet")]),a._v(" "),e("h3",{attrs:{id:"queue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[a._v("#")]),a._v(" Queue")]),a._v(" "),e("h4",{attrs:{id:"deque"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#deque"}},[a._v("#")]),a._v(" Deque")]),a._v(" "),e("h4",{attrs:{id:"arraydeque"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#arraydeque"}},[a._v("#")]),a._v(" ArrayDeque")]),a._v(" "),e("h2",{attrs:{id:"map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[a._v("#")]),a._v(" Map")]),a._v(" "),e("h3",{attrs:{id:"hashmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),e("p",[a._v("1.HashMap 基于哈希表的Map接口实现，是以 key-value 存储形式存在，即主要用来存放键值对")]),a._v(" "),e("p",[a._v("2.HashMap 的实现不是同步的，这意味着它不是线程安全的")]),a._v(" "),e("p",[a._v("3.HashMap 中的映射不是有序的(即存取顺序不一致)")]),a._v(" "),e("p",[a._v("4.实现结构是 数组+链表+红黑树")]),a._v(" "),e("h3",{attrs:{id:"linkedhashmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashmap"}},[a._v("#")]),a._v(" LinkedHashMap")]),a._v(" "),e("h3",{attrs:{id:"hashtable"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashtable"}},[a._v("#")]),a._v(" HashTable")]),a._v(" "),e("p",[a._v("1.与HashMap一样，Hashtable也是一个散列表，是以key-value存储形式存在，即主要用来存放键值对；")]),a._v(" "),e("p",[a._v("2.与HashMap不同，Hashtable的函数都是同步的，这意味着它是线程安全的；")]),a._v(" "),e("p",[a._v("3.Hashtable的key、value都不可以为null，并且，Hashtable中的映射不是有序的；")]),a._v(" "),e("p",[a._v("4.实现结构是数组+单向链表。")])])}),[],!1,null,null,null);t.default=v.exports}}]);