import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as r,f as i}from"./app-be4339cd.js";const t={},d=i('<h2 id="集合关系图谱" tabindex="-1"><a class="header-anchor" href="#集合关系图谱" aria-hidden="true">#</a> 集合关系图谱</h2><blockquote><p>Java集合框架包括Collection和Map，Collection主要用于存储对象，Map主要用用于存储键值对数据。<br><img src="https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Java-collection-cheat-sheet.PNG" alt="Java-Collection" loading="lazy"></p></blockquote><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h2><p>容器，就是可以容纳其他Java对象的对象。*Java Collections Framework(JCF)*为Java开发者提供了通用的容器，其始于JDK 1.2，优点是:</p><ul><li>降低编程难度</li><li>提高程序性能</li><li>提高API间的互操作性</li><li>降低学习难度</li><li>降低设计和实现相关API的难度</li><li>增加程序的重用性<br> Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</li></ul><h2 id="collection" tabindex="-1"><a class="header-anchor" href="#collection" aria-hidden="true">#</a> Collection</h2><h3 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h3><h4 id="arraylist简介" tabindex="-1"><a class="header-anchor" href="#arraylist简介" aria-hidden="true">#</a> ArrayList简介</h4><p>1.ArrayList继承自<code>AbstractList</code>，实现了<code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code>接口。</p><p>2.底层基于动态数组实现容量大小动态变化（容量可自动增长）。</p><p>3.允许<code>null</code>的存在。</p><p>4.ArrayList是支持快速访问、复制、序列化的。基于动态数组实现，支持。</p><p>5.ArrayList是非同步的。</p><p>6.ArrayList的iterator和listIterator方法返回的迭代器是fail-fast的。</p><h4 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist" aria-hidden="true">#</a> LinkedList</h4><p>1.LinkedList继承自<code>AbstractSequentialList</code>，实现了<code>List</code>、<code>Deque</code>、<code>Cloneable</code>、<code>Serializable</code>接口，LinkedList是基于链表实现的，只能顺序访问。</p><p>2.<code>LinkedList</code>插入和删除方面要优于<code>ArrayList</code>。</p><p>3.LinkedList是非同步的。</p><p>4.LinkedList的iterator和listIterator方法返回的迭代器是fail-fast的。</p><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h3><h4 id="hashset" tabindex="-1"><a class="header-anchor" href="#hashset" aria-hidden="true">#</a> Hashset</h4><p>1.HashSet继承自<code>AbstractSet</code>,实现了<code>Set</code>、<code>Cloneable</code>、<code>Serializable</code>接口,底层是一个HashMap。</p><p>2.HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。</p><p>3.HashSet中元素都是无序的(即存取顺序不一致)；</p><p>4.HashSet没有下标选取，只能通过增强for循环或者迭代器取出元素；</p><p>5.HashSet是非同步的；</p><p>6.HashSet的iterator方法返回的迭代器是fail-fast的。</p><h4 id="linkedhashset" tabindex="-1"><a class="header-anchor" href="#linkedhashset" aria-hidden="true">#</a> LinkedHashSet</h4><p>1.LinkedHashSet继承自<code>HashSet</code>，实现了<code>Set</code>、<code>Cloneable</code>接口，底层其实是一个LinkedHashMap。</p><p>2.不能保证插入和输出的顺序一致。</p><p>3.不允许重复的元素插入，可以插入null。</p><p>4.HashSet的iterator方法返回的迭代器是fail-fast的。</p><h4 id="treeset" tabindex="-1"><a class="header-anchor" href="#treeset" aria-hidden="true">#</a> TreeSet</h4><p>1.TreeSet继承自<code>AbstractSet</code>，实现了NavigableSet、Cloneable、Serializable接口。</p><p>2.一种基于<code>TreeMap</code>的<code>NavigableSet</code>实现,意味着它支持一系列的导航方法。</p><p>3.TreeSet是有序的Set集合,通过<code>TreeMap</code>实现的一个有序的、不可重复的集合，底层维护的是红黑树结构。</p><p>4.TreeSet的iterator方法返回的迭代器是fail-fast的。</p><h3 id="queue" tabindex="-1"><a class="header-anchor" href="#queue" aria-hidden="true">#</a> Queue</h3><h4 id="arraydeque" tabindex="-1"><a class="header-anchor" href="#arraydeque" aria-hidden="true">#</a> ArrayDeque</h4><p>1.ArrayDeque是Deque接口的一个实现，使用了可变数组，所以没有容量上的限制。</p><p>2.ArrayDeque是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。</p><p>3.ArrayDeque是Deque的实现类，可以作为栈来使用，效率高于Stack；<br> 也可以作为队列来使用，效率高于LinkedList。</p><p>4.ArrayDeque不支持null值。</p><p>5.ArrayDeque的iterator方法返回的迭代器是fail-fast的。</p><p>6.ArrayDeque两端都可以操作,支持双向迭代器遍历。</p><h4 id="priorityqueue" tabindex="-1"><a class="header-anchor" href="#priorityqueue" aria-hidden="true">#</a> PriorityQueue</h4><p>1.PriorityQueue继承自<code>AbstractQueue</code>，实现了<code>Serializable</code>接口。</p><p>2.PriorityQueue队列元素根据自然排序或者根据具体的比较器排序。</p><p>3.PriorityQueue实例化时若未指定初始容量，默认容量为11。</p><p>4.PriorityQueue自动扩容。如果容量小于64，两倍增长扩容；否则增长50%,PriorityQueue是无边界容器。</p><p>5.PriorityQueue的迭代器不具有以特定顺序访问队列元素。</p><p>6.PriorityQueue不支持<code>null</code>元素。</p><p>7.PriorityQueue入队出队的时间复杂度O(log(n))</p><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h2><h3 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h3><p>1.HashMap继承自<code>AbstractMap</code>,实现<code>Map</code>、<code>Cloneable</code>、<code>Serializable</code>接口。</p><p>2.HashMap 基于哈希表的Map接口实现，是以 key-value 存储形式存在，即主要用来存放键值对。</p><p>3.HashMap 的实现不是同步的，这意味着它不是线程安全的。</p><p>4.HashMap 中的映射不是有序的(即存取顺序不一致)。</p><p>5.JDK1.5-JDK1.7实现的结果是数组+链表，JDK1.8实现结构是数组+链表+红黑树。</p><p>6.HashMap key值能为null,value值可以为null，且key值不允许重复。</p><p>7.HashMap的iterator方法返回的迭代器是fail-fastl的。</p><h3 id="linkedhashmap" tabindex="-1"><a class="header-anchor" href="#linkedhashmap" aria-hidden="true">#</a> LinkedHashMap</h3><p>1.LinkedHashMap继承自<code>HashMap</code>,实现了<code>Map</code>接口。</p><p>2.LinkedHashMap维护了一个Entry的双向链表，保证了插入的Entry中的顺序。</p><p>3.使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</p><p>4.LinkedHashMap的iterator方法返回的迭代器是fail-fastl的。</p><h3 id="treemap" tabindex="-1"><a class="header-anchor" href="#treemap" aria-hidden="true">#</a> TreeMap</h3><p>1.TreeMap 继承自AbstractMap，实现了<code>NavigableMap</code>、<code>Cloneable</code>、<code>Serializable接口</code>。</p><p>2.TreeMap不允许出现重复的key。</p><p>3.TreeMap可以插入null键，null值。</p><p>4.TreeMap可以对元素进行排序。</p><p>5.TreeMap无序集合（插入和遍历顺序不一致）。</p><p>6.TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的Comparator进行排序，具体取决于使用的构造方法。</p><p>7.TreeMap的iterator方法返回的迭代器是fail-fastl的。</p><h3 id="hashtable" tabindex="-1"><a class="header-anchor" href="#hashtable" aria-hidden="true">#</a> HashTable</h3><p>1.与HashMap一样，Hashtable也是一个散列表，是以key-value存储形式存在，即主要用来存放键值对；</p><p>2.与HashMap不同，Hashtable的函数都是同步的，这意味着它是线程安全的；</p><p>3.Hashtable的key、value都不可以为null，并且，Hashtable中的映射不是有序的；</p><p>4.实现结构是数组+单向链表。</p>',80),o=[d];function p(h,l){return a(),r("div",null,o)}const n=e(t,[["render",p],["__file","index.html.vue"]]);export{n as default};
