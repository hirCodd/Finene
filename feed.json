{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Moremind's Blog",
  "home_page_url": "https://www.moremind.cn/",
  "feed_url": "https://www.moremind.cn/feed.json",
  "description": "Stay Hungry, Stay Foolish!",
  "author": {
    "name": "Moremind"
  },
  "items": [
    {
      "title": "My Book For 2022",
      "url": "https://www.moremind.cn/book/",
      "id": "https://www.moremind.cn/book/",
      "content_html": "<h2 id=\"_2022-阅读书籍\"> 2022 阅读书籍</h2>\n<h3 id=\"专业书籍\"> 专业书籍</h3>\n<ul>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> Plan A</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> Plan B</label></li>\n</ul>\n<h3 id=\"非专业书籍\"> 非专业书籍</h3>\n<ul>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-2\"><label for=\"task-item-2\"> 结构性改革-中国经济的问题与对策</label></li>\n</ul>\n",
      "date_published": "2022-01-01T00:00:00.000Z",
      "date_modified": "2022-04-06T13:44:30.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": []
    },
    {
      "title": "友链",
      "url": "https://www.moremind.cn/friends/",
      "id": "https://www.moremind.cn/friends/",
      "content_html": "<h3 id=\"左领右舍\"> 左领右舍</h3>\n<table>\n<thead>\n<tr>\n<th>✌️✌️名称</th>\n<th style=\"text-align:left\">👍👍链接</th>\n<th style=\"text-align:center\">简介🎉 💯</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>南瓜慢说</td>\n<td style=\"text-align:left\"><a href=\"https://www.pkslow.com/\" target=\"_blank\" rel=\"noopener noreferrer\">南瓜慢说</a></td>\n<td style=\"text-align:center\">a niubility man</td>\n</tr>\n<tr>\n<td>云扬四海</td>\n<td style=\"text-align:left\"><a href=\"https://www.cnblogs.com/yunlongn/\" target=\"_blank\" rel=\"noopener noreferrer\">云扬四海</a></td>\n<td style=\"text-align:center\">源码大佬</td>\n</tr>\n<tr>\n<td>赵俊</td>\n<td style=\"text-align:left\"><a href=\"http://www.zhaojun.im/\" target=\"_blank\" rel=\"noopener noreferrer\">赵俊的博客</a></td>\n<td style=\"text-align:center\">一个 Java 学习者的博客</td>\n</tr>\n<tr>\n<td>R'Blog</td>\n<td style=\"text-align:left\"><a href=\"http://bolg.rvich.com/\" target=\"_blank\" rel=\"noopener noreferrer\">R'Blog</a></td>\n<td style=\"text-align:center\">分享资源</td>\n</tr>\n<tr>\n<td>随遇而安</td>\n<td style=\"text-align:left\"><a href=\"https://www.iszy.cc/\" target=\"_blank\" rel=\"noopener noreferrer\">随遇而安</a></td>\n<td style=\"text-align:center\">技术分享&amp;生活吐槽</td>\n</tr>\n<tr>\n<td>GongJS</td>\n<td style=\"text-align:left\"><a href=\"https://gongjs.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">GongJS</a></td>\n<td style=\"text-align:center\">Talk is cheap,show me the code.</td>\n</tr>\n<tr>\n<td>谭升的博客</td>\n<td style=\"text-align:left\"><a href=\"https://face2ai.com\" target=\"_blank\" rel=\"noopener noreferrer\">谭升的博客</a></td>\n<td style=\"text-align:center\">人工智能算法，数学基础类原创博客</td>\n</tr>\n<tr>\n<td>冰水鉴心的博客</td>\n<td style=\"text-align:left\"><a href=\"https://xq773939719.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">冰水鉴心的博客</a></td>\n<td style=\"text-align:center\">.软工渣.编程痴.开发宅.系统迷.强迫症</td>\n</tr>\n<tr>\n<td>LmCjl在线工具</td>\n<td style=\"text-align:left\"><a href=\"https://www.lmcjl.com\" target=\"_blank\" rel=\"noopener noreferrer\">LmCjl在线工具</a></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>YuYe</td>\n<td style=\"text-align:left\"><a href=\"https://chenyeah.com/\" target=\"_blank\" rel=\"noopener noreferrer\">YuYe</a></td>\n<td style=\"text-align:center\">专注于前端技术</td>\n</tr>\n<tr>\n<td>笨小孩杂谈</td>\n<td style=\"text-align:left\"><a href=\"https://rocky-191.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">笨小孩杂谈</a></td>\n<td style=\"text-align:center\">专注前端技术</td>\n</tr>\n<tr>\n<td>yoko blog</td>\n<td style=\"text-align:left\"><a href=\"https://pengrl.com\" target=\"_blank\" rel=\"noopener noreferrer\">yoko blog</a></td>\n<td style=\"text-align:center\">目前主要写些c++和Go语言方面的博客</td>\n</tr>\n<tr>\n<td>六阿哥博客</td>\n<td style=\"text-align:left\"><a href=\"https://blog.6ag.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">六阿哥博客</a></td>\n<td style=\"text-align:center\">记录一个程序员的成长历程</td>\n</tr>\n<tr>\n<td>枫糖</td>\n<td style=\"text-align:left\"><a href=\"https://blog.maplesugar.top\" target=\"_blank\" rel=\"noopener noreferrer\">枫糖</a></td>\n<td style=\"text-align:center\">From rookie to master</td>\n</tr>\n<tr>\n<td>Serence</td>\n<td style=\"text-align:left\"><a href=\"https://blog.blinkstar.cn\" target=\"_blank\" rel=\"noopener noreferrer\">Serence</a></td>\n<td style=\"text-align:center\">一个程序员 + 文艺青年的博客</td>\n</tr>\n<tr>\n<td>羽叶丶</td>\n<td style=\"text-align:left\"><a href=\"https://yuye.fun\" target=\"_blank\" rel=\"noopener noreferrer\">羽叶丶</a></td>\n<td style=\"text-align:center\">羽叶丶的个人博客</td>\n</tr>\n<tr>\n<td>飞跃高山和大洋的🐟</td>\n<td style=\"text-align:left\"><a href=\"https://timspan.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">飞跃高山和大洋的🐟</a></td>\n<td style=\"text-align:center\">前端</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"优秀技术博客\"> 优秀技术博客</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th style=\"text-align:left\">链接</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>美团技术团队</td>\n<td style=\"text-align:left\"><a href=\"https://tech.meituan.com/\" target=\"_blank\" rel=\"noopener noreferrer\">美团技术团队</a></td>\n<td style=\"text-align:center\">美团技术团队相关文档</td>\n</tr>\n<tr>\n<td>FEX技术周刊</td>\n<td style=\"text-align:left\"><a href=\"http://fex.baidu.com/\" target=\"_blank\" rel=\"noopener noreferrer\">FEX技术周刊</a></td>\n<td style=\"text-align:center\">FEX技术周刊</td>\n</tr>\n<tr>\n<td>前端精读周刊</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/dt-fe/weekly\" target=\"_blank\" rel=\"noopener noreferrer\">前端精读周刊</a></td>\n<td style=\"text-align:center\">前端精读周刊</td>\n</tr>\n<tr>\n<td>前端资源汇总仓库</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/helloqingfeng/Awsome-Front-End-learning-resource\" target=\"_blank\" rel=\"noopener noreferrer\">前端资源汇总仓库</a></td>\n<td style=\"text-align:center\">前端资源汇总仓库</td>\n</tr>\n<tr>\n<td>后端架构师技术图谱</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/xingshaocheng/architect-awesome\" target=\"_blank\" rel=\"noopener noreferrer\">后端架构师技术图谱</a></td>\n<td style=\"text-align:center\">后端架构师技术图谱</td>\n</tr>\n<tr>\n<td>CS-NOTES</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/CyC2018/CS-Notes\" target=\"_blank\" rel=\"noopener noreferrer\">CS-NOTES</a></td>\n<td style=\"text-align:center\">CS-NOTES</td>\n</tr>\n<tr>\n<td>JAVA-进阶</td>\n<td style=\"text-align:left\"><a href=\"https://doocs.gitee.io/advanced-java/#/\" target=\"_blank\" rel=\"noopener noreferrer\">JAVA-进阶</a></td>\n<td style=\"text-align:center\">JAVA-进阶</td>\n</tr>\n<tr>\n<td>经典编程书籍大全</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/jobbole/awesome-programming-books\" target=\"_blank\" rel=\"noopener noreferrer\">经典编程书籍大全</a></td>\n<td style=\"text-align:center\">经典编程书籍大全</td>\n</tr>\n<tr>\n<td>代码日志</td>\n<td style=\"text-align:left\"><a href=\"https://codeday.me/\" target=\"_blank\" rel=\"noopener noreferrer\">代码日志</a></td>\n<td style=\"text-align:center\">代码日志</td>\n</tr>\n<tr>\n<td>阿里中间件团队博客</td>\n<td style=\"text-align:left\"><a href=\"http://jm.taobao.org/\" target=\"_blank\" rel=\"noopener noreferrer\">阿里中间件团队博客</a></td>\n<td style=\"text-align:center\">阿里中间件团队博客</td>\n</tr>\n<tr>\n<td>自然语言处理</td>\n<td style=\"text-align:left\"><a href=\"http://www.hankcs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">自然语言处理</a></td>\n<td style=\"text-align:center\">自然语言处理</td>\n</tr>\n<tr>\n<td>崔庆才的个人博客</td>\n<td style=\"text-align:left\"><a href=\"https://cuiqingcai.com/\" target=\"_blank\" rel=\"noopener noreferrer\">崔庆才的个人博客</a></td>\n<td style=\"text-align:center\">崔庆才的个人博客</td>\n</tr>\n<tr>\n<td>Frank</td>\n<td style=\"text-align:left\"><a href=\"https://www.frankfeekr.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">Frank</a></td>\n<td style=\"text-align:center\">Frank的个人博客</td>\n</tr>\n<tr>\n<td>并发编程网</td>\n<td style=\"text-align:left\"><a href=\"http://ifeve.com/\" target=\"_blank\" rel=\"noopener noreferrer\">并发编程网</a></td>\n<td style=\"text-align:center\">并发编程网</td>\n</tr>\n<tr>\n<td>java与cs-base</td>\n<td style=\"text-align:left\"><a href=\"http://java.isture.com/\" target=\"_blank\" rel=\"noopener noreferrer\">java与cs-base</a></td>\n<td style=\"text-align:center\">java与cs-base</td>\n</tr>\n</tbody>\n</table>\n<div><p>提示</p>\n<p>欢迎留言提交互加友链!最好提供你网站的简介哟<br>\n如果您需要更改您的链接或者链接有错误，请联系我: <a href=\"mailto:hefengen@hotmail.com\">hefengen@hotmail.com</a></p>\n</div>\n<div><p>我的个人链接</p>\n<p>昵称：Finen<br>\n链接：https://www.finen.top/<br>\n头像链接：https://finen-1251602255.cos.ap-shanghai.myqcloud.com/file/pic/finen.png<br>\n介绍：Stay Hungry! Stay Foolish!</p>\n</div>\n",
      "date_published": "2018-04-28T00:00:00.000Z",
      "date_modified": "2022-08-19T01:20:12.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": []
    },
    {
      "title": "Project home",
      "url": "https://www.moremind.cn/home/",
      "id": "https://www.moremind.cn/home/",
      "content_html": "<p>This is an example of a normal homepage. You can place your main content here.</p>\n<p>To use this layout, you need to set <code>home: true</code> in the page front matter.</p>\n<p>For related descriptions of configuration items, please see <a href=\"https://vuepress-theme-hope.github.io/guide/layout/home/\" target=\"_blank\" rel=\"noopener noreferrer\">Project HomePage Layout Config</a>.</p>\n",
      "date_published": "2022-01-12T12:29:41.000Z",
      "date_modified": "2022-01-12T12:29:41.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": []
    },
    {
      "title": "Intro Page",
      "url": "https://www.moremind.cn/intro/",
      "id": "https://www.moremind.cn/intro/",
      "content_html": "<h1 id=\"intro-page\"> Intro Page</h1>\n<p>Place your introducation and profile here.</p>\n",
      "date_published": "2022-01-12T12:29:41.000Z",
      "date_modified": "2022-01-14T09:08:36.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": []
    },
    {
      "title": "算法",
      "url": "https://www.moremind.cn/md/construct/construct/",
      "id": "https://www.moremind.cn/md/construct/construct/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-13T16:50:45.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "算法",
      "url": "https://www.moremind.cn/md/construct/design/",
      "id": "https://www.moremind.cn/md/construct/design/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-13T16:50:45.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "算法",
      "url": "https://www.moremind.cn/md/cs/alg/",
      "id": "https://www.moremind.cn/md/cs/alg/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-13T16:50:45.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "数据结构",
      "url": "https://www.moremind.cn/md/cs/datastructure/",
      "id": "https://www.moremind.cn/md/cs/datastructure/",
      "content_html": "<p>JVM 内存分析图\nJVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-13T16:50:45.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "计算机网络",
      "url": "https://www.moremind.cn/md/cs/network/",
      "id": "https://www.moremind.cn/md/cs/network/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-13T16:50:45.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "操作系统",
      "url": "https://www.moremind.cn/md/cs/os/",
      "id": "https://www.moremind.cn/md/cs/os/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-13T16:50:45.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "hibernate",
      "url": "https://www.moremind.cn/md/data-persistence/hibernate/",
      "id": "https://www.moremind.cn/md/data-persistence/hibernate/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Hibernate"
      ]
    },
    {
      "title": "jpa",
      "url": "https://www.moremind.cn/md/data-persistence/jpa/",
      "id": "https://www.moremind.cn/md/data-persistence/jpa/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "JPA"
      ]
    },
    {
      "title": "mybatis-进阶",
      "url": "https://www.moremind.cn/md/data-persistence/mybatis-advance/",
      "id": "https://www.moremind.cn/md/data-persistence/mybatis-advance/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-21T15:41:02.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Mybaits"
      ]
    },
    {
      "title": "mybatis",
      "url": "https://www.moremind.cn/md/data-persistence/mybatis/",
      "id": "https://www.moremind.cn/md/data-persistence/mybatis/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Mybaits"
      ]
    },
    {
      "title": "数据库进阶",
      "url": "https://www.moremind.cn/md/db/db-advance/",
      "id": "https://www.moremind.cn/md/db/db-advance/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-14T17:15:37.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Relation-Database"
      ]
    },
    {
      "title": "数据库知识体系",
      "url": "https://www.moremind.cn/md/db/db-basic/",
      "id": "https://www.moremind.cn/md/db/db-basic/",
      "content_html": "<p>数据库基础知识体系</p>\n",
      "date_published": "2022-01-14T17:15:37.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Relation-Database"
      ]
    },
    {
      "title": "MySQL知识体系",
      "url": "https://www.moremind.cn/md/db/db-mysql/",
      "id": "https://www.moremind.cn/md/db/db-mysql/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-21T15:41:02.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "MySQL"
      ]
    },
    {
      "title": "Elasticsearch知识体系",
      "url": "https://www.moremind.cn/md/db/db-nosql-elasticsearch/",
      "id": "https://www.moremind.cn/md/db/db-nosql-elasticsearch/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-21T15:41:02.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Elasticsearch"
      ]
    },
    {
      "title": "Redis知识体系",
      "url": "https://www.moremind.cn/md/db/db-nosql-redis/",
      "id": "https://www.moremind.cn/md/db/db-nosql-redis/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-21T15:41:02.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Redis"
      ]
    },
    {
      "title": "JVM源码解读-Boolean类",
      "url": "https://www.moremind.cn/md/java/basic/Boolean/",
      "id": "https://www.moremind.cn/md/java/basic/Boolean/",
      "content_html": "<h2 id=\"_1-类图\"> 1.类图</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Boolean.png\" alt=\"Boolean-Class\" /></p>\n<h2 id=\"_2-存储位置\"> 2.存储位置</h2>\n<ul>\n<li>Boolean类中有两个状态码，TRUE和FALSE，这两个属性存在<code>JVM方法区的静态区</code>，对应源码如下：</li>\n</ul>\n<div><pre><code>    <span>/**\n     * The {@code Boolean} object corresponding to the primitive\n     * value {@code true}.\n     */</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>Boolean</span> TRUE <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>true</span><span>)</span><span>;</span>\n\n    <span>/**\n     * The {@code Boolean} object corresponding to the primitive\n     * value {@code false}.\n     */</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>Boolean</span> FALSE <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>false</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>\n<li>通过new Boolean()创建的对象都存储在堆区。</li>\n</ul>\n<h2 id=\"_3-源码解读\"> 3.源码解读</h2>\n<h3 id=\"_3-1-核心方法\"> 3.1 核心方法</h3>\n<h4 id=\"boolean构造方法\"> Boolean构造方法</h4>\n<ul>\n<li>从Java9开始弃用</li>\n</ul>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Boolean</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span>\n        <span>Comparable</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> <span>{</span>\n    <span>// 将传过来的boolean作为参数</span>\n    <span>public</span> <span>Boolean</span><span>(</span><span>boolean</span> value<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n    <span>}</span>\n\n    <span>// 将输入拖来的字符串解析为true或者false</span>\n    <span>public</span> <span>Boolean</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n        <span>this</span><span>(</span><span>parseBoolean</span><span>(</span>s<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>BooleanDemoTest</span> <span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testBoolean</span><span>(</span><span>)</span> <span>{</span>\n        <span>Boolean</span> b1 <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>\"TRue\"</span><span>)</span><span>;</span> <span>// true</span>\n        <span>Boolean</span> b2 <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>\"True\"</span><span>)</span><span>;</span> <span>// true</span>\n\n        <span>Boolean</span> b3 <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>\"fAlse\"</span><span>)</span><span>;</span> <span>// false</span>\n        <span>Boolean</span> b4 <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>\"False\"</span><span>)</span><span>;</span> <span>// false</span>\n        <span>Boolean</span> b5 <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>\"Trrue\"</span><span>)</span><span>;</span> <span>// false</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id=\"valueof方法\"> valueOf方法</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Boolean</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span>\n        <span>Comparable</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> <span>{</span>\n    <span>// 根据值返回TRUE或者FALSE，对应Boolean的两个属性</span>\n    <span>public</span> <span>static</span> <span>Boolean</span> <span>valueOf</span><span>(</span><span>boolean</span> b<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>b <span>?</span> TRUE <span>:</span> FALSE<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>Boolean</span> <span>valueOf</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n        <span>return</span> <span>parseBoolean</span><span>(</span>s<span>)</span> <span>?</span> TRUE <span>:</span> FALSE<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id=\"parseboolean方法\"> parseBoolean方法</h4>\n<p>该方法是将字符串值转为对应boolean值，如果传入的值为true或者false的大小写，则返回true或者false，如果传入不是true或者false(null或者其他)，则返回false</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Boolean</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span>\n<span>Comparable</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>boolean</span> <span>parseBoolean</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span>s <span>!=</span> <span>null</span><span>)</span> <span>&amp;&amp;</span> s<span>.</span><span>equalsIgnoreCase</span><span>(</span><span>\"true\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>BooleanDemoTest</span> <span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testParseBoolean</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>parseBoolean</span><span>(</span><span>null</span><span>)</span><span>)</span><span>;</span>    <span>// false</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>parseBoolean</span><span>(</span><span>\"True\"</span><span>)</span><span>)</span><span>;</span>  <span>// true</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>parseBoolean</span><span>(</span><span>\"False\"</span><span>)</span><span>)</span><span>;</span> <span>// false</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>parseBoolean</span><span>(</span><span>\"ttur\"</span><span>)</span><span>)</span><span>;</span>  <span>// false</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id=\"booleanvalue方法\"> booleanValue方法</h4>\n<p>将对应的Boolean值转为对应的boolean值。</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Boolean</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span>\n<span>Comparable</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>boolean</span> <span>booleanValue</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> value<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id=\"tostring方法\"> toString方法</h4>\n<p>该方法是将boolean值转为对应的boolean字符串</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Boolean</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span>\n<span>Comparable</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> <span>{</span>\n    <span>// 根据不同的boolean值返回对应boolean字符串</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>toString</span><span>(</span><span>boolean</span> b<span>)</span> <span>{</span>\n        <span>return</span> b <span>?</span> <span>\"true\"</span> <span>:</span> <span>\"false\"</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> value <span>?</span> <span>\"true\"</span> <span>:</span> <span>\"false\"</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id=\"getboolean方法\"> getBoolean方法</h4>\n<p>该方法是获取系统设置的参数，并且将对应的参数转为true或者false，如果没有获取到参数或者获取错误都返回false。</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Boolean</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span>\n<span>Comparable</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>boolean</span> <span>getBoolean</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>boolean</span> result <span>=</span> <span>false</span><span>;</span>\n        <span>try</span> <span>{</span>\n            result <span>=</span> <span>parseBoolean</span><span>(</span><span>System</span><span>.</span><span>getProperty</span><span>(</span>name<span>)</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>IllegalArgumentException</span> <span>|</span> <span>NullPointerException</span> e<span>)</span> <span>{</span>\n        <span>}</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>BooleanDemoTest</span> <span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testGetBoolean</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span><span>setProperty</span><span>(</span><span>\"test-boolean\"</span><span>,</span> <span>\"55\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>getBoolean</span><span>(</span><span>\"test-boolean\"</span><span>)</span><span>)</span><span>;</span> <span>// false</span>\n        <span>System</span><span>.</span><span>setProperty</span><span>(</span><span>\"test-boolean2\"</span><span>,</span> <span>\"true\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>getBoolean</span><span>(</span><span>\"test-boolean2\"</span><span>)</span><span>)</span><span>;</span> <span>// true</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id=\"compare方法\"> compare方法</h4>\n<p>该方法是比较两个boolean值，并且返回对应的int值，如果两个值相等则返回0，如果两个值不等，则返回1或者-1，如果第一个值是false则返回-1，如果第一个值为true则返回1</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Boolean</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span>\n<span>Comparable</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>compare</span><span>(</span><span>boolean</span> x<span>,</span> <span>boolean</span> y<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>x <span>==</span> y<span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>x <span>?</span> <span>1</span> <span>:</span> <span>-</span><span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>BooleanDemoTest</span> <span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testCompare</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>compare</span><span>(</span><span>true</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span> <span>// 0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>compare</span><span>(</span><span>true</span><span>,</span> <span>false</span><span>)</span><span>)</span><span>;</span> <span>// 1</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>compare</span><span>(</span><span>false</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span> <span>// -1</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>compare</span><span>(</span><span>false</span><span>,</span> <span>false</span><span>)</span><span>)</span><span>;</span> <span>// 0</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id=\"logicaland方法\"> logicalAnd方法</h4>\n<p>逻辑和方法，该方法要求两个值必须同时满足才返回true，否则返回false</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Boolean</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span>\n<span>Comparable</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>boolean</span> <span>logicalAnd</span><span>(</span><span>boolean</span> a<span>,</span> <span>boolean</span> b<span>)</span> <span>{</span>\n        <span>return</span> a <span>&amp;&amp;</span> b<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>BooleanDemoTest</span> <span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testLogicalAnd</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>logicalAnd</span><span>(</span><span>true</span><span>,</span> <span>false</span><span>)</span><span>)</span><span>;</span> <span>// false</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>logicalAnd</span><span>(</span><span>true</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span> <span>// true</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>logicalAnd</span><span>(</span><span>false</span><span>,</span> <span>false</span><span>)</span><span>)</span><span>;</span> <span>// false</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id=\"logicalor方法\"> logicalOr方法</h4>\n<p>逻辑或方法，传入的两个boolean值只要有一个为true则返回true，否则返回false</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Boolean</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span>\n<span>Comparable</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>boolean</span> <span>logicalOr</span><span>(</span><span>boolean</span> a<span>,</span> <span>boolean</span> b<span>)</span> <span>{</span>\n        <span>return</span> a <span>||</span> b<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>BooleanDemoTest</span> <span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testLogicalOr</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>logicalOr</span><span>(</span><span>true</span><span>,</span> <span>false</span><span>)</span><span>)</span><span>;</span> <span>// true</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>logicalOr</span><span>(</span><span>false</span><span>,</span> <span>false</span><span>)</span><span>)</span><span>;</span> <span>// false</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id=\"logicalxor方法\"> logicalXor方法</h4>\n<p>该方法返回对分配的布尔操作数执行逻辑异或运算的结果。</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Boolean</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span>\n<span>Comparable</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>boolean</span> <span>logicalXor</span><span>(</span><span>boolean</span> a<span>,</span> <span>boolean</span> b<span>)</span> <span>{</span>\n        <span>return</span> a <span>^</span> b<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>BooleanDemoTest</span> <span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testLogicalXor</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>logicalXor</span><span>(</span><span>true</span><span>,</span> <span>false</span><span>)</span><span>)</span><span>;</span>  <span>// true</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>logicalXor</span><span>(</span><span>false</span><span>,</span> <span>false</span><span>)</span><span>)</span><span>;</span> <span>// false</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>logicalXor</span><span>(</span><span>false</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>  <span>// true</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Boolean</span><span>.</span><span>logicalXor</span><span>(</span><span>true</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>   <span>// false</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"_4-使用建议\"> 4.使用建议</h2>\n<ul>\n<li>推荐使用Boolean.TRUE或Boolean.valueOf(true)或Boolean.valueOf(&quot;true&quot;)，避免重复创建对象</li>\n<li>两个值进行比较时，使用Boolean.TRUE.equals(xxx)进行判断</li>\n</ul>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Boolean.png",
      "date_published": "2022-11-08T16:22:31.000Z",
      "date_modified": "2022-11-09T02:16:12.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM源码解读-Float类",
      "url": "https://www.moremind.cn/md/java/basic/Float/",
      "id": "https://www.moremind.cn/md/java/basic/Float/",
      "content_html": "<h2 id=\"_1-类图\"> 1.类图</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Float.png\" alt=\"Float-Class\" /></p>\n<h2 id=\"_2-存储位置\"> 2.存储位置</h2>\n<ul>\n<li>Float类中的静态属性存储在方法区中的静态区。</li>\n<li>通过new Float()方法创建出来的对象存储在堆区。</li>\n</ul>\n<h2 id=\"_3-了解ieee-754\"> 3.了解IEEE 754</h2>\n<h3 id=\"_3-1-ieee-754简介\"> 3.1 IEEE 754简介</h3>\n<p>在看Float前需要先了解IEEE 754标准，该标准定义了浮点数的格式还有一些特殊值，它规定了计算机中二进制与十进制浮点数转换的格式及方法。规定了四种表示浮点数值的方法，单精确度（32位）、双精确度（64位）、延伸单精确度（43位以上）与延伸双精确度（79位以上）。\n多数编程语言支持单精确度和双精确度，该标准的全称为IEEE二进制浮点数算术标准（ANSI/IEEE Std 754-1985），又称IEC 60559:1989，微处理器系统的二进制浮点数算术（本来的编号是IEC 559:1989）。后来还有“与基数无关的浮点数”的“IEEE 854-1987标准”，有规定基数为2跟10的状况。最新标准是“ISO/IEC/IEEE FDIS 60559:2010”。\nFloat就是Java的单精度实现。</p>\n<h3 id=\"_3-2-ieee-754单精度浮点数表示\"> 3.2 IEEE 754单精度浮点数表示</h3>\n<p>浮点数由三部分组成，分别是符号位s、指数e和尾数f。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/1668009317049.jpg\" alt=\"\" /></p>\n<p>在IEEE754标准中，一个规格化的32位浮点数x的真值表示为\nx = (−1)s∗(1.f)∗2(e−127)\ne = E - 127</p>\n<p>其中尾数域所表示的值是1.f。由于规格化的浮点数的尾数域最左位（最高有效位）总是1，故这一位经常不予存储，而认为隐藏在小数点的左边。于是用23位字段可以存储24位有效数。</p>\n<div><pre><code>我们举个例子来看，二进制的“01000001001101100000000000000000”表示的浮点数是啥？\n\n符号位为0，表示正数。\n指数为“10000010”，减去127后为3。\n尾数对应的值为“1.011011”。\n于是最终得到浮点数为“1011.011”，转成十进制为“11.375”。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"_4-源码解读\"> 4.源码解读</h2>\n<h3 id=\"_4-1-属性说明\"> 4.1 属性说明</h3>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Float</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Float</span><span>></span></span> <span>{</span>\n    <span>// System.out.println(Float.POSITIVE_INFINITY == Float.intBitsToFloat(0x7f800000)); // true</span>\n    <span>// System.out.println(Float.POSITIVE_INFINITY);  ==> Infinity</span>\n    <span>//  用来表示正无穷大，按照IEEE 754浮点标准规定，任何有限正数除以0为正无穷大，正无穷的值为0x7f800000。</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>float</span> POSITIVE_INFINITY <span>=</span> <span>1.0f</span> <span>/</span> <span>0.0f</span><span>;</span>\n\n    <span>// System.out.println(Float.NEGATIVE_INFINITY == Float.intBitsToFloat(0xff800000)); // true</span>\n    <span>// System.out.println(Float.NEGATIVE_INFINITY); // -Infinity</span>\n    <span>// 用来表示负无穷大，任何有限负数除以0为负无穷的，负无穷的值为0xff800000。</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>float</span> NEGATIVE_INFINITY <span>=</span> <span>-</span><span>1.0f</span> <span>/</span> <span>0.0f</span><span>;</span>\n\n    <span>// System.out.println(Float.isNaN(Float.intBitsToFloat(0x7fc00000))); // true</span>\n    <span>// System.out.println(Float.intBitsToFloat(0x7fc00000)); // NaN</span>\n    <span>// NaN 用来表示处理计算中出现的错误情况，比如0除以0或负数平方根。对于单精度浮点数，IEEE 标准规定 NaN 的指数域全为 1，且尾数域不等于零的浮点数。它并没有要求具体的尾数域，所以 NaN 实际上不非是一个，而是一族。Java这里定义的值为0x7fc00000。</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>float</span> <span>NaN</span> <span>=</span> <span>0.0f</span> <span>/</span> <span>0.0f</span><span>;</span>\n    \n    <span>// System.out.println(Float.MAX_VALUE == Float.intBitsToFloat(0x7f7fffff)); // true</span>\n    <span>// System.out.println(Float.intBitsToFloat(0x7f7fffff)); // 3.4028235E38</span>\n    <span>// 用来表示最大的浮点数值，它定义为0x1.fffffeP+127f，这里0x表示十六进制，1.fffffe表示十六进制的小数，P表示2，+表示几次方，这里就是2的127次方，最后的f是转成浮点型。所以最后最大值为3.4028235E38。</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>float</span> MAX_VALUE <span>=</span> <span>0x1.fffffeP+127f</span><span>;</span> <span>// 3.4028235e+38f</span>\n    \n    <span>// System.out.println(Float.MIN_NORMAL == Float.intBitsToFloat(0x00800000)); // true</span>\n    <span>// System.out.println(Float.intBitsToFloat(0x00800000)); // 1.17549435E-38</span>\n    <span>// 1.6开始存在</span>\n    <span>// 用来表示最小标准值，它定义为0x1.0p-126f，这里其实就是2的-126次方的了，值为1.17549435E-38f。</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>float</span> MIN_NORMAL <span>=</span> <span>0x1.0p-126f</span><span>;</span> <span>// 1.17549435E-38f</span>\n\n    <span>// System.out.println(Float.MIN_VALUE == Float.intBitsToFloat(0x1)); // true</span>\n    <span>// System.out.println(Float.intBitsToFloat(0x1)); // 1.4E-45</span>\n    <span>// 用来表示浮点数最小值，它定义为0x0.000002P-126f，最后的值为1.4e-45f</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>float</span> MIN_VALUE <span>=</span> <span>0x0.000002P-126f</span><span>;</span> <span>// 1.4e-45f</span>\n    \n    <span>// System.out.println(Math.getExponent(Float.MAX_VALUE) == Float.MAX_EXPONENT); // true</span>\n    <span>// System.out.println(Math.getExponent(Float.MAX_VALUE)); // 127</span>\n    <span>// 1.6开始</span>\n    <span>// 用来表示指数的最大值，这里定为127，这个也是按照IEEE 754浮点标准的规定。</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>int</span> MAX_EXPONENT <span>=</span> <span>127</span><span>;</span>\n    \n    <span>// System.out.println(Math.getExponent(Float.MIN_NORMAL) == Float.MIN_EXPONENT); // true</span>\n    <span>// System.out.println(Float.MIN_EXPONENT); // -126</span>\n    <span>// 1.6开始</span>\n    <span>// 用来表示指数的最小值，按照IEEE 754浮点标准的规定，它为-126。</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>int</span> MIN_EXPONENT <span>=</span> <span>-</span><span>126</span><span>;</span>\n    \n    <span>// 用来表示二进制float值的比特数，值为32，静态变量且不可变。</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>int</span> SIZE <span>=</span> <span>32</span><span>;</span>\n    \n    <span>// 用来表示二进制float值的字节数，值为SIZE除于Byte.SIZE，结果为4字节，表示存储一个Float类型的变量占用4字节。</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>int</span> BYTES <span>=</span> SIZE <span>/</span> <span>Byte</span><span>.</span>SIZE<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h3 id=\"_4-2-方法说明\"> 4.2 方法说明</h3>\n<h3 id=\"float构造方法\"> Float构造方法</h3>\n<p>Float构造方法有3个，第一个是将float但精度浮点数转为Float值，第二个是将double值的双精度浮点数转为单精度浮点数，该转化可能出现精度丢失的情况。\n第三个构造方法是将字符串转为单精度浮点数。</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Float</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Float</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>Float</span><span>(</span><span>float</span> value<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>value <span>=</span> value<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>Float</span><span>(</span><span>double</span> value<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>value <span>=</span> <span>(</span><span>float</span><span>)</span>value<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>Float</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        value <span>=</span> <span>parseFloat</span><span>(</span>s<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id=\"tohexstring方法\"> toHexString方法</h4>\n<ul>\n<li>该方法是将浮点数转为16进制数的字符串</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Floating-point Value</th>\n<th>Hexadecimal String</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.0</td>\n<td>0x1.0p0</td>\n</tr>\n<tr>\n<td>0.25</td>\n<td>0x1.0p-2</td>\n</tr>\n<tr>\n<td>Float.MAX_VALUE</td>\n<td>0x1.fffffep127</td>\n</tr>\n<tr>\n<td>Float.MIN_VALUE</td>\n<td>0x0.000002p-126</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Float</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Float</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>toHexString</span><span>(</span><span>float</span> f<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>Math</span><span>.</span><span>abs</span><span>(</span>f<span>)</span> <span>&lt;</span> <span>FloatConsts</span><span>.</span>MIN_NORMAL\n                <span>&amp;&amp;</span>  f <span>!=</span> <span>0.0f</span> <span>)</span> <span>{</span><span>// float subnormal</span>\n            <span>// Adjust exponent to create subnormal double, then</span>\n            <span>// replace subnormal double exponent with subnormal float</span>\n            <span>// exponent</span>\n            <span>String</span> s <span>=</span> <span>Double</span><span>.</span><span>toHexString</span><span>(</span><span>Math</span><span>.</span><span>scalb</span><span>(</span><span>(</span><span>double</span><span>)</span>f<span>,</span>\n                    <span>/* -1022+126 */</span>\n                    <span>DoubleConsts</span><span>.</span>MIN_EXPONENT<span>-</span>\n                            <span>FloatConsts</span><span>.</span>MIN_EXPONENT<span>)</span><span>)</span><span>;</span>\n            <span>return</span> s<span>.</span><span>replaceFirst</span><span>(</span><span>\"p-1022$\"</span><span>,</span> <span>\"p-126\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>else</span> <span>// double string will be the same as float string</span>\n            <span>return</span> <span>Double</span><span>.</span><span>toHexString</span><span>(</span>f<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>FloatDemoTest</span> <span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testToHexString</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Float</span><span>.</span><span>toHexString</span><span>(</span><span>1.0f</span><span>)</span><span>)</span><span>;</span> <span>//0x1.0p0</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id=\"valueof方法\"> valueOf方法</h4>\n<p>改方法有两个，一个是将字符串转为单精度浮点数，一个是将float值转化为Float对象</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Float</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Float</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>Float</span> <span>valueOf</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>Float</span><span>(</span><span>parseFloat</span><span>(</span>s<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>Float</span> <span>valueOf</span><span>(</span><span>float</span> f<span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>Float</span><span>(</span>f<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>FloatDemoTest</span> <span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testValueOf</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Float</span><span>.</span><span>valueOf</span><span>(</span><span>1.01f</span><span>)</span><span>)</span><span>;</span> <span>// 1.01</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Float</span><span>.</span><span>valueOf</span><span>(</span><span>\"1.01\"</span><span>)</span><span>)</span><span>;</span> <span>// 1.01</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Float</span><span>.</span><span>valueOf</span><span>(</span><span>\"+1.01f\"</span><span>)</span><span>)</span><span>;</span> <span>// 1.01</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Float</span><span>.</span><span>valueOf</span><span>(</span><span>\"-1.01f\"</span><span>)</span><span>)</span><span>;</span> <span>// -1.01</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Float</span><span>.</span><span>valueOf</span><span>(</span><span>\"1.01F\"</span><span>)</span><span>)</span><span>;</span> <span>// 1.01</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Float</span><span>.</span><span>valueOf</span><span>(</span><span>\"1.01d\"</span><span>)</span><span>)</span><span>;</span> <span>// 1.01</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Float</span><span>.</span><span>valueOf</span><span>(</span><span>\"1.01I\"</span><span>)</span><span>)</span><span>;</span> <span>// java.lang.NumberFormatException: For input string: \"1.01I\"</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h4 id=\"parsefloat方法\"> parseFloat方法</h4>\n<p>该是Java中的内置方法，该方法返回一个新的float，该新float初始化为指定的String表示的值，这由Float类的valueOf方法完成。</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Float</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Float</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>float</span> <span>parseFloat</span><span>(</span><span>String</span> s<span>)</span> <span>throws</span> <span>NumberFormatException</span> <span>{</span>\n        <span>return</span> <span>FloatingDecimal</span><span>.</span><span>parseFloat</span><span>(</span>s<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"isnan方法\"> isNaN方法</h4>\n<ul>\n<li>该方法是判断是否是非数字的值(NAN)， NaN是Not a Number的缩写。</li>\n</ul>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Float</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Float</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>boolean</span> <span>isNaN</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>isNaN</span><span>(</span>value<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>boolean</span> <span>isNaN</span><span>(</span><span>float</span> v<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>v <span>!=</span> v<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id=\"isinfinite与isinfinite方法\"> isInfinite与isInfinite方法</h4>\n<ul>\n<li>\n<p>isInfinite()方法用于检查此Float对象的无穷大(即正无穷大或负无穷大)</p>\n</li>\n<li>\n<p>isFinite() 方法如果传递的参数是有限浮点数，则返回 true，否则返回 false(在 NaN 和无穷大参数的情况下)。</p>\n</li>\n</ul>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Float</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Float</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>boolean</span> <span>isInfinite</span><span>(</span><span>float</span> v<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>v <span>==</span> POSITIVE_INFINITY<span>)</span> <span>||</span> <span>(</span>v <span>==</span> NEGATIVE_INFINITY<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>boolean</span> <span>isFinite</span><span>(</span><span>float</span> f<span>)</span> <span>{</span>\n        <span>return</span> <span>Math</span><span>.</span><span>abs</span><span>(</span>f<span>)</span> <span>&lt;=</span> <span>FloatConsts</span><span>.</span>MAX_VALUE<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>FloatDemoTest</span> <span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testInfiniteAndFinite</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Float</span><span>.</span><span>isInfinite</span><span>(</span><span>Float</span><span>.</span>POSITIVE_INFINITY<span>)</span><span>)</span><span>;</span> <span>// true</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Float</span><span>.</span><span>isInfinite</span><span>(</span><span>0.05f</span><span>)</span><span>)</span><span>;</span>                <span>// false</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Float</span><span>.</span><span>isFinite</span><span>(</span><span>0.05f</span><span>)</span><span>)</span><span>;</span>                  <span>// true</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Float</span><span>.</span><span>isFinite</span><span>(</span><span>Float</span><span>.</span>POSITIVE_INFINITY<span>)</span><span>)</span><span>;</span>   <span>// false</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id=\"floattointbits方法\"> floatToIntBits方法</h4>\n<p>Float类中的floatToIntBits()方法是Java中的内置函数，它根据IEEE 754浮点“single format”位布局返回指定浮点值的表示形式。</p>\n<p>返回值：该函数返回表示浮点数的整数位。以下是特殊情况：</p>\n<ul>\n<li>如果参数为正无穷大，则结果为0x7f800000。</li>\n<li>如果参数为负无穷大，则结果为0xff800000。</li>\n<li>如果参数为NaN，则结果为0x7fc00000。</li>\n</ul>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Float</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Float</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>floatToIntBits</span><span>(</span><span>float</span> value<span>)</span> <span>{</span>\n        <span>int</span> result <span>=</span> <span>floatToRawIntBits</span><span>(</span>value<span>)</span><span>;</span>\n        <span>// Check for NaN based on values of bit fields, maximum</span>\n        <span>// exponent and nonzero significand.</span>\n        <span>if</span> <span>(</span> <span>(</span><span>(</span>result <span>&amp;</span> <span>FloatConsts</span><span>.</span>EXP_BIT_MASK<span>)</span> <span>==</span>\n                <span>FloatConsts</span><span>.</span>EXP_BIT_MASK<span>)</span> <span>&amp;&amp;</span>\n                <span>(</span>result <span>&amp;</span> <span>FloatConsts</span><span>.</span>SIGNIF_BIT_MASK<span>)</span> <span>!=</span> <span>0</span><span>)</span>\n            result <span>=</span> <span>0x7fc00000</span><span>;</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h4 id=\"sum-max-min方法\"> sum/max/min方法</h4>\n<ul>\n<li>sum方法是用来计算两个float值之和。</li>\n<li>max方法是用来查找两个float值的最大值。</li>\n<li>min方法是用来查找两个float值的最小值。</li>\n</ul>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Float</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Float</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>float</span> <span>sum</span><span>(</span><span>float</span> a<span>,</span> <span>float</span> b<span>)</span> <span>{</span>\n        <span>return</span> a <span>+</span> b<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>float</span> <span>max</span><span>(</span><span>float</span> a<span>,</span> <span>float</span> b<span>)</span> <span>{</span>\n        <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>float</span> <span>min</span><span>(</span><span>float</span> a<span>,</span> <span>float</span> b<span>)</span> <span>{</span>\n        <span>return</span> <span>Math</span><span>.</span><span>min</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id=\"floattorawintbits-intbitstofloat-native方法\"> floatToRawIntBits/intBitsToFloat native方法()</h4>\n<ul>\n<li>Float类中的floatToRawIntBits()方法是Java中的内置函数，该函数根据IEEE 754浮点“single format”位布局返回指定浮点值的表示形式，并保留Not-a-Number(NaN)值。</li>\n</ul>\n<p>返回值：该函数返回代表浮点数的位。但是，有3种特殊情况：</p>\n<div><pre><code>* 如果参数为正无穷大，则结果为0x7f800000。\n* 如果参数为负无穷大，则结果为0xff800000。\n* 如果参数为NaN，则结果为0x7fc00000。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>\n<li>Java Float 类的 intBitsToFloat() 方法返回与给定位表示相关的浮点值。根据 IEEE 754 浮点 'single format' 位布局，传递的参数被视为浮点值的表示。</li>\n</ul>\n<p>此方法返回具有相同位模式的浮点值。</p>\n<div><pre><code>* 如果传递的参数为 0X7f800000，则返回的结果为正无穷大。\n* 如果传递的参数为 0Xff800000，则返回的结果为负无穷大。\n* 如果传递的参数在 0x7f800001 到 0x7fffffff 之间的范围内或在 0xff800001 到 0xffffffff 之间的范围内，则返回的结果为 Nan。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Float</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Float</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>native</span> <span>int</span> <span>floatToRawIntBits</span><span>(</span><span>float</span> value<span>)</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>native</span> <span>float</span> <span>intBitsToFloat</span><span>(</span><span>int</span> bits<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"_5-说明\"> 5.说明</h2>\n<ul>\n<li>需要精确计算时不要使用float和double，如果需要精度计算，请使用BigDecimal</li>\n<li>不能用浮点数作为循环变量,浮点数不能为循环因子，精度问题会导致 (float)2000000000 == 2000000050为true</li>\n<li>浮点型数据判断相等不能直接使用,应采用如下方式</li>\n</ul>\n<div><pre><code><span>float</span> a <span>=</span><span>.</span><span>.</span><span>.</span><span>;</span>\n<span>float</span> b <span>=</span><span>.</span><span>.</span><span>.</span><span>;</span>\n<span>if</span> <span>(</span><span>Math</span><span>.</span><span>abs</span><span>(</span>a<span>-</span>b<span>)</span> <span>&lt;</span> <span>1E-6f</span><span>)</span> <span>{</span>\n      <span>.</span><span>.</span><span>.</span>\n<span>}</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Float.png",
      "date_published": "2022-11-10T15:19:47.000Z",
      "date_modified": "2022-11-14T04:24:03.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM源码解读-Integer类",
      "url": "https://www.moremind.cn/md/java/basic/Integer/",
      "id": "https://www.moremind.cn/md/java/basic/Integer/",
      "content_html": "<h2 id=\"_1-类图\"> 1. 类图</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Integer.png\" alt=\"Integer-Class\" /></p>\n<h2 id=\"_2-存储位置\"> 2. 存储位置</h2>\n<ul>\n<li><code>-128-127</code>的值存储在<code>JVM方法区的静态区</code>,是因为Integer内部有一个静态内部类IntegerCache</li>\n<li>其余的存储在<code>JVM堆区</code>，都是通过<code>new Integer(x)</code>创建出来</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> <span>IntegerDemoTest</span> <span>{</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>newIntegerTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>Integer</span> a <span>=</span> <span>3</span><span>;</span>\n        <span>Integer</span> b <span>=</span> <span>3</span><span>;</span>\n        <span>Integer</span> a <span>=</span> <span>3</span><span>;</span> <span>&lt;=</span><span>=</span><span>></span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        <span>// a == b 为true，是因为对应同一个IntegerCache游标的地址</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> b<span>)</span><span>;</span>\n\n        <span>Integer</span> c <span>=</span> <span>129</span><span>;</span>\n        <span>Integer</span> d <span>=</span> <span>129</span><span>;</span>\n\n        <span>// c == d 为false,是因为本身就是两个不同的地址</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c <span>==</span> d<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"_3-源码解读\"> 3. 源码解读</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Integer-2.png\" alt=\"\" /></p>\n<h3 id=\"_3-1-主要属性\"> 3.1 主要属性</h3>\n<h4 id=\"_3-1-1-第一部分-常量参数\"> 3.1.1 第一部分-常量参数</h4>\n<div><pre><code><span>/**\n * A constant holding the minimum value an {@code int} can\n * have, -2^31.\n */</span>\n<span>@Native</span> <span>public</span> <span>static</span> <span>final</span> <span>int</span>   MIN_VALUE <span>=</span> <span>0x80000000</span><span>;</span>\n\n<span>/**\n * A constant holding the maximum value an {@code int} can\n * have, 2^31-1.\n */</span>\n<span>@Native</span> <span>public</span> <span>static</span> <span>final</span> <span>int</span>   MAX_VALUE <span>=</span> <span>0x7fffffff</span><span>;</span>\n\n<span>/**\n * The {@code Class} instance representing the primitive type\n * {@code int}.\n *\n * @since   JDK1.1\n */</span>\n<span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n<span>public</span> <span>static</span> <span>final</span> <span>Class</span><span><span>&lt;</span><span>Integer</span><span>></span></span>  TYPE <span>=</span> <span>(</span><span>Class</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>)</span> <span>Class</span><span>.</span><span>getPrimitiveClass</span><span>(</span><span>\"int\"</span><span>)</span><span>;</span>\n\n<span>/**\n * The number of bits used to represent an {@code int} value in two's\n * complement binary form.\n *\n * @since 1.5\n */</span>\n<span>@Native</span> <span>public</span> <span>static</span> <span>final</span> <span>int</span> SIZE <span>=</span> <span>32</span><span>;</span>\n\n<span>/**\n * The number of bytes used to represent a {@code int} value in two's\n * complement binary form.\n *\n * @since 1.8\n */</span>\n<span>public</span> <span>static</span> <span>final</span> <span>int</span> BYTES <span>=</span> SIZE <span>/</span> <span>Byte</span><span>.</span>SIZE<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><ul>\n<li>MIN_VALUE为Integer可定义的最小值，为-2^31 = -2147483648。</li>\n<li>MIN_VALUE为Integer可定义的最大值，为2^31-1 = 2147483647。</li>\n<li>SIZE用来表示二进制补码形式的int值的比特数，值为32，静态变量且不可变。</li>\n<li>BYTES用来表示二进制补码形式的int值的字节数，值为SIZE除于Byte.SIZE，不同机器的值可能不一样，在16位机中为2字节，在32位机和64位机中为4字节。</li>\n<li>TYPE表示执行toString后的类型为<code>int</code>,Class的getPrimitiveClass是一个native方法，在Class.c中有个Java_java_lang_Class_getPrimitiveClass方法与之对应，所以JVM层面会通过JVM_FindPrimitiveClass函数根据”int”字符串获得jclass，最终到Java层则为Class<Integer>。</li>\n</ul>\n<h4 id=\"_3-1-2-第二部分-数组\"> 3.1.2 第二部分-数组</h4>\n<div><pre><code><span>final</span> <span>static</span> <span>char</span> <span>[</span><span>]</span> <span>DigitTens</span> <span>=</span> <span>{</span>\n        <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span> <span>'0'</span><span>,</span>\n        <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span> <span>'1'</span><span>,</span>\n        <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span> <span>'2'</span><span>,</span>\n        <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span> <span>'3'</span><span>,</span>\n        <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span> <span>'4'</span><span>,</span>\n        <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span> <span>'5'</span><span>,</span>\n        <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span> <span>'6'</span><span>,</span>\n        <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span> <span>'7'</span><span>,</span>\n        <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span> <span>'8'</span><span>,</span>\n        <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>}</span> <span>;</span>\n\n<span>final</span> <span>static</span> <span>char</span> <span>[</span><span>]</span> <span>DigitOnes</span> <span>=</span> <span>{</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>'0'</span><span>,</span> <span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>,</span>\n        <span>}</span> <span>;</span>\n\n<span>final</span> <span>static</span> <span>char</span><span>[</span><span>]</span> digits <span>=</span> <span>{</span>\n        <span>'0'</span> <span>,</span> <span>'1'</span> <span>,</span> <span>'2'</span> <span>,</span> <span>'3'</span> <span>,</span> <span>'4'</span> <span>,</span> <span>'5'</span> <span>,</span>\n        <span>'6'</span> <span>,</span> <span>'7'</span> <span>,</span> <span>'8'</span> <span>,</span> <span>'9'</span> <span>,</span> <span>'a'</span> <span>,</span> <span>'b'</span> <span>,</span>\n        <span>'c'</span> <span>,</span> <span>'d'</span> <span>,</span> <span>'e'</span> <span>,</span> <span>'f'</span> <span>,</span> <span>'g'</span> <span>,</span> <span>'h'</span> <span>,</span>\n        <span>'i'</span> <span>,</span> <span>'j'</span> <span>,</span> <span>'k'</span> <span>,</span> <span>'l'</span> <span>,</span> <span>'m'</span> <span>,</span> <span>'n'</span> <span>,</span>\n        <span>'o'</span> <span>,</span> <span>'p'</span> <span>,</span> <span>'q'</span> <span>,</span> <span>'r'</span> <span>,</span> <span>'s'</span> <span>,</span> <span>'t'</span> <span>,</span>\n        <span>'u'</span> <span>,</span> <span>'v'</span> <span>,</span> <span>'w'</span> <span>,</span> <span>'x'</span> <span>,</span> <span>'y'</span> <span>,</span> <span>'z'</span>\n        <span>}</span><span>;</span>\n\n<span>final</span> <span>static</span> <span>int</span> <span>[</span><span>]</span> sizeTable <span>=</span> <span>{</span> <span>9</span><span>,</span> <span>99</span><span>,</span> <span>999</span><span>,</span> <span>9999</span><span>,</span> <span>99999</span><span>,</span> <span>999999</span><span>,</span> <span>9999999</span><span>,</span>\n        <span>99999999</span><span>,</span> <span>999999999</span><span>,</span> <span>Integer</span><span>.</span>MAX_VALUE <span>}</span><span>;</span>\n\n<span>// Requires positive x</span>\n<span>static</span> <span>int</span> <span>stringSize</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> <span>;</span> i<span>++</span><span>)</span>\n        <span>if</span> <span>(</span>x <span>&lt;=</span> sizeTable<span>[</span>i<span>]</span><span>)</span>\n        <span>return</span> i<span>+</span><span>1</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><ul>\n<li>DigitTens和DigitOnes两个数组放到一起讲更好理解，它们主要用于获取0到99之间某个数的十位和个位，比如48，通过DigitTens数组直接取出来十位为4，而通过DigitOnes数组取出来个位为8。</li>\n<li>digits数组用于表示数字的所有可能的字符，因为int支持从2进制到36进制，所以这里需要有36个字符才能表示所有不同进制的数字。</li>\n<li>sizeTable数组主要用在判断一个int型数字对应字符串的长度。比如相关的方法如下，这种方法可以高效得到对应字符串长度，避免了使用除法或求余等操作。</li>\n</ul>\n<h4 id=\"_3-1-3-integercache静态内部类\"> 3.1.3 IntegerCache静态内部类</h4>\n<div><pre><code><span>private</span> <span>static</span> <span>class</span> <span>IntegerCache</span> <span>{</span>\n    <span>static</span> <span>final</span> <span>int</span> low <span>=</span> <span>-</span><span>128</span><span>;</span>\n    <span>static</span> <span>final</span> <span>int</span> high<span>;</span>\n    <span>static</span> <span>final</span> <span>Integer</span> cache<span>[</span><span>]</span><span>;</span>\n\n    <span>static</span> <span>{</span>\n        <span>// high value may be configured by property</span>\n        <span>int</span> h <span>=</span> <span>127</span><span>;</span>\n        <span>String</span> integerCacheHighPropValue <span>=</span>\n                sun<span>.</span>misc<span>.</span>VM<span>.</span><span>getSavedProperty</span><span>(</span><span>\"java.lang.Integer.IntegerCache.high\"</span><span>)</span><span>;</span>\n        <span>// 如果设置了cache的高位，缓存就设置为[-128, high]</span>\n        <span>if</span> <span>(</span>integerCacheHighPropValue <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>// 解析为int的静态值</span>\n                <span>int</span> i <span>=</span> <span>parseInt</span><span>(</span>integerCacheHighPropValue<span>)</span><span>;</span>\n                <span>// 取最大值</span>\n                i <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>i<span>,</span> <span>127</span><span>)</span><span>;</span>\n                <span>// 最大值是Integer.MAX_VALUE</span>\n                h <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>i<span>,</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>(</span><span>-</span>low<span>)</span> <span>-</span><span>1</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span><span>(</span> <span>NumberFormatException</span> nfe<span>)</span> <span>{</span>\n                <span>// If the property cannot be parsed into an int, ignore it.</span>\n            <span>}</span>\n        <span>}</span>\n        high <span>=</span> h<span>;</span>\n\n        <span>// cache空间为256</span>\n        cache <span>=</span> <span>new</span> <span>Integer</span><span>[</span><span>(</span>high <span>-</span> low<span>)</span> <span>+</span> <span>1</span><span>]</span><span>;</span>\n        <span>int</span> j <span>=</span> low<span>;</span>\n        <span>for</span><span>(</span><span>int</span> k <span>=</span> <span>0</span><span>;</span> k <span>&lt;</span> cache<span>.</span>length<span>;</span> k<span>++</span><span>)</span>\n            <span>// 生成cache值的缓存空间</span>\n            cache<span>[</span>k<span>]</span> <span>=</span> <span>new</span> <span>Integer</span><span>(</span>j<span>++</span><span>)</span><span>;</span>\n\n        <span>// range [-128, 127] must be interned (JLS7 5.1.7)</span>\n        <span>assert</span> <span>IntegerCache</span><span>.</span>high <span>>=</span> <span>127</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>IntegerCache</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>IntegerCache为静态内部类，存储在方法区中的静态区，IntegerCache中的cache参数存储在静态区，包含了int可能值的Integer数组，默认范围是[-128,127],最大值可通过指定方式进行调整，在启动时\n通过JVM参数<code>Djava.lang.Integer.IntegerCache.high=xxx</code>进行调整。当Integer的值范围在[-128,127]时则直接从缓存中获取对应的Integer对象，\n不必重新实例化。这些缓存值都是静态且final的，避免重复的实例化和回收。</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>Integer</span> <span>valueOf</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>i <span>>=</span> <span>IntegerCache</span><span>.</span>low <span>&amp;&amp;</span> i <span>&lt;=</span> <span>IntegerCache</span><span>.</span>high<span>)</span>\n            <span>// IntegerCache.cache空间如下:</span>\n            <span>[</span><span>0</span><span>]</span> <span>=</span> <span>-</span><span>128</span>\n            <span>[</span><span>1</span><span>]</span> <span>=</span> <span>-</span><span>127</span>\n            <span>.</span><span>.</span><span>.</span>\n            <span>[</span><span>129</span><span>]</span> <span>=</span> <span>1</span>\n            <span>[</span><span>130</span><span>]</span> <span>=</span> <span>2</span>\n            <span>[</span><span>256</span><span>]</span> <span>=</span> <span>127</span>\n            <span>// e.g. i = 1, 那就从IntegerCache.cache[1+128] => Integer.cache[129] = 1</span>\n            <span>return</span> <span>IntegerCache</span><span>.</span>cache<span>[</span>i <span>+</span> <span>(</span><span>-</span><span>IntegerCache</span><span>.</span>low<span>)</span><span>]</span><span>;</span>\n        <span>return</span> <span>new</span> <span>Integer</span><span>(</span>i<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>由上述代码可知，当值在[-128,127]之间时，取值是直接从IntegerCache的cache中取值。</p>\n<h3 id=\"_3-2-核心方法\"> 3.2 核心方法</h3>\n<h4 id=\"max-min-sum方法\"> max/min/sum方法</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Integer</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n    <span>// 取两者之间的最大值</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>max</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n        <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n    <span>}</span>\n    <span>// 取两者之间的最小值</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>min</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n        <span>return</span> <span>Math</span><span>.</span><span>min</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>\n    <span>}</span>\n    <span>// 取两者之间的和</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>sum</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n        <span>return</span> a <span>+</span> b<span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>public</span> <span>class</span> <span>IntegerDemoTest</span> <span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>maxTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>// a => 97, b => 98 => max => 98</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Integer</span><span>.</span><span>max</span><span>(</span><span>'a'</span><span>,</span> <span>'b'</span><span>)</span><span>)</span><span>;</span>\n        <span>// a => 97, b => 98 => min => 97</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Integer</span><span>.</span><span>min</span><span>(</span><span>'a'</span><span>,</span> <span>'b'</span><span>)</span><span>)</span><span>;</span>\n        <span>// a => 97, b => 98 => sum => 195</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Integer</span><span>.</span><span>sum</span><span>(</span><span>'a'</span><span>,</span> <span>'b'</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h4 id=\"getinteger方法\"> getInteger方法</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Integer</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>Integer</span> <span>getInteger</span><span>(</span><span>String</span> nm<span>)</span> <span>{</span>\n        <span>return</span> <span>getInteger</span><span>(</span>nm<span>,</span> <span>null</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>Integer</span> <span>getInteger</span><span>(</span><span>String</span> nm<span>,</span> <span>int</span> val<span>)</span> <span>{</span>\n        <span>Integer</span> result <span>=</span> <span>getInteger</span><span>(</span>nm<span>,</span> <span>null</span><span>)</span><span>;</span>\n        <span>return</span> <span>(</span>result <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span>val<span>)</span> <span>:</span> result<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>Integer</span> <span>getInteger</span><span>(</span><span>String</span> nm<span>,</span> <span>Integer</span> val<span>)</span> <span>{</span>\n        <span>String</span> v <span>=</span> <span>null</span><span>;</span>\n        <span>try</span> <span>{</span>\n            v <span>=</span> <span>System</span><span>.</span><span>getProperty</span><span>(</span>nm<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>IllegalArgumentException</span> <span>|</span> <span>NullPointerException</span> e<span>)</span> <span>{</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>v <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>return</span> <span>Integer</span><span>.</span><span>decode</span><span>(</span>v<span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>NumberFormatException</span> e<span>)</span> <span>{</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> val<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>Integer.getInteger(String)的功能是根据指定的名称得到系统属性的整数值。第一个参数将被认为是系统属性的名称。系统属性可以通过  System.getProperty(java.lang.String)方法访问得到。属性值字符串将被解释成一个整数，并且以表示这个值的Integer对象形式返回。可能出现的数字格式的详细说明可以在 getProperty 的定义说明里找到。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testGetInteger</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span><span>setProperty</span><span>(</span><span>\"test-integer\"</span><span>,</span> <span>\"55\"</span><span>)</span><span>;</span>\n        <span>Integer</span> testNumber <span>=</span> <span>Integer</span><span>.</span><span>getInteger</span><span>(</span><span>\"test-integer\"</span><span>)</span><span>;</span>\n        <span>Assertions</span><span>.</span><span>assertEquals</span><span>(</span><span>55</span><span>,</span> testNumber<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id=\"tostring方法\"> toString方法</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Integer</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>String</span> <span>toString</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>i <span>==</span> <span>Integer</span><span>.</span>MIN_VALUE<span>)</span>\n            <span>return</span> <span>\"-2147483648\"</span><span>;</span>\n        <span>int</span> size <span>=</span> <span>(</span>i <span>&lt;</span> <span>0</span><span>)</span> <span>?</span> <span>stringSize</span><span>(</span><span>-</span>i<span>)</span> <span>+</span> <span>1</span> <span>:</span> <span>stringSize</span><span>(</span>i<span>)</span><span>;</span>\n        <span>char</span><span>[</span><span>]</span> buf <span>=</span> <span>new</span> <span>char</span><span>[</span>size<span>]</span><span>;</span>\n        <span>getChars</span><span>(</span>i<span>,</span> size<span>,</span> buf<span>)</span><span>;</span>\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>buf<span>,</span> <span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>toString</span><span>(</span>value<span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>static</span> <span>String</span> <span>toString</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> radix<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>radix <span>&lt;</span> <span>Character</span><span>.</span>MIN_RADIX <span>||</span> radix <span>></span> <span>Character</span><span>.</span>MAX_RADIX<span>)</span>\n            radix <span>=</span> <span>10</span><span>;</span>\n\n        <span>/* Use the faster version */</span>\n        <span>if</span> <span>(</span>radix <span>==</span> <span>10</span><span>)</span> <span>{</span>\n            <span>return</span> <span>toString</span><span>(</span>i<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>char</span> buf<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>char</span><span>[</span><span>33</span><span>]</span><span>;</span>\n        <span>boolean</span> negative <span>=</span> <span>(</span>i <span>&lt;</span> <span>0</span><span>)</span><span>;</span>\n        <span>int</span> charPos <span>=</span> <span>32</span><span>;</span>\n\n        <span>if</span> <span>(</span><span>!</span>negative<span>)</span> <span>{</span>\n            i <span>=</span> <span>-</span>i<span>;</span>\n        <span>}</span>\n\n        <span>while</span> <span>(</span>i <span>&lt;=</span> <span>-</span>radix<span>)</span> <span>{</span>\n            buf<span>[</span>charPos<span>--</span><span>]</span> <span>=</span> digits<span>[</span><span>-</span><span>(</span>i <span>%</span> radix<span>)</span><span>]</span><span>;</span>\n            i <span>=</span> i <span>/</span> radix<span>;</span>\n        <span>}</span>\n        buf<span>[</span>charPos<span>]</span> <span>=</span> digits<span>[</span><span>-</span>i<span>]</span><span>;</span>\n\n        <span>if</span> <span>(</span>negative<span>)</span> <span>{</span>\n            buf<span>[</span><span>--</span>charPos<span>]</span> <span>=</span> <span>'-'</span><span>;</span>\n        <span>}</span>\n\n        <span>return</span> <span>new</span> <span>String</span><span>(</span>buf<span>,</span> charPos<span>,</span> <span>(</span><span>33</span> <span>-</span> charPos<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>一共有3个toString方法，两个静态方法一个是非静态方法，第一个toString方法很简单，就是先用stringSize得到数字是多少位，再用getChars获取数字对应的char数组，最后返回一个String类型。第二个toString调用第一个toString。第三个toString方法是带了进制信息的，它会转换成对应进制的字符串。凡是不在2到36进制范围之间的都会被处理成10进制，我们都知道从十进制转成其他进制时就是不断地除于进制数得到余数，然后把余数反过来串起来就是最后结果，所以这里其实也是这样子做的，得到余数后通过digits数组获取到对应的字符，而且这里是用负数的形式来运算的。</p>\n<h4 id=\"reversebytes方法\"> reverseBytes方法</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Integer</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>reverseBytes</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span>i <span>>>></span> <span>24</span><span>)</span>           <span>)</span> <span>|</span>\n                <span>(</span><span>(</span>i <span>>></span>   <span>8</span><span>)</span> <span>&amp;</span>   <span>0xFF00</span><span>)</span> <span>|</span>\n                <span>(</span><span>(</span>i <span>&lt;&lt;</span>   <span>8</span><span>)</span> <span>&amp;</span> <span>0xFF0000</span><span>)</span> <span>|</span>\n                <span>(</span><span>(</span>i <span>&lt;&lt;</span> <span>24</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>该方法返回通过反转指定int值的二进制补码表示形式的字节顺序而获得的值。</p>\n<h4 id=\"signum方法\"> signum方法</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Integer</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>signum</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>// HD, Section 2-7</span>\n        <span>return</span> <span>(</span>i <span>>></span> <span>31</span><span>)</span> <span>|</span> <span>(</span><span>-</span>i <span>>>></span> <span>31</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>改方法确定输入的数的符号，如果输入的是正数则返回1，如果输入的是零则返回0，如果输入的是负数则返回-1。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testSignum</span><span>(</span><span>)</span> <span>{</span>\n        <span>// the result is -1</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Integer</span><span>.</span><span>signum</span><span>(</span><span>-</span><span>99</span><span>)</span><span>)</span><span>;</span>\n        <span>// the result is 1</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Integer</span><span>.</span><span>signum</span><span>(</span><span>99</span><span>)</span><span>)</span><span>;</span>\n        <span>// the result is 0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Integer</span><span>.</span><span>signum</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id=\"reverse方法\"> reverse方法</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Integer</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>reverse</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>// HD, Figure 7-1</span>\n        i <span>=</span> <span>(</span>i <span>&amp;</span> <span>0x55555555</span><span>)</span> <span>&lt;&lt;</span> <span>1</span> <span>|</span> <span>(</span>i <span>>>></span> <span>1</span><span>)</span> <span>&amp;</span> <span>0x55555555</span><span>;</span>\n        i <span>=</span> <span>(</span>i <span>&amp;</span> <span>0x33333333</span><span>)</span> <span>&lt;&lt;</span> <span>2</span> <span>|</span> <span>(</span>i <span>>>></span> <span>2</span><span>)</span> <span>&amp;</span> <span>0x33333333</span><span>;</span>\n        i <span>=</span> <span>(</span>i <span>&amp;</span> <span>0x0f0f0f0f</span><span>)</span> <span>&lt;&lt;</span> <span>4</span> <span>|</span> <span>(</span>i <span>>>></span> <span>4</span><span>)</span> <span>&amp;</span> <span>0x0f0f0f0f</span><span>;</span>\n        i <span>=</span> <span>(</span>i <span>&lt;&lt;</span> <span>24</span><span>)</span> <span>|</span> <span>(</span><span>(</span>i <span>&amp;</span> <span>0xff00</span><span>)</span> <span>&lt;&lt;</span> <span>8</span><span>)</span> <span>|</span>\n                <span>(</span><span>(</span>i <span>>>></span> <span>8</span><span>)</span> <span>&amp;</span> <span>0xff00</span><span>)</span> <span>|</span> <span>(</span>i <span>>>></span> <span>24</span><span>)</span><span>;</span>\n        <span>return</span> i<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>用于返回指定int值的二进制补码二进制表示形式的位的相反顺序。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testReverse</span><span>(</span><span>)</span> <span>{</span>\n        <span>// the result is 100663296</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Integer</span><span>.</span><span>reverse</span><span>(</span><span>96</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id=\"rotateleft-rotateright方法\"> rotateLeft/rotateRight方法</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Integer</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>rotateRight</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> distance<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>i <span>>>></span> distance<span>)</span> <span>|</span> <span>(</span>i <span>&lt;&lt;</span> <span>-</span>distance<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>rotateLeft</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> distance<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span>i <span>&lt;&lt;</span> distance<span>)</span> <span>|</span> <span>(</span>i <span>>>></span> <span>-</span>distance<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>rotateRight该方法通过将指定int值a的二进制补码二进制表示形式向右旋转指定位数来返回获得的值。位向右移，即低位。</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span> \n        <span>int</span> a <span>=</span> <span>64</span><span>;</span> \n        <span>int</span> shifts <span>=</span> <span>0</span><span>;</span> \n        <span>while</span> <span>(</span>shifts <span>&lt;</span> <span>3</span><span>)</span> <span>{</span>\n        <span>// It will return the value obtained by rotating left</span>\n            a <span>=</span> <span>Integer</span><span>.</span><span>rotateRight</span><span>(</span>a<span>,</span> <span>2</span><span>)</span><span>;</span> \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>)</span><span>;</span> \n            shifts<span>++</span><span>;</span> \n        <span>}</span> \n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>16</span>\n<span>4</span>\n<span>1</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>rotateLeft该方法返回通过将指定int值的二进制补码二进制表示形式向左旋转指定数量的移位位数而获得的值。</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>\n        <span>int</span> a <span>=</span> <span>2</span><span>;</span> \n        <span>int</span> shifts <span>=</span> <span>0</span><span>;</span> \n        <span>while</span> <span>(</span>shifts <span>&lt;</span> <span>6</span><span>)</span> <span>{</span>\n        <span>// It will return the value obtained by rotating left</span>\n            a <span>=</span> <span>Integer</span><span>.</span><span>rotateLeft</span><span>(</span>a<span>,</span> <span>2</span><span>)</span><span>;</span> \n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>)</span><span>;</span> \n            shifts<span>++</span><span>;</span> \n        <span>}</span> \n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>8</span>\n<span>32</span>\n<span>128</span>\n<span>512</span>\n<span>2048</span>\n<span>8192</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id=\"numberofleadingzeros-numberoftrailingzeros方法\"> numberOfLeadingZeros/numberOfTrailingZeros方法</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Integer</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>numberOfLeadingZeros</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>// HD, Figure 5-6</span>\n        <span>if</span> <span>(</span>i <span>==</span> <span>0</span><span>)</span>\n            <span>return</span> <span>32</span><span>;</span>\n        <span>int</span> n <span>=</span> <span>1</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>>>></span> <span>16</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> n <span>+=</span> <span>16</span><span>;</span> i <span>&lt;&lt;=</span> <span>16</span><span>;</span> <span>}</span>\n        <span>if</span> <span>(</span>i <span>>>></span> <span>24</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> n <span>+=</span>  <span>8</span><span>;</span> i <span>&lt;&lt;=</span>  <span>8</span><span>;</span> <span>}</span>\n        <span>if</span> <span>(</span>i <span>>>></span> <span>28</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> n <span>+=</span>  <span>4</span><span>;</span> i <span>&lt;&lt;=</span>  <span>4</span><span>;</span> <span>}</span>\n        <span>if</span> <span>(</span>i <span>>>></span> <span>30</span> <span>==</span> <span>0</span><span>)</span> <span>{</span> n <span>+=</span>  <span>2</span><span>;</span> i <span>&lt;&lt;=</span>  <span>2</span><span>;</span> <span>}</span>\n        n <span>-=</span> i <span>>>></span> <span>31</span><span>;</span>\n        <span>return</span> n<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>numberOfTrailingZeros</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>// HD, Figure 5-14</span>\n        <span>int</span> y<span>;</span>\n        <span>if</span> <span>(</span>i <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>32</span><span>;</span>\n        <span>int</span> n <span>=</span> <span>31</span><span>;</span>\n        y <span>=</span> i <span>&lt;&lt;</span><span>16</span><span>;</span> <span>if</span> <span>(</span>y <span>!=</span> <span>0</span><span>)</span> <span>{</span> n <span>=</span> n <span>-</span><span>16</span><span>;</span> i <span>=</span> y<span>;</span> <span>}</span>\n        y <span>=</span> i <span>&lt;&lt;</span> <span>8</span><span>;</span> <span>if</span> <span>(</span>y <span>!=</span> <span>0</span><span>)</span> <span>{</span> n <span>=</span> n <span>-</span> <span>8</span><span>;</span> i <span>=</span> y<span>;</span> <span>}</span>\n        y <span>=</span> i <span>&lt;&lt;</span> <span>4</span><span>;</span> <span>if</span> <span>(</span>y <span>!=</span> <span>0</span><span>)</span> <span>{</span> n <span>=</span> n <span>-</span> <span>4</span><span>;</span> i <span>=</span> y<span>;</span> <span>}</span>\n        y <span>=</span> i <span>&lt;&lt;</span> <span>2</span><span>;</span> <span>if</span> <span>(</span>y <span>!=</span> <span>0</span><span>)</span> <span>{</span> n <span>=</span> n <span>-</span> <span>2</span><span>;</span> i <span>=</span> y<span>;</span> <span>}</span>\n        <span>return</span> n <span>-</span> <span>(</span><span>(</span>i <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>>>></span> <span>31</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h4 id=\"highestonebit-lowestonebit方法\"> highestOneBit/lowestOneBit方法</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Integer</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n    <span>// 返回一个 int 值，最多有一个单个位，位于指定 int 值中最高（“最左边”）一位的位置。 如果指定的值在其二进制补码表示中没有一位，即等于零，则返回零。</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>highestOneBit</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>// HD, Figure 3-1</span>\n        i <span>|=</span> <span>(</span>i <span>>></span>  <span>1</span><span>)</span><span>;</span>\n        i <span>|=</span> <span>(</span>i <span>>></span>  <span>2</span><span>)</span><span>;</span>\n        i <span>|=</span> <span>(</span>i <span>>></span>  <span>4</span><span>)</span><span>;</span>\n        i <span>|=</span> <span>(</span>i <span>>></span>  <span>8</span><span>)</span><span>;</span>\n        i <span>|=</span> <span>(</span>i <span>>></span> <span>16</span><span>)</span><span>;</span>\n        <span>return</span> i <span>-</span> <span>(</span>i <span>>>></span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>lowestOneBit</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>\n        <span>// 返回一个 int 值，最多只有一个一位，位于指定 int 值中最低位（“最右边”）一位的位置。 如果指定的值在其二进制补码表示中没有一位，即等于零，则返回零。</span>\n        <span>// HD, Section 2-1</span>\n        <span>return</span> i <span>&amp;</span> <span>-</span>i<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id=\"tounsignedlong方法\"> toUnsignedLong方法</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Integer</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n    <span>/**\n     * \n     * @param x 它是一个用于转换为 unsigned long 的值。\n     * @return\n     */</span>\n    <span>public</span> <span>static</span> <span>long</span> <span>toUnsignedLong</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>(</span><span>long</span><span>)</span> x<span>)</span> <span>&amp;</span> <span>0</span>xffffffffL<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>它通过无符号转换将参数转换为 long。在对 long 的无符号转换中，long 的 high-order 32 位为零，低 32 位等于整数参数的位。</p>\n<h4 id=\"divideunsigned方法\"> divideUnsigned方法</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Integer</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n    <span>/**\n     * e.g. dividend=55,divisor=5, result为11\n     * @param dividend 它是一个将被分割的 int 值。\n     * @param divisor 将进行除法过程的值。\n     * @return\n     */</span>\n    \n    <span>public</span> <span>static</span> <span>int</span> <span>divideUnsigned</span><span>(</span><span>int</span> dividend<span>,</span> <span>int</span> divisor<span>)</span> <span>{</span>\n        <span>// In lieu of tricky code, for now just use long arithmetic.</span>\n        <span>return</span> <span>(</span><span>int</span><span>)</span> <span>(</span><span>toUnsignedLong</span><span>(</span>dividend<span>)</span> <span>/</span> <span>toUnsignedLong</span><span>(</span>divisor<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>该方法它返回第一个参数除以第二个参数的无符号商，其中每个参数和结果都被解释为一个无符号值。</p>\n<h4 id=\"remainderunsigned方法\"> remainderUnsigned方法</h4>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Integer</span> <span>extends</span> <span>Number</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n    <span>/**\n     * dividend=56, divisor=5, the result is 1\n     * @param dividend 它是一个将被分割的 int 值\n     * @param divisor 将进行除法过程的值\n     * @return\n     */</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>remainderUnsigned</span><span>(</span><span>int</span> dividend<span>,</span> <span>int</span> divisor<span>)</span> <span>{</span>\n        <span>// In lieu of tricky code, for now just use long arithmetic.</span>\n        <span>return</span> <span>(</span><span>int</span><span>)</span> <span>(</span><span>toUnsignedLong</span><span>(</span>dividend<span>)</span> <span>%</span> <span>toUnsignedLong</span><span>(</span>divisor<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>它返回第一个参数除以第二个参数的无符号余数，其中每个参数和结果都被解释为无符号值。</p>\n<h2 id=\"_4-经典面试题\"> 4.经典面试题</h2>\n<h3 id=\"_1-integer-a-1、integer-a-new-integer-1-、integer-a-integer-valueof-1-的区别\"> 1. Integer a = 1、Integer a = new Integer(1)、Integer a = Integer.valueOf(1)的区别</h3>\n<ul>\n<li>Integer a = 1与Integer.valueOf(1)含义相同,所存储的对象在方法区的静态区。new Integer(1)存储的位置在堆区。</li>\n<li><code>-128-127</code>的值存储在<code>JVM方法区的静态区</code>,是因为Integer内部有一个静态内部类IntegerCache。</li>\n<li>new Integer(1)存储在<code>JVM堆区</code>，都是通过<code>new Integer(x)</code>创建出来。</li>\n</ul>\n<h3 id=\"_2-你所了解到integercache\"> 2. 你所了解到IntegerCache</h3>\n<ul>\n<li>IntegerCache是Integer类的中的内部静态类</li>\n<li>IntegerCache中有一个低位，有一个高位，有一个Integer类型的数组缓存。其中低位为-128，不可改变，高位如果不设置则为127,高位可以通过通过JVM参数<code>Djava.lang.Integer.IntegerCache.high=xxx</code>进行调整，用缓存的好处在于快速读取，不用再重新创建对象。</li>\n</ul>\n<h2 id=\"_5-文章参考\"> 5. 文章参考</h2>\n<p>1.https://www.cmsblogs.com/article/1389544331186147328</p>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Integer.png",
      "date_published": "2022-10-12T16:22:28.000Z",
      "date_modified": "2022-10-12T16:22:28.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "java基础",
      "url": "https://www.moremind.cn/md/java/basic/",
      "id": "https://www.moremind.cn/md/java/basic/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Basic"
      ]
    },
    {
      "title": "ArrayList源码解析",
      "url": "https://www.moremind.cn/md/java/collection/ArrayList-Source/",
      "id": "https://www.moremind.cn/md/java/collection/ArrayList-Source/",
      "content_html": "<h2 id=\"arraylist是什么\"> ArrayList是什么?</h2>\n<h2 id=\"为什么要使用arraylist\"> 为什么要使用ArrayList?</h2>\n<h2 id=\"在什么环境下使用arraylist\"> 在什么环境下使用ArrayList?</h2>\n<h2 id=\"怎么使用arraylist\"> 怎么使用ArrayList?</h2>\n<h3 id=\"基本api\"> 基本API</h3>\n<h3 id=\"基本源码\"> 基本源码</h3>\n",
      "date_published": "2022-02-24T09:46:27.000Z",
      "date_modified": "2022-04-18T08:35:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Collection"
      ]
    },
    {
      "title": "HashSet源码解析",
      "url": "https://www.moremind.cn/md/java/collection/HashMap&HashSet-Source/",
      "id": "https://www.moremind.cn/md/java/collection/HashMap&HashSet-Source/",
      "content_html": "<h2 id=\"集合关系图谱\"> 集合关系图谱</h2>\n<blockquote>\n<p>Java集合框架包括Collection和Map，Collection主要用于存储对象，Map主要用用于存储键值对数据。</p>\n</blockquote>\n<h2 id=\"collection\"> Collection</h2>\n<h3 id=\"list\"> List</h3>\n<h4 id=\"arraylist\"> ArrayList</h4>\n<h4 id=\"linkedlist\"> LinkedList</h4>\n<h3 id=\"set\"> Set</h3>\n<h4 id=\"hashset\"> Hashset</h4>\n<h4 id=\"linkedhashset\"> LinkedHashSet</h4>\n<h3 id=\"queue\"> Queue</h3>\n<h4 id=\"deque\"> Deque</h4>\n<h4 id=\"arraydeque\"> ArrayDeque</h4>\n",
      "date_published": "2022-04-06T13:44:30.000Z",
      "date_modified": "2022-04-06T13:44:30.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Collection"
      ]
    },
    {
      "title": "LinkedList源码解析",
      "url": "https://www.moremind.cn/md/java/collection/LinkedList-Source/",
      "id": "https://www.moremind.cn/md/java/collection/LinkedList-Source/",
      "content_html": "<h2 id=\"集合关系图谱\"> 集合关系图谱</h2>\n<blockquote>\n<p>Java集合框架包括Collection和Map，Collection主要用于存储对象，Map主要用用于存储键值对数据。</p>\n</blockquote>\n<h2 id=\"collection\"> Collection</h2>\n<h3 id=\"list\"> List</h3>\n<h4 id=\"arraylist\"> ArrayList</h4>\n<h4 id=\"linkedlist\"> LinkedList</h4>\n<h3 id=\"set\"> Set</h3>\n<h4 id=\"hashset\"> Hashset</h4>\n<h4 id=\"linkedhashset\"> LinkedHashSet</h4>\n<h3 id=\"queue\"> Queue</h3>\n<h4 id=\"deque\"> Deque</h4>\n<h4 id=\"arraydeque\"> ArrayDeque</h4>\n",
      "date_published": "2022-02-24T09:46:27.000Z",
      "date_modified": "2022-02-25T06:53:23.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Collection"
      ]
    },
    {
      "title": "java集合框架知识图谱",
      "url": "https://www.moremind.cn/md/java/collection/",
      "id": "https://www.moremind.cn/md/java/collection/",
      "content_html": "<h2 id=\"集合关系图谱\"> 集合关系图谱</h2>\n<blockquote>\n<p>Java集合框架包括Collection和Map，Collection主要用于存储对象，Map主要用用于存储键值对数据。\n<img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Java-collection-cheat-sheet.PNG\" alt=\"Java-Collection\" /></p>\n</blockquote>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>容器，就是可以容纳其他Java对象的对象。*Java Collections Framework(JCF)*为Java开发者提供了通用的容器，其始于JDK 1.2，优点是:</p>\n<ul>\n<li>降低编程难度</li>\n<li>提高程序性能</li>\n<li>提高API间的互操作性</li>\n<li>降低学习难度</li>\n<li>降低设计和实现相关API的难度</li>\n<li>增加程序的重用性\nJava容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</li>\n</ul>\n<h2 id=\"collection\"> Collection</h2>\n<h3 id=\"list\"> List</h3>\n<h4 id=\"arraylist简介\"> ArrayList简介</h4>\n<p>1.ArrayList继承自<code>AbstractList</code>，实现了<code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code>接口。</p>\n<p>2.底层基于动态数组实现容量大小动态变化（容量可自动增长）。</p>\n<p>3.允许<code>null</code>的存在。</p>\n<p>4.ArrayList是支持快速访问、复制、序列化的。基于动态数组实现，支持。</p>\n<p>5.ArrayList是非同步的。</p>\n<p>6.ArrayList的iterator和listIterator方法返回的迭代器是fail-fast的。</p>\n<h4 id=\"linkedlist\"> LinkedList</h4>\n<p>1.LinkedList继承自<code>AbstractSequentialList</code>，实现了<code>List</code>、<code>Deque</code>、<code>Cloneable</code>、<code>Serializable</code>接口，LinkedList是基于链表实现的，只能顺序访问。</p>\n<p>2.<code>LinkedList</code>插入和删除方面要优于<code>ArrayList</code>。</p>\n<p>3.LinkedList是非同步的。</p>\n<p>4.LinkedList的iterator和listIterator方法返回的迭代器是fail-fast的。</p>\n<h3 id=\"set\"> Set</h3>\n<h4 id=\"hashset\"> Hashset</h4>\n<p>1.HashSet继承自<code>AbstractSet</code>,实现了<code>Set</code>、<code>Cloneable</code>、<code>Serializable</code>接口,底层是一个HashMap。</p>\n<p>2.HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。</p>\n<p>3.HashSet中元素都是无序的(即存取顺序不一致)；</p>\n<p>4.HashSet没有下标选取，只能通过增强for循环或者迭代器取出元素；</p>\n<p>5.HashSet是非同步的；</p>\n<p>6.HashSet的iterator方法返回的迭代器是fail-fast的。</p>\n<h4 id=\"linkedhashset\"> LinkedHashSet</h4>\n<p>1.LinkedHashSet继承自<code>HashSet</code>，实现了<code>Set</code>、<code>Cloneable</code>接口，底层其实是一个LinkedHashMap。</p>\n<p>2.不能保证插入和输出的顺序一致。</p>\n<p>3.不允许重复的元素插入，可以插入null。</p>\n<p>4.HashSet的iterator方法返回的迭代器是fail-fast的。</p>\n<h4 id=\"treeset\"> TreeSet</h4>\n<p>1.TreeSet继承自<code>AbstractSet</code>，实现了NavigableSet、Cloneable、Serializable接口。</p>\n<p>2.一种基于<code>TreeMap</code>的<code>NavigableSet</code>实现,意味着它支持一系列的导航方法。</p>\n<p>3.TreeSet是有序的Set集合,通过<code>TreeMap</code>实现的一个有序的、不可重复的集合，底层维护的是红黑树结构。</p>\n<p>4.TreeSet的iterator方法返回的迭代器是fail-fast的。</p>\n<h3 id=\"queue\"> Queue</h3>\n<h4 id=\"arraydeque\"> ArrayDeque</h4>\n<p>1.ArrayDeque是Deque接口的一个实现，使用了可变数组，所以没有容量上的限制。</p>\n<p>2.ArrayDeque是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。</p>\n<p>3.ArrayDeque是Deque的实现类，可以作为栈来使用，效率高于Stack；\n也可以作为队列来使用，效率高于LinkedList。</p>\n<p>4.ArrayDeque不支持null值。</p>\n<p>5.ArrayDeque的iterator方法返回的迭代器是fail-fast的。</p>\n<p>6.ArrayDeque两端都可以操作,支持双向迭代器遍历。</p>\n<h4 id=\"priorityqueue\"> PriorityQueue</h4>\n<p>1.PriorityQueue继承自<code>AbstractQueue</code>，实现了<code>Serializable</code>接口。</p>\n<p>2.PriorityQueue队列元素根据自然排序或者根据具体的比较器排序。</p>\n<p>3.PriorityQueue实例化时若未指定初始容量，默认容量为11。</p>\n<p>4.PriorityQueue自动扩容。如果容量小于64，两倍增长扩容；否则增长50%,PriorityQueue是无边界容器。</p>\n<p>5.PriorityQueue的迭代器不具有以特定顺序访问队列元素。</p>\n<p>6.PriorityQueue不支持<code>null</code>元素。</p>\n<p>7.PriorityQueue入队出队的时间复杂度O(log(n))</p>\n<h2 id=\"map\"> Map</h2>\n<h3 id=\"hashmap\"> HashMap</h3>\n<p>1.HashMap继承自<code>AbstractMap</code>,实现<code>Map</code>、<code>Cloneable</code>、<code>Serializable</code>接口。</p>\n<p>2.HashMap 基于哈希表的Map接口实现，是以 key-value 存储形式存在，即主要用来存放键值对。</p>\n<p>3.HashMap 的实现不是同步的，这意味着它不是线程安全的。</p>\n<p>4.HashMap 中的映射不是有序的(即存取顺序不一致)。</p>\n<p>5.JDK1.5-JDK1.7实现的结果是数组+链表，JDK1.8实现结构是数组+链表+红黑树。</p>\n<p>6.HashMap key值能为null,value值可以为null，且key值不允许重复。</p>\n<p>7.HashMap的iterator方法返回的迭代器是fail-fastl的。</p>\n<h3 id=\"linkedhashmap\"> LinkedHashMap</h3>\n<p>1.LinkedHashMap继承自<code>HashMap</code>,实现了<code>Map</code>接口。</p>\n<p>2.LinkedHashMap维护了一个Entry的双向链表，保证了插入的Entry中的顺序。</p>\n<p>3.使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</p>\n<p>4.LinkedHashMap的iterator方法返回的迭代器是fail-fastl的。</p>\n<h3 id=\"treemap\"> TreeMap</h3>\n<p>1.TreeMap 继承自AbstractMap，实现了<code>NavigableMap</code>、<code>Cloneable</code>、<code>Serializable接口</code>。</p>\n<p>2.TreeMap不允许出现重复的key。</p>\n<p>3.TreeMap可以插入null键，null值。</p>\n<p>4.TreeMap可以对元素进行排序。</p>\n<p>5.TreeMap无序集合（插入和遍历顺序不一致）。</p>\n<p>6.TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的Comparator进行排序，具体取决于使用的构造方法。</p>\n<p>7.TreeMap的iterator方法返回的迭代器是fail-fastl的。</p>\n<h3 id=\"hashtable\"> HashTable</h3>\n<p>1.与HashMap一样，Hashtable也是一个散列表，是以key-value存储形式存在，即主要用来存放键值对；</p>\n<p>2.与HashMap不同，Hashtable的函数都是同步的，这意味着它是线程安全的；</p>\n<p>3.Hashtable的key、value都不可以为null，并且，Hashtable中的映射不是有序的；</p>\n<p>4.实现结构是数组+单向链表。</p>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Java-collection-cheat-sheet.PNG",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-07-02T17:06:40.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Collection"
      ]
    },
    {
      "title": "TreeMap&TreeSet源码解析",
      "url": "https://www.moremind.cn/md/java/collection/TreeMap&TreeSet-Source/",
      "id": "https://www.moremind.cn/md/java/collection/TreeMap&TreeSet-Source/",
      "content_html": "<h2 id=\"集合关系图谱\"> 集合关系图谱</h2>\n<blockquote>\n<p>Java集合框架包括Collection和Map，Collection主要用于存储对象，Map主要用用于存储键值对数据。</p>\n</blockquote>\n<h2 id=\"collection\"> Collection</h2>\n<h3 id=\"list\"> List</h3>\n<h4 id=\"arraylist\"> ArrayList</h4>\n<h4 id=\"linkedlist\"> LinkedList</h4>\n<h3 id=\"set\"> Set</h3>\n<h4 id=\"hashset\"> Hashset</h4>\n<h4 id=\"linkedhashset\"> LinkedHashSet</h4>\n<h3 id=\"queue\"> Queue</h3>\n<h4 id=\"deque\"> Deque</h4>\n<h4 id=\"arraydeque\"> ArrayDeque</h4>\n",
      "date_published": "2022-04-06T13:44:30.000Z",
      "date_modified": "2022-04-06T13:44:30.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Collection"
      ]
    },
    {
      "title": "Java IO框架图谱",
      "url": "https://www.moremind.cn/md/java/io/",
      "id": "https://www.moremind.cn/md/java/io/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-17T14:28:59.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-IO"
      ]
    },
    {
      "title": "JVM前奏-JVM堆栈内存简析",
      "url": "https://www.moremind.cn/md/java/jvm/JVM-1/",
      "id": "https://www.moremind.cn/md/java/jvm/JVM-1/",
      "content_html": "<h2 id=\"_1-官网\"> 1 官网</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310000943157.png\" alt=\"image-20220310000943157\" /></p>\n<h3 id=\"_1-1-jdk8\"> 1.1 JDK8</h3>\n<h3 id=\"_1-2-the-relation-of-jdk-jre-jvm\"> 1.2 The relation of JDK/JRE/JVM</h3>\n<p>Reference -&gt; Developer Guides -&gt; 定位到:https://docs.oracle.com/javase/8/docs/index.html</p>\n<blockquote>\n<p>JDK 8 is a superset of JRE 8, and contains everything that is in JRE 8, plus tools such as the compilers and debuggers necessary for developing applets and applications. JRE 8 provides the libraries, the Java Virtual Machine (JVM), and other components to run applets and applications written in the Java programming language. Note that the JRE includes components not required by the Java SE specification, including both standard and non-standard Java components.</p>\n</blockquote>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309202058012.png\" alt=\"image-20220309202058012\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309203220133.png\" alt=\"image-20220309203220133\" /></p>\n<h2 id=\"_2-源码到类文件\"> 2 源码到类文件</h2>\n<h3 id=\"_2-1-源码\"> 2.1 源码</h3>\n<div><pre><code><span>class</span> <span>Person</span><span>{</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n    <span>private</span> <span>static</span> <span>String</span> address<span>;</span>\n    <span>private</span> <span>final</span> <span>static</span> <span>String</span> hobby<span>=</span><span>\"Programming\"</span><span>;</span>\n    <span>public</span> <span>void</span> <span>say</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"person say...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>int</span> <span>calc</span><span>(</span><span>int</span> op1<span>,</span><span>int</span> op2<span>)</span><span>{</span>\n        <span>return</span> op1<span>+</span>op2<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_2-2-编译过程\"> 2.2 编译过程</h3>\n<blockquote>\n<p>Person.java -&gt; 词法分析器 -&gt; tokens流 -&gt; 语法分析器 -&gt; 语法树/抽象语法树 -&gt; 语义分析器 -&gt; 注解抽象语法树 -&gt; 字节码生成器 -&gt; Person.class文件</p>\n</blockquote>\n<h3 id=\"_2-3-类文件-class文件\"> 2.3 类文件(Class文件)</h3>\n<p>官网The class File Format :https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</p>\n<div><pre><code>cafe babe 0000 0034 0027 0a00 0600 1809\n0019 001a 0800 1b0a 001c 001d 0700 1e07\n001f 0100 046e 616d 6501 0012 4c6a 6176\n612f 6c61 6e67 2f53 7472 696e 673b 0100\n0361 6765 0100 0149 0100 0761 6464 7265\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309204252776.png\" alt=\"image-20220309204252776\" /></p>\n<p><strong>minor_version, major_version</strong></p>\n<div><pre><code>minor_version, major_version\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>constant_pool_count</strong></p>\n<p>0027 对应十进制27，代表常量池中27个常量</p>\n<div><pre><code>ClassFile {\n    u4             magic;\n    u2             minor_version;\n    u2             major_version;\n    u2             constant_pool_count;\n    cp_info        constant_pool[constant_pool_count-1];\n    u2             access_flags;\n    u2             this_class;\n    u2             super_class;\n    u2             interfaces_count;\n    u2             interfaces[interfaces_count];\n    u2             fields_count;\n    field_info     fields[fields_count];\n    u2             methods_count;\n    method_info    methods[methods_count];\n    u2             attributes_count;\n    attribute_info attributes[attributes_count];\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>.class字节码文件</strong></p>\n<div><pre><code>魔数与class文件版本\n常量池\n访问标志\n类索引、父类索引、接口索引\n字段表集合\n方法表集合\n属性表集合\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"_3-类文件到虚拟机-类加载机制\"> 3 类文件到虚拟机(类加载机制)</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309204625348.png\" alt=\"image-20220309204625348\" /></p>\n<h3 id=\"_3-1-装载-load\"> 3.1 装载(Load)</h3>\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html\" target=\"_blank\" rel=\"noopener noreferrer\">Chapter 5. Loading, Linking, and Initializing (oracle.com)</a></p>\n<p>a.找到类文件所在的位置---:磁盘--&gt;类装载器ClassLoader --&gt; 寻找类</p>\n<p>b.类文件的信息交给JVM  --&gt; 类文件字节码流静态存储结构 --&gt; JVM里卖弄的某一块区域</p>\n<p>c.类文件所对应的对象Class ---&gt; JVM</p>\n<p>查找和导入class文件 --&gt; JVM --&gt; 堆</p>\n<div><pre><code>(1)通过一个类的全限定名获取定义此类的二进制字节流\n(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-2-链接-link\"> 3.2 链接(Link)</h3>\n<h4 id=\"_3-2-1-验证-verify-保证被加载类的正确性\"> 3.2.1 验证(Verify):保证被加载类的正确性</h4>\n<ul>\n<li>\n<p>文件格式验证</p>\n</li>\n<li>\n<p>元数据验证</p>\n</li>\n<li>\n<p>字节码验证</p>\n</li>\n<li>\n<p>符号引用验证</p>\n</li>\n</ul>\n<h4 id=\"_3-2-2-准备-prepare\"> 3.2.2 准备(Prepare)</h4>\n<p><strong>为类的静态变量分配内存，并将其初始化为默认值</strong></p>\n<p>static int num = 10; // 在准备阶段为num分配内存空间，并初始化其值为0</p>\n<h4 id=\"_3-2-3-解析-resolve\"> 3.2.3 解析(Resolve)</h4>\n<p><strong>把类中的符号引用转换为直接引用</strong></p>\n<p>地址：String str =地址是什么，直接对应到内存中某个地址指向。</p>\n<h3 id=\"_3-3-初始化-initialize\"> 3.3 初始化(Initialize)</h3>\n<p>对类的静态变量，静态代码块执行初始化操作</p>\n<p>static int num = 10; // 此时，num才会被真正的赋值为10</p>\n<h3 id=\"_3-4-类加载机制图解\"> 3.4 类加载机制图解</h3>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309205334127.png\" alt=\"image-20220309205334127\" /></p>\n<h2 id=\"_4-类装载器classloader\"> 4 类装载器ClassLoader</h2>\n<p>在装载(Load)阶段，其中第(1)步:通过类的全限定名获取其定义的二进制字节流，需要借助类装载 器完成，顾名思义，就是用来装载Class文件的。</p>\n<p>(1)通过一个类的全限定名获取定义此类的二进制字节流。</p>\n<h3 id=\"_4-1-分类\"> 4.1 分类</h3>\n<p>1）Bootstrap ClassLoader 负责加载$JAVA_HOME中 jre/lib/rt.jar 里所有的class或 Xbootclassoath选项指定的jar包。由C++实现，不是ClassLoader子类。</p>\n<p>2）Extension ClassLoader 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中 jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。</p>\n<p>3）App ClassLoader 负责加载classpath中指定的jar包及 Djava.class.path 所指定目录下的类和 jar包。</p>\n<p>4）Custom ClassLoader 通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据 自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。</p>\n<h3 id=\"_4-2-图解\"> 4.2 图解</h3>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309205433326.png\" alt=\"image-20220309205433326\" /></p>\n<h3 id=\"_4-3-加载原则\"> 4.3 加载原则</h3>\n<p><strong>检查某个类是否已经加载：顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检 查，只要某个Classloader已加载，就视为已加载此类，保证此类只所有ClassLoader加载一次。</strong></p>\n<p><strong>加载的顺序：加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</strong></p>\n<p><strong>双亲委派机制：</strong></p>\n<blockquote>\n<p>定义：如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把 这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就 成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>\n</blockquote>\n<blockquote>\n<p>优势：Java类随着加载它的类加载器一起具备了一种带有优先级的层次关系。比如，Java中的 Object类，它存放在rt.jar之中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型 最顶端的启动类加载器进行加载，因此Object在各种类加载环境中都是同一个类。如果不采用 双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的Object 类。</p>\n</blockquote>\n<blockquote>\n<p>破坏：可以继承ClassLoader类，然后重写其中的loadClass方法，其他方式大家可以自己了解 拓展一下。</p>\n</blockquote>\n<h2 id=\"_5-运行时数据区-run-time-data-areas\"> 5 运行时数据区(Run-Time Data Areas)</h2>\n<p>在装载阶段的第(2),(3)步可以发现有运行时数据，堆，方法区等名词</p>\n<p>(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>\n<p>(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</p>\n<p>说白了就是类文件被类装载器装载进来之后，类中的内容(比如变量，常量，方法，对象等这些数 据得要有个去处，也就是要存储起来，存储的位置肯定是在JVM中有对应的空间)</p>\n<h3 id=\"_5-1-官网概括\"> 5.1 官网概括</h3>\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5\" target=\"_blank\" rel=\"noopener noreferrer\">Chapter 2. The Structure of the Java Virtual Machine (oracle.com)</a></p>\n<div><pre><code>The Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these data areas are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits. Other data areas are per thread. Per-thread data areas are created when a thread is created and destroyed when the thread exits\n\n&gt;&gt;&gt; Java 虚拟机定义了在程序执行期间使用的各种运行时数据区域。 其中一些数据区是在 Java 虚拟机启动时创建的，只有在 Java 虚拟机退出时才会被销毁。 其他数据区域是每个线程。 每线程数据区在创建线程时创建，在线程退出时销毁\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_5-2-图解\"> 5.2 图解</h3>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309213359201.png\" alt=\"image-20220309213359201\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309211847128.png\" alt=\"image-20220309211847128\" /></p>\n<h3 id=\"_5-3-常规理解\"> 5.3 常规理解</h3>\n<h4 id=\"_5-3-1-method-area-方法区-类信息、常量、静态变量、即使编译器编译之后的代码\"> 5.3.1 Method Area(方法区):类信息、常量、静态变量、即使编译器编译之后的代码</h4>\n<blockquote>\n<p>在JDK1.8中，方法区存放运行时常量池、方法数据、方法的代码和构造方法，包括类中的实例化方法和接口初始化方法。\n存放如下数据：</p>\n</blockquote>\n<div><pre><code><span>// 该类型数据存放在方法区</span>\n<span>public</span> <span>static</span> <span>final</span> CONSTSANT <span>=</span> <span>\"constant\"</span><span>;</span>\n\n<span>// 方法区存放方法以及方法的代码</span>\n<span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n   <span>// 该方法存放在方法区</span>\n   <span>public</span> <span>Test</span><span>(</span><span>)</span> <span>{</span>\n   <span>}</span>\n   \n   <span>// 该方法存放在方法区</span>\n   <span>public</span> <span>void</span> <span>testMethod</span><span>(</span><span>)</span> <span>{</span>\n   <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>interface</span> <span>IXXService</span><span>(</span><span>)</span> <span>{</span>\n   <span>// 该方法存放在方法区</span>\n   <span>default</span> <span>void</span> test <span>(</span><span>)</span> <span>{</span>\n       \n   <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code>The Java Virtual Machine has a method area that is shared among all Java Virtual\nMachine threads.\n&gt;&gt; 方法区只有一个，线程共享的内存区域【线程非安全】，生命周期是跟虚拟机一样的。\n\nIt stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods (§2.9) used in class and instance initialization and interface initialization.\n&gt;&gt; 类信息、常量、静态变量、即使编译器编译之后的代码。\n\nThe method area is created on virtual machine start-up.\n\nAlthough the method area is logically part of the heap【逻辑上是属于堆的一部分】, simple implementations may choose not to either garbage collect or compact it.\n垃圾回收不太会讨论方法区的垃圾回收\n\nIf memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an OutOfMemoryError.\n&gt;&gt; OOM\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>方法区是各个线程共享的内存区域，在虚拟机启动时创建。</strong></p>\n<p><strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong></p>\n<p><strong>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-Heap(非堆)，目 的是与Java堆区分开来。</strong></p>\n<p><strong>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</strong></p>\n<blockquote>\n<p>此时回看装载阶段的第2步：(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据 结构</p>\n</blockquote>\n<p>如果这时候把从Class文件到装载的第(1)和(2)步合并起来理解的话，可以画个图</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309211440247.png\" alt=\"image-20220309211440247\" /></p>\n<p><strong>(1)方法区在JDK 8中就是Metaspace，在JDK6或7中就是Perm Space (2)Run-Time Constant Pool</strong></p>\n<p><strong>(2)Run-Time Constant Pool</strong></p>\n<p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，</p>\n<p>还有一项信息就是常量池，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在 类加载后进 入方法区的运行时常量池中存放。</p>\n<blockquote>\n<p>Each run-time constant pool is allocated from the Java Virtual Machine's method area (§2.5.4).s</p>\n<p>每个运行时常量池都是从 Java 虚拟机的方法中分配的区域 (§2.5.4).s</p>\n</blockquote>\n<h4 id=\"_5-3-2-heap-堆-对象或者数组\"> 5.3.2 Heap(堆):对象或者数组</h4>\n<p>Java堆是Java虚拟机所管理内存中最大的一块，在虚拟机启动时创建，被所有线程共享。</p>\n<p>Java对象实例以及数组都在堆上分配。</p>\n<div><pre><code>The Java Virtual Machine has a heap that is shared among all Java Virtual Machine threads. \n堆只有一个，线程共享内存区域的【线程非安全】，生命周期跟虚拟机一样。\n\nThe heap is the run-time data area from which memory for all class instances and arrays is allocated.\n存储数据包括：对象或者数组\n\nThe heap is created on virtual machine start-up. \n\nIf a computation requires more heap than can be made available by the automatic storage management system, the Java Virtual Machine throws an OutOfMemoryError.\n【如果内存不够，也会发生OOM】\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>此时回看装载阶段的第3步：(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方 法区中这些数据的访问入口</p>\n<p>此时装载(1)(2)(3)的图可以改动一下</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309211847128.png\" alt=\"image-20220309211847128\" /></p>\n<h4 id=\"_5-3-3-java-virtual-machine-stacks-虚拟机栈-局部变量、操作数、返回数\"> 5.3.3 Java Virtual Machine Stacks(虚拟机栈):局部变量、操作数、返回数</h4>\n<div><pre><code>Each Java Virtual Machine thread has a private Java Virtual Machine stack,\ncreated at the same time as the thread. A Java Virtual Machine stack stores\nframes (§2.6)\n【每个线程独有的线程栈】\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一个线程的创建代表一个栈，每个方法被当前线程调用了，就代表一个栈帧。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309220003612.png\" alt=\"image-20220309220003612\" /></p>\n<div><pre><code>If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a StackOverflowError.\n【StackOverflowError】\n\nIf Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an OutOfMemoryError.\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<p>经过上面的分析，类加载机制的装载过程已经完成，后续的链接，初始化也会相应的生效。</p>\n<p>假如目前的阶段是初始化完成了，后续做啥呢？肯定是Use使用咯，不用的话这样折腾来折腾去 有什么意义？那怎样才能被使用到？换句话说里面内容怎样才能被执行？比如通过主函数main调 用其他方法，这种方式实际上是main线程执行之后调用的方法，即要想使用里面的各种内容，得 要以线程为单位，执行相应的方法才行。</p>\n<p>那一个线程执行的状态如何维护？一个线程可以执行多少个方法？这样的关系怎么维护呢？</p>\n</blockquote>\n<p>虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。换句话说，一个Java线程的运行 状态，由一个虚拟机栈来保存，所以虚拟机栈肯定是线程私有的，独有的，随着线程的创建而创建。</p>\n<p>每一个被线程执行的方法，为该栈中的栈帧，即每个方法对应一个栈帧。</p>\n<p>调用一个方法，就会向栈中压入一个栈帧；一个方法调用完成，就会把该栈帧从栈中弹出。</p>\n<h4 id=\"_5-3-4-the-pc-register-程序计数器\"> 5.3.4 The pc Register(程序计数器)</h4>\n<blockquote>\n<p>我们都知道一个JVM进程中有多个线程在执行，而线程中的内容是否能够拥有执行权，是根据 CPU调度来的。</p>\n<p>假如线程A正在执行到某个地方，突然失去了CPU的执行权，切换到线程B了，然后当线程A再获 得CPU执行权的时候，怎么能继续执行呢？这就是需要在线程中维护一个变量，记录线程执行到 的位置。</p>\n</blockquote>\n<p>程序计数器占用的内存空间很小，由于Java虚拟机的多线程是通过线程轮流切换，并分配处理器执行时 间的方式来实现的，在任意时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能够 恢复到正确的执行位置，每条线程需要有一个独立的程序计数器(线程私有)。</p>\n<p>如果线程正在执行Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；</p>\n<p>如果正在执行的是Native方法，则这个计数器为空。</p>\n<div><pre><code>The Java Virtual Machine can support many threads of execution at once (JLS §17). Each Java Virtual Machine thread has its own pc (program counter)register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method (§2.6) for that thread. If that method is not native, the pc register contains the address of the Java Virtual Machine instruction currently being executed. If the method currently being executed by the thread is native, the value of the Java Virtual Machine&#39;s pcregister is undefined. The Java Virtual Machine&#39;s pc register is wide enough to hold a returnAddress or a native pointer on the specific platform\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_5-3-5-native-method-stacks-本地方法栈\"> 5.3.5 Native Method Stacks(本地方法栈)</h4>\n<div><pre><code>An implementation of the Java Virtual Machine may use conventional stacks, colloquially called &quot;C stacks,&quot; to support native methods (methods written in a language other than the Java programming language).\n\n&gt;&gt; Java 虚拟机的实现可以使用传统的堆栈，通俗地称为“C 堆栈”，以支持本地方法（以 Java 编程语言以外的语言编写的方法）\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果当前线程执行的方法是Native类型的，这些方法就会在本地方法栈中执行。</p>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310000943157.png",
      "date_published": "2022-05-05T10:22:38.000Z",
      "date_modified": "2022-10-12T16:22:28.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM进行时-JVM堆栈内存详解",
      "url": "https://www.moremind.cn/md/java/jvm/JVM-2/",
      "id": "https://www.moremind.cn/md/java/jvm/JVM-2/",
      "content_html": "<h2 id=\"_1-结合字节码指令理解java虚拟机栈和栈帧\"> 1 结合字节码指令理解Java虚拟机栈和栈帧</h2>\n<blockquote>\n<p>官网 ：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6</p>\n<p>栈帧：每个栈帧对应一个被调用的方法，可以理解为一个方法的运行空间。</p>\n</blockquote>\n<p>每个栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向运行时常量池的引用(A reference to the run-time constant pool)、方法返回地址(Return Address)和附加信息。</p>\n<div><pre><code>每个栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向运行时常量池的引用(A reference to the run-time constant pool)、方法返回地址(Return Address)和附加信息。\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>操作数栈:以压栈和出栈的方式存储操作数的\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>动态链接:每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>方法返回地址:当一个方法开始执行后,只有两种方式可以退出，一种是遇到方法返回的字节码指令；一种是遇见异常，并且这个异常没有在方法体内得到处理。\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309223600414.png\" alt=\"image-20220309223600414\" /></p>\n<div><pre><code><span>class</span> <span>Person</span><span>{</span>\n    <span>private</span> <span>String</span> name<span>=</span><span>\"Jack\"</span><span>;</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n    <span>private</span> <span>final</span> <span>double</span> salary<span>=</span><span>100</span><span>;</span>\n    <span>private</span> <span>static</span> <span>String</span> address<span>;</span>\n    <span>private</span> <span>final</span> <span>static</span> <span>String</span> hobby<span>=</span><span>\"Programming\"</span><span>;</span>\n    <span>public</span> <span>void</span> <span>say</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"person say...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>calc</span><span>(</span><span>int</span> op1<span>,</span><span>int</span> op2<span>)</span><span>{</span>\n        op1<span>=</span><span>3</span><span>;</span>\n        <span>int</span> result<span>=</span>op1<span>+</span>op2<span>;</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>order</span><span>(</span><span>)</span><span>{</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>\n        <span>calc</span><span>(</span><span>1</span><span>,</span><span>2</span><span>)</span><span>;</span>\n        <span>order</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>\n<p>此时你需要一个能够看懂反编译指令的宝典</p>\n<p>比如官网的：https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</p>\n</blockquote>\n<div><pre><code><span>class</span> <span>Person</span> <span>{</span>\n  <span>Person</span><span>(</span><span>)</span><span>;</span>\n    <span>Code</span><span>:</span>\n       <span>0</span><span>:</span> aload_0\n       <span>1</span><span>:</span> invokespecial #<span>1</span>                  <span>// Method java/lang/Object.\"&lt;init>\":()V</span>\n       <span>4</span><span>:</span> aload_0\n       <span>5</span><span>:</span> ldc           #<span>2</span>                  <span>// String Jack</span>\n       <span>7</span><span>:</span> putfield      #<span>3</span>                  <span>// Field name:Ljava/lang/String;</span>\n      <span>10</span><span>:</span> aload_0\n      <span>11</span><span>:</span> ldc2_w        #<span>4</span>                  <span>// double 100.0d</span>\n      <span>14</span><span>:</span> putfield      #<span>6</span>                  <span>// Field salary:D</span>\n      <span>17</span><span>:</span> <span>return</span>\n\n  <span>public</span> <span>void</span> <span>say</span><span>(</span><span>)</span><span>;</span>\n    <span>Code</span><span>:</span>\n       <span>0</span><span>:</span> getstatic     #<span>7</span>                  <span>// Field java/lang/System.out:Ljava/io/PrintStream;</span>\n       <span>3</span><span>:</span> ldc           #<span>8</span>                  <span>// String person say...</span>\n       <span>5</span><span>:</span> invokevirtual #<span>9</span>                  <span>// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>\n       <span>8</span><span>:</span> <span>return</span>\n\n  <span>public</span> <span>static</span> <span>int</span> <span>calc</span><span>(</span><span>int</span><span>,</span> <span>int</span><span>)</span><span>;</span>\n    <span>Code</span><span>:</span>\n       <span>0</span><span>:</span> iconst_3  <span>//将int类型常量3压入[操作数栈]</span>\n       <span>1</span><span>:</span> istore_0  <span>//将int类型值存入局部变量表[局部变量0] ==> op = 3</span>\n       <span>2</span><span>:</span> iload_0   <span>//从[局部变量0]中装载int类型值入栈</span>\n       <span>3</span><span>:</span> iload_1   <span>//从[局部变量1]中装载int类型值入栈</span>\n       <span>4</span><span>:</span> iadd      <span>//将栈顶元素弹出栈，执行int类型的加法，结果入栈</span>\n       <span>5</span><span>:</span> istore_2  <span>//将栈顶int类型值保存到[局部变量2]中</span>\n       <span>6</span><span>:</span> iload_2   <span>//从[局部变量2]中装载int类型值入栈</span>\n       <span>7</span><span>:</span> ireturn   <span>//从方法中返回int类型的数据</span>\n\n  <span>public</span> <span>static</span> <span>void</span> <span>order</span><span>(</span><span>)</span><span>;</span>\n    <span>Code</span><span>:</span>\n       <span>0</span><span>:</span> <span>return</span>\n\n  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span><span>java<span>.</span>lang<span>.</span></span>String</span><span>[</span><span>]</span><span>)</span><span>;</span>\n    <span>Code</span><span>:</span>\n       <span>0</span><span>:</span> iconst_1\n       <span>1</span><span>:</span> iconst_2\n       <span>2</span><span>:</span> invokestatic  #<span>10</span>                 <span>// Method calc:(II)I</span>\n       <span>5</span><span>:</span> pop\n       <span>6</span><span>:</span> invokestatic  #<span>11</span>                 <span>// Method order:()V</span>\n       <span>9</span><span>:</span> <span>return</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309223510002.png\" alt=\"image-20220309223510002\" /></p>\n<h2 id=\"_2-折腾一下\"> 2 折腾一下</h2>\n<h3 id=\"_2-1栈指向堆\"> 2.1栈指向堆</h3>\n<p>如果在栈帧中有一个变量，类型为引用类型，比如Object obj=new Object()，这时候就是典型的栈中元素指向堆中的对象。</p>\n<div><pre><code><span>class</span> <span>Person</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>order</span><span>(</span><span>)</span> <span>{</span>\n        <span>Object</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309230040459.png\" alt=\"image-20220309230040459\" /></p>\n<h3 id=\"_2-2-方法区指向堆\"> 2.2 方法区指向堆</h3>\n<p>方法区中会存放静态变量，常量等数据。如果是下面这种情况，就是典型的方法区中元素指向堆中的对象。</p>\n<div><pre><code><span>class</span> <span>Person</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>Object</span> obj<span>=</span><span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span> <span>// 方法区指向堆</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309230410111.png\" alt=\"image-20220309230410111\" /></p>\n<h3 id=\"_2-3-堆指向方法区\"> 2.3 堆指向方法区</h3>\n<p>方法区中会包含类的信息，堆中会有对象，那怎么知道对象是哪个类创建的呢？</p>\n<p>思考 ：一个对象怎么知道它是由哪个类创建出来的？怎么记录？这就需要了解一个Java对象的具体信息咯。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309230858070.png\" alt=\"image-20220309230858070\" /></p>\n<h3 id=\"_2-4-java对象内存布局\"> 2.4 Java对象内存布局</h3>\n<p>一个Java对象在内存中包括3个部分：对象头、实例数据和对齐填充</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309230913143.png\" alt=\"image-20220309230913143\" /></p>\n<h2 id=\"_3-内存模型\"> 3 内存模型</h2>\n<h3 id=\"_3-1-图解\"> 3.1 图解</h3>\n<div><pre><code>一块是非堆区，一块是堆区。\n堆区分为两大块，一个是Old区，一个是Young区。\nYoung区分为两大块，一个是Survivor区（S0+S1），一块是Eden区。 Eden:S0:S1=8:1:1\nS0和S1一样大，也可以叫From和To。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309233401625.png\" alt=\"image-20220309233401625\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309233506458.png\" alt=\"image-20220309233506458\" /></p>\n<p>根据之前对于Heap的介绍可以知道，一般对象和数组的创建会在堆中分配内存空间，关键是堆中有这么多区 域，那一个对象的创建到底在哪个区域呢？</p>\n<h3 id=\"_3-2-对象创建所在区域\"> 3.2 对象创建所在区域</h3>\n<p>一般情况下，新创建的对象都会被分配到Eden区，一些特殊的大的对象会直接分配到Old区。</p>\n<blockquote>\n<p>比如有对象A，B，C等创建在Eden区，但是Eden区的内存空间肯定有限，比如有100M，假如已经使用了 100M或者达到一个设定的临界值，这时候就需要对Eden内存空间进行清理，即垃圾收集(Garbage Collect)， 这样的GC我们称之为Minor GC，Minor GC指得是Young区的GC。 经过GC之后，有些对象就会被清理掉，有些对象可能还存活着，对于存活着的对象需要将其复制到Survivor 区，然后再清空Eden区中的这些对象。</p>\n</blockquote>\n<h3 id=\"_3-3-survivor区详解\"> 3.3 Survivor区详解</h3>\n<p>由图解可以看出，Survivor区分为两块S0和S1，也可以叫做From和To。</p>\n<p>在同一个时间点上，S0和S1只能有一个区有数据，另外一个是空的。</p>\n<blockquote>\n<p>接着上面的GC来说，比如一开始只有Eden区和From中有对象，To中是空的。</p>\n<p>此时进行一次GC操作，From区中对象的年龄就会+1，我们知道Eden区中所有存活的对象会被复制到To区， From区中还能存活的对象会有两个去处。</p>\n<p>若对象年龄达到之前设置好的年龄阈值，此时对象会被移动到Old区，如果Eden区和From区没有达到阈值的</p>\n<p>对象会被复制到To区。 此时Eden区和From区已经被清空(被GC的对象肯定没了，没有被GC的对象都有了各 自的去处)</p>\n<p>这时候From和To交换角色，之前的From变成了To，之前的To变成了From。</p>\n<p>也就是说无论如何都要保证名为To的Survivor区域是空的。</p>\n<p>Minor GC会一直重复这样的过程，直到To区被填满，然后会将所有对象复制到老年代中。</p>\n</blockquote>\n<p>从上面的分析可以看出，一般Old区都是年龄比较大的对象，或者相对超过了某个阈值的对象。</p>\n<p>在Old区也会有GC的操作，Old区的GC我们称作为Major GC。</p>\n<h3 id=\"_3-4-old区详解\"> 3.4 Old区详解</h3>\n<p>从上面的分析可以看出，一般Old区都是年龄比较大的对象，或者相对超过了某个阈值的对象。 在Old区也会有GC的操作，Old区的GC我们称作为Major GC。</p>\n<h3 id=\"_3-5-对象的一辈子理解\"> 3.5 对象的一辈子理解</h3>\n<div><pre><code>我是一个普通的Java对象,我出生在Eden区,在Eden区我还看到和我长的很像的小兄弟,我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了,我就被迫去了Survivor区的“From”区,自从去了Survivor区,我就开始漂了,有时候在Survivor的“From”区,有时候在Survivor的“To”区,居无定所。直到我18岁的时候,爸爸说我成人了,该去社会上闯闯了。\n于是我就去了年老代那边,年老代里,人很多,并且年龄都挺大的,我在这里也认识了很多人。在年老代里,我生活了20年(每次GC加一岁),然后被回收。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309235221230.png\" alt=\"image-20220309235221230\" /></p>\n<h3 id=\"_3-6-常见问题\"> 3.6 常见问题</h3>\n<ul>\n<li>\n<p>如何理解Minor/Major/Full GC</p>\n<div><pre><code>Minor GC:新生代\nMajor GC:老年代\nFull GC:新生代+老年代\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>\n<li>\n<p>为什么需要Survivor区?只有Eden不行吗？</p>\n<div><pre><code>如果没有Survivor,Eden区每进行一次Minor GC,并且没有年龄限制的话，存活的对象就会被送到老年代。\n这样一来，老年代很快被填满,触发Major GC(因为Major GC一般伴随着Minor GC,也可以看做触发了Full GC)。\n老年代的内存空间远大于新生代,进行一次Full GC消耗的时间比Minor GC长得多。\n执行时间长有什么坏处?频发的Full GC消耗的时间很长,会影响大型程序的执行和响应速度。\n\n可能你会说，那就对老年代的空间进行增加或者较少咯。\n假如增加老年代空间，更多存活对象才能填满老年代。虽然降低Full GC频率，但是随着老年代空间加大,一旦发生Full GC,执行所需要的时间更长。\n假如减少老年代空间，虽然Full GC所需时间减少，但是老年代很快被存活对象填满,Full GC频率增加。\n\n所以Survivor的存在意义,就是减少被送到老年代的对象,进而减少Full GC的发生,Survivor的预筛选保证,只有经历16次Minor GC还能在新生代中存活的对象,才会被送到老年代。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>\n<li>\n<p>为什么需要两个Survivor区?</p>\n<div><pre><code>最大的好处就是解决了碎片化。也就是说为什么一个Survivor区不行?第一部分中,我们知道了必须设置Survivor区。假设现在只有一个Survivor区,我们来模拟一下流程:\n刚刚新建的对象在Eden中,一旦Eden满了,触发一次Minor GC,Eden中的存活对象就会被移动Survivor区。这样继续循环下去,下一次Eden满了的时候,问题来了,此时进行Minor GC,Eden和Survivor各有一些存活对象,如果此时把Eden区的存活对象硬放到Survivor区,很明显这两部分对象所占有的内存是不连续的,也就导致了内存碎片化。\n永远有一个Survivor space是空的,另一个非空的Survivor space无碎片。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>\n<li>\n<p>新生代中Eden:S1:S2为什么是8:1:1？</p>\n<div><pre><code>新生代中的可用内存：复制算法用来担保的内存为9：1\n可用内存中Eden：S1区为8：1\n即新生代中Eden:S1:S2 = 8：1：1\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>\n</ul>\n<h2 id=\"_4-体验与验证\"> 4 体验与验证</h2>\n<h3 id=\"_4-1-使用jvisualvm查看\"> 4.1 使用jvisualvm查看</h3>\n<p>visualgc插件下载链接 ： https://visualvm.github.io/pluginscenters.html ---&gt;选择对应版本链接---&gt;Tools---&gt;Visual GC</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310000015238.png\" alt=\"image-20220310000015238\" /></p>\n<h3 id=\"_4-1-堆内存溢出\"> 4.1 堆内存溢出</h3>\n<h4 id=\"_4-1-1-代码\"> 4.1.1 代码</h4>\n<div><pre><code><span>@RestController</span>\n<span>public</span> <span>class</span> <span>HeapController</span> <span>{</span>\n    <span>List</span><span><span>&lt;</span><span>Person</span><span>></span></span> list<span>=</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Person</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>@GetMapping</span><span>(</span><span>\"/heap\"</span><span>)</span>\n    <span>public</span> <span>String</span> <span>heap</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>{</span>\n        <span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>\n            list<span>.</span><span>add</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>\n<p>记得设置参数比如-Xmx20M -Xms20M</p>\n</blockquote>\n<h4 id=\"_4-1-2-运行结果\"> 4.1.2 运行结果</h4>\n<p>访问-&gt;http://localhost:8080/heap</p>\n<blockquote>\n<p>Exception in thread &quot;http-nio-8080-exec-2&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</p>\n</blockquote>\n<h3 id=\"_4-2-方法区内存溢出\"> 4.2 方法区内存溢出</h3>\n<blockquote>\n<p>比如向方法区中添加Class的信息</p>\n</blockquote>\n<h4 id=\"_4-2-1-asm依赖和class代码\"> 4.2.1 asm依赖和Class代码</h4>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n   <span><span><span>&lt;</span>groupId</span><span>></span></span>asm<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n   <span><span><span>&lt;</span>artifactId</span><span>></span></span>asm<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n   <span><span><span>&lt;</span>version</span><span>></span></span>3.3.1<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>MetaspaceUtil</span> <span>extends</span> <span>ClassLoader</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>List</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> <span>createClasses</span><span>(</span><span>)</span> <span>{</span>\n        <span>List</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> classes <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10000000</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n            <span>ClassWriter</span> cw <span>=</span> <span>new</span> <span>ClassWriter</span><span>(</span><span>0</span><span>)</span><span>;</span>\n            cw<span>.</span><span>visit</span><span>(</span><span>Opcodes</span><span>.</span>V1_1<span>,</span> <span>Opcodes</span><span>.</span>ACC_PUBLIC<span>,</span> <span>\"Class\"</span> <span>+</span> i<span>,</span> <span>null</span><span>,</span>\n                    <span>\"java/lang/Object\"</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n            <span>MethodVisitor</span> mw <span>=</span> cw<span>.</span><span>visitMethod</span><span>(</span><span>Opcodes</span><span>.</span>ACC_PUBLIC<span>,</span> <span>\"&lt;init>\"</span><span>,</span>\n                    <span>\"()V\"</span><span>,</span> <span>null</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n            mw<span>.</span><span>visitVarInsn</span><span>(</span><span>Opcodes</span><span>.</span>ALOAD<span>,</span> <span>0</span><span>)</span><span>;</span>\n            mw<span>.</span><span>visitMethodInsn</span><span>(</span><span>Opcodes</span><span>.</span>INVOKESPECIAL<span>,</span> <span>\"java/lang/Object\"</span><span>,</span>\n                    <span>\"&lt;init>\"</span><span>,</span> <span>\"()V\"</span><span>)</span><span>;</span>\n            mw<span>.</span><span>visitInsn</span><span>(</span><span>Opcodes</span><span>.</span>RETURN<span>)</span><span>;</span>\n            mw<span>.</span><span>visitMaxs</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span>\n            mw<span>.</span><span>visitEnd</span><span>(</span><span>)</span><span>;</span>\n            <span>MetaspaceUtil</span> test <span>=</span> <span>new</span> <span>MetaspaceUtil</span><span>(</span><span>)</span><span>;</span>\n            <span>byte</span><span>[</span><span>]</span> code <span>=</span> cw<span>.</span><span>toByteArray</span><span>(</span><span>)</span><span>;</span>\n            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> exampleClass <span>=</span> test<span>.</span><span>defineClass</span><span>(</span><span>\"Class\"</span> <span>+</span> i<span>,</span> code<span>,</span> <span>0</span><span>,</span> code<span>.</span>length<span>)</span><span>;</span>\n            classes<span>.</span><span>add</span><span>(</span>exampleClass<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> classes<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h4 id=\"_4-2-2-代码\"> 4.2.2 代码</h4>\n<div><pre><code><span>@RestController</span>\n<span>public</span> <span>class</span> <span>NonHeapController</span> <span>{</span>\n    <span>List</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> list<span>=</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>@GetMapping</span><span>(</span><span>\"/nonheap\"</span><span>)</span>\n    <span>public</span> <span>String</span> <span>heap</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>{</span>\n        <span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>\n            list<span>.</span><span>addAll</span><span>(</span><span>MetaspaceUtil</span><span>.</span><span>createClasses</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id=\"_4-2-3-运行结果\"> 4.2.3 运行结果</h4>\n<blockquote>\n<p>访问-&gt;http://localhost:8080/nonheap</p>\n</blockquote>\n<div><pre><code>java.lang.OutOfMemoryError: Metaspace\nat java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_191]\nat java.lang.ClassLoader.defineClass(ClassLoader.java:763) ~[na:1.8.0_191]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_4-3-虚拟机栈\"> 4.3 虚拟机栈</h3>\n<h4 id=\"_4-3-1-代码演示stackoverflow\"> 4.3.1 代码演示StackOverFlow</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>StackOverFlowDemo</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>long</span> count<span>=</span><span>0</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>method</span><span>(</span><span>long</span> i<span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>count<span>++</span><span>)</span><span>;</span>\n        <span>method</span><span>(</span>i<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>method</span><span>(</span><span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id=\"_4-3-2-运行结果\"> 4.3.2 运行结果</h4>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310000555900.png\" alt=\"image-20220310000555900\" /></p>\n<h4 id=\"_4-3-3-理解和说明\"> 4.3.3 理解和说明</h4>\n<div><pre><code>Stack Space用来做方法的递归调用时压入Stack Frame(栈帧)。所以当递归调用太深的时候，就有可能耗尽StackSpace，爆出StackOverflow的错误。\n\n-Xss128k：设置每个线程的堆栈大小。JDK 5以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。\n\n线程栈的大小是个双刃剑，如果设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢出的可能性更大，如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的错误。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309223600414.png",
      "date_published": "2022-05-05T10:22:38.000Z",
      "date_modified": "2022-07-02T17:06:40.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM升华-JVM垃圾回收算法以及垃圾回收器",
      "url": "https://www.moremind.cn/md/java/jvm/JVM-3/",
      "id": "https://www.moremind.cn/md/java/jvm/JVM-3/",
      "content_html": "<h2 id=\"_1-garbage-collect-垃圾回收\"> 1 Garbage Collect(垃圾回收)</h2>\n<p>GC Root:虚拟机栈中的本地变量、static成员、常量引用、本地方法栈[Thread C]中的变量</p>\n<p>类加载器：如果它找到一条路线，能到到达某个对象，也不能称为垃圾。</p>\n<p>Thread:Java进程(线程)</p>\n<h3 id=\"_1-1-如何确定一个对象是垃圾\"> 1.1 如何确定一个对象是垃圾？</h3>\n<h4 id=\"_1-1-1-引用计数法\"> 1.1.1 引用计数法</h4>\n<p>对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任 何指针对其 引用，它就是垃圾。</p>\n<blockquote>\n<p>弊端 :如果AB相互持有引用，导致永远不能被回收。</p>\n</blockquote>\n<h4 id=\"_1-1-2-可达性分析\"> 1.1.2 可达性分析</h4>\n<p>通过GC Root的对象，开始向下寻找，看某个对象是否可达</p>\n<blockquote>\n<p>能作为GC Root:类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法 栈的变量等。</p>\n</blockquote>\n<h3 id=\"_1-2-垃圾收集算法\"> 1.2 垃圾收集算法</h3>\n<h4 id=\"_1-2-1-标记-清除-mark-sweep\"> 1.2.1 标记-清除(Mark-Sweep)</h4>\n<ul>\n<li>标记</li>\n</ul>\n<p>找出内存中需要回收的对象，并且把它们标记出来</p>\n<blockquote>\n<p>此时堆中所有的对象都会被扫描一遍，从而才能确定需要回收的对象，比较耗时</p>\n</blockquote>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004158070.png\" alt=\"image-20220310004158070\" /></p>\n<ul>\n<li>清除</li>\n</ul>\n<p>清除掉被标记需要回收的对象，释放出对应的内存空间</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004225334.png\" alt=\"image-20220310004225334\" /></p>\n<p>缺点：</p>\n<div><pre><code>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n(1)标记和清除两个过程都比较耗时，效率不高\n(2)会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"_1-2-2-复制-copying\"> 1.2.2 复制(Copying)</h4>\n<p>将内存划分为两块相等的区域，每次只使用其中一块，如下图所示：</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/jvm-copy-alg.jpg\" alt=\"\" /></p>\n<p>当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存空间一次 清除掉。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004442121.png\" alt=\"image-20220310004442121\" /></p>\n<p>缺点: 空间利用率降低。</p>\n<h4 id=\"_1-2-3-标记-整理-mark-compact\"> 1.2.3 标记-整理(Mark-Compact)</h4>\n<p>标记过程仍然与&quot;标记-清除&quot;算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活 的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004604646.png\" alt=\"image-20220310004604646\" /></p>\n<p>让所有存活的对象都向一端移动，清理掉边界意外的内存。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Mark-Compact-alg.jpg\" alt=\"\" /></p>\n<h3 id=\"_1-3-分代收集算法\"> 1.3 分代收集算法</h3>\n<p><strong>Young区：复制算法</strong>(对象在被分配之后，可能生命周期比较短，Young区复制效率比较高)</p>\n<p><strong>Old区：标记清除或标记整理</strong>(Old区对象存活时间比较长，复制来复制去没必要，不如做个标记再清理)</p>\n<h3 id=\"_1-4-垃圾收集器\"> 1.4 垃圾收集器</h3>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004914409.png\" alt=\"image-20220310004914409\" /></p>\n<h4 id=\"_1-4-1-serial收集器\"> 1.4.1 Serial收集器</h4>\n<p>Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯 一选择。</p>\n<p>它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更 重要的是其在进行垃圾收集的时候需要暂停其他线程。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310204357425.png\" alt=\"image-20220310204357425\" /></p>\n<h4 id=\"_1-4-2-parnew收集器\"> 1.4.2 ParNew收集器</h4>\n<div><pre><code>优点：在多CPU时，比Serial效率高。\n缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。\n算法：复制算法\n适用范围：新生代\n应用：运行在Server模式下的虚拟机中首选的新生代收集器\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/ParNew-gc.jpg\" alt=\"\" /></p>\n<h4 id=\"_1-4-3-parallel-scavenge收集器\"> 1.4.3 Parallel Scavenge收集器</h4>\n<p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集 器，看上去和ParNew一样，但是<strong>Parallel Scanvenge更关注系统的吞吐量 。</strong></p>\n<div><pre><code>吞吐量=运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)\n比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=(100-1)/100=99%。\n若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code>-XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间，\n-XX:GCTimeRatio直接设置吞吐量的大小。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_1-4-4-serial-old收集器\"> 1.4.4 Serial Old收集器</h4>\n<p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是<strong>采用&quot;标记-整理算 法&quot;</strong>，运行过程和Serial收集器一样。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310205235758.png\" alt=\"image-20220310205235758\" /></p>\n<h4 id=\"_1-4-5-parallel-old收集器\"> 1.4.5 Parallel Old收集器</h4>\n<p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，<strong>使用多线程和&quot;标记-整理算法&quot;进行垃圾 回收。</strong></p>\n<h4 id=\"_1-4-6-cms收集器\"> 1.4.6 CMS收集器</h4>\n<p><strong>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间 为目标的收集器。</strong></p>\n<p>采用的是&quot;标记-清除算法&quot;,整个过程分为4步</p>\n<div><pre><code>(1)初始标记 CMS initial mark \t\t标记GC Roots能关联到的对象 Stop The World---&gt;速度很快\n(2)并发标记 CMS concurrent mark \t进行GC Roots Tracing\n(3)重新标记 CMS remark \t\t\t\t修改并发标记因用户程序变动的内容 Stop The World\n4)并发清除 CMS concurrent sweep\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<p>由于整个过程中，并发标记和并发清除，收集器线程可以与用户线程一起工作，所以总体上来 说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。</p>\n</blockquote>\n<div><pre><code>优点：并发收集、低停顿\n缺点：产生大量空间碎片、并发阶段会降低吞吐量\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310210434471.png\" alt=\"image-20220310210434471\" /></p>\n<h4 id=\"_1-4-7-g1收集器\"> 1.4.7 G1收集器</h4>\n<ul>\n<li>G1特点:</li>\n</ul>\n<div><pre><code>并行与并发\n分代收集（仍然保留了分代的概念）\n空间整合（整体上属于“标记-整理”算法，不会导致空间碎片）\n可预测的停顿（比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>使用G1收集器时，Java堆的内存布局与就与其他收集器有很大差别，它将整个Java堆划分为多个 大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再 是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>\n<ul>\n<li>工作过程分为以下几个阶段：</li>\n</ul>\n<div><pre><code>初始标记（Initial Marking） 标记一下GC Roots能够关联的对象，并且修改TAMS的值，需要暂停用户线程\n并发标记（Concurrent Marking） 从GC Roots进行可达性分析，找出存活的对象，与用户线程并发执行\n最终标记（Final Marking） 修正在并发标记阶段因为用户程序的并发执行导致变动的数据，需暂停用户线程\n筛选回收（Live Data Counting and Evacuation） 对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/G1-gc.jpg\" alt=\"\" /></p>\n<ul>\n<li>判断是否需要使用G1收集器？</li>\n</ul>\n<div><pre><code>（1）50%以上的堆被存活对象占用\n（2）对象分配和晋升的速度变化非常大\n（3）垃圾回收时间比较长\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"_1-4-8-垃圾收集器分类\"> 1.4.8 垃圾收集器分类</h4>\n<ul>\n<li>串行收集器-&gt;Serial和Serial Old</li>\n</ul>\n<p>只能有一个垃圾回收线程执行，用户线程暂停。 适用于内存比较小的嵌入式设备 。</p>\n<ul>\n<li>并行收集器[吞吐量优先]-&gt;Parallel Scanvenge、Parallel Old</li>\n</ul>\n<p>多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 适用于科学计算、后台处理等若交互场 景 。</p>\n<ul>\n<li>并发收集器[停顿时间优先]-&gt;CMS、G1</li>\n</ul>\n<p>用户线程和垃圾收集线程同时执行(但并不一定是并行的，可能是交替执行的)，垃圾收集线程在执行的 时候不会停顿用户线程的运行。 适用于相对时间有要求的场景，比如Web 。</p>\n<h4 id=\"_1-4-9-理解吞吐量和停顿时间\"> 1.4.9 理解吞吐量和停顿时间</h4>\n<ul>\n<li>停顿时间-&gt;垃圾收集器 进行 垃圾回收终端应用执行响应的时间</li>\n<li>吞吐量-&gt;运行用户代码时间/(运行用户代码时间+垃圾收集时间)</li>\n</ul>\n<div><pre><code>停顿时间越短就越适合需要和用户交互的程序，良好的响应速度能提升用户体验；\n高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_1-4-10-如何选择合适的垃圾收集器\"> 1.4.10 如何选择合适的垃圾收集器</h4>\n<p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28\" target=\"_blank\" rel=\"noopener noreferrer\">Available Collectors (oracle.com)</a></p>\n<ul>\n<li>优先调整堆的大小让服务器自己来选择</li>\n<li>如果内存小于100M，使用串行收集器</li>\n<li>如果是单核，并且没有停顿时间要求，使用串行或JVM自己选</li>\n<li>如果允许停顿时间超过1秒，选择并行或JVM自己选</li>\n<li>如果响应时间最重要，并且不能超过1秒，使用并发收集器 G1收集</li>\n</ul>\n<h4 id=\"_1-4-11-如何开启需要的垃圾收集器\"> 1.4.11 如何开启需要的垃圾收集器</h4>\n<div><pre><code>（1）串行\n    -XX：+UseSerialGC\n    -XX：+UseSerialOldGC\n（2）并行(吞吐量优先)：\n    -XX：+UseParallelGC\n    -XX：+UseParallelOldGC\n（3）并发收集器(响应时间优先)\n    -XX：+UseConcMarkSweepGC\n    -XX：+UseG1GC\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004158070.png",
      "date_published": "2022-05-05T10:22:38.000Z",
      "date_modified": "2022-11-06T15:58:04.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM实战-JVM性能分析以及调优分析",
      "url": "https://www.moremind.cn/md/java/jvm/JVM-4/",
      "id": "https://www.moremind.cn/md/java/jvm/JVM-4/",
      "content_html": "<h1 id=\"_1-jvm实战篇\"> 1 JVM实战篇</h1>\n<h2 id=\"_1-1-jvm参数\"> 1.1 JVM参数</h2>\n<h4 id=\"_1-1-1-标准参数\"> 1.1.1 标准参数</h4>\n<div><pre><code>-version\n-help\n-server\n-cp\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"_1-1-2-x参数\"> 1.1.2 -X参数</h4>\n<div><pre><code>-Xint 解释执行\n-Xcomp 第一次使用就编译成本地代码\n-Xmixed 混合模式，JVM自己来决定\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"_1-1-3-xx参数\"> 1.1.3 -XX参数</h4>\n<blockquote>\n<p>使用得最多的参数类型 非标准化参数，相对不稳定，主要用于JVM调优和Debug</p>\n</blockquote>\n<div><pre><code>a.Boolean类型\n格式：-XX:[+-]&lt;name&gt; +或-表示启用或者禁用name属性\n比如：-XX:+UseConcMarkSweepGC 表示启用CMS类型的垃圾回收器\n\t -XX:+UseG1GC 表示启用G1类型的垃圾回收器\n\n** b.非Boolean类型\n格式：-XX&lt;name&gt;=&lt;value&gt;表示name属性的值是value\n比如：-XX:MaxGCPauseMillis=500\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id=\"_1-1-4-其他参数\"> 1.1.4 其他参数</h4>\n<div><pre><code>-Xms1000等价于-XX:InitialHeapSize=1000\n-Xmx1000等价于-XX:MaxHeapSize=1000\n-Xss100等价于-XX:ThreadStackSize=100\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"_1-1-5-查看参数\"> 1.1.5 查看参数</h4>\n<blockquote>\n<p><strong>java -XX:+PrintFlagsFinal -version &gt; flags.txt</strong></p>\n</blockquote>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310215001216.png\" alt=\"\" /></p>\n<h4 id=\"_1-1-6-设置参数的方式\"> 1.1.6 设置参数的方式</h4>\n<ul>\n<li>\n<p>开发工具中设置比如IDEA，eclipse</p>\n</li>\n<li>\n<p>运行jar包的时候:java -XX:+UseG1GC xxx.jar</p>\n</li>\n<li>\n<p>web容器比如tomcat，可以在脚本中的进行设置</p>\n</li>\n<li>\n<p><strong>通过jinfo实时调整某个java进程的参数(参数只有被标记为manageable的flags可以被实时修改)</strong></p>\n</li>\n</ul>\n<h4 id=\"_1-1-7-实践和单位换算\"> 1.1.7 实践和单位换算</h4>\n<div><pre><code>1Byte(字节)=8bit(位)\n1KB=1024Byte(字节)\n1MB=1024KB\n1GB=1024MB\n1TB=1024GB\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>(1)设置堆内存大小和参数打印\n\t-Xmx100M -Xms100M -XX:+PrintFlagsFinal\n(2)查询+PrintFlagsFinal的值\n\t:=true\n(3)查询堆内存大小MaxHeapSize\n\t:= 104857600\n(4)换算\n104857600(Byte)/1024=102400(KB)\n102400(KB)/1024=100(MB)\n(5)结论\n\t104857600是字节单位\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id=\"_1-1-8-常用参数含义\"> 1.1.8 常用参数含义</h4>\n<p>JVM参数说明：<a href=\"https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html\" target=\"_blank\" rel=\"noopener noreferrer\">JVM参数</a></p>\n<ul>\n<li>调优堆栈内存-堆栈大小典型配置参数</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">配置参数</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-Xmx</code></td>\n<td style=\"text-align:left\">设置最大堆大小。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m</code>，设置JVM最大可用内存为3550 MB。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-Xms</code></td>\n<td style=\"text-align:left\">设置JVM初始内存。</td>\n<td style=\"text-align:left\"><code>-Xms3550m</code>，设置JVM初始内存为3550 MB。此值建议与<code>-Xmx</code>相同，避免每次垃圾回收完成后JVM重新分配内存。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-Xmn</code></td>\n<td style=\"text-align:left\">设置年轻代大小。</td>\n<td style=\"text-align:left\"><code>-Xmn2g</code>，设置年轻代大小为2 GB。整个JVM内存大小=年轻代大小+年老代大小+持久代大小。持久代一般固定大小为64 MB，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-Xss</code></td>\n<td style=\"text-align:left\">设置线程的栈大小。</td>\n<td style=\"text-align:left\"><code>-Xss128k</code>，设置每个线程的栈大小为128 KB。<strong>说明</strong> JDK 5.0版本以后每个线程栈大小为1 MB，JDK 5.0以前版本每个线程栈大小为256 KB。请依据应用的线程所需内存大小进行调整。在相同物理内存下，减小该值可以生成更多的线程。但是操作系统对一个进程内的线程个数有一定的限制，无法无限生成，一般在3000个~5000个。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:NewRatio=n</code></td>\n<td style=\"text-align:left\">设置年轻代和年老代的比值。</td>\n<td style=\"text-align:left\"><code>-XX:NewRatio=4</code>，设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。如果设置为4，那么年轻代与年老代所占比值为1:4，年轻代占整个堆栈的1/5。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:SurvivorRatio=n</code></td>\n<td style=\"text-align:left\">年轻代中Eden区与两个Survivor区的比值。</td>\n<td style=\"text-align:left\"><code>-XX:SurvivorRatio=4</code>，设置年轻代中Eden区与Survivor区的大小比值。如果设置为4，那么两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:MaxPermSize=n</code></td>\n<td style=\"text-align:left\">设置持久代大小。</td>\n<td style=\"text-align:left\"><code>-XX:MaxPermSize=16m</code>，设置持久代大小为16 MB。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:MaxTenuringThreshold=n</code></td>\n<td style=\"text-align:left\">设置垃圾最大年龄。</td>\n<td style=\"text-align:left\"><code>-XX:MaxTenuringThreshold=0</code>，设置垃圾最大年龄。如果设置为0，那么年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，提高了效率。如果将此值设置为较大值，那么年轻代对象会在Survivor区进行多次复制，增加了对象在年轻代的存活时间，增加在年轻代即被回收的概率。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>调优回收器GC-吞吐量优先的GC典型配置参数</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">配置参数</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+UseParallelGC</code></td>\n<td style=\"text-align:left\">选择垃圾收集器为并行收集器。</td>\n<td style=\"text-align:left\"><code>-Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</code>，<code>-XX:+UseParallelGC</code>此配置仅对年轻代有效，即在示例配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:ParallelGCThreads</code></td>\n<td style=\"text-align:left\">配置并行收集器的线程数，即同时多少个线程一起进行垃圾回收。<strong>说明</strong> 此值建议配置与处理器数目相等。</td>\n<td style=\"text-align:left\"><code>-Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</code>，<code>-XX:ParallelGCThreads=20</code>表示配置并行收集器的线程数为20个。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+UseParallelOldGC</code></td>\n<td style=\"text-align:left\">配置年老代垃圾收集方式为并行收集。<strong>说明</strong> JDK 6.0支持对年老代并行收集。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC</code>，<code>-XX:+UseParallelOldGC</code>表示对年老代进行并行收集。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:MaxGCPauseMillis</code></td>\n<td style=\"text-align:left\">设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100</code>，<code>-XX:MaxGCPauseMillis=100</code>设置每次年轻代垃圾回收的最长时间为100 ms。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+UseAdaptiveSizePolicy</code></td>\n<td style=\"text-align:left\">设置此选项后，并行收集器自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时该间或者收集频率，该值建议使用并行收集器时，并且一直打开。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAda</code></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>响应时间优先的GC典型配置参数</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">配置参数</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+UseConcMarkSweepGC</code></td>\n<td style=\"text-align:left\">设置年老代为并发收集。<strong>说明</strong> 配置了<code>-XX:+UseConcMarkSweepGC</code>，建议年轻代大小使用<code>-Xmn</code>设置。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+UseParNewGC</code></td>\n<td style=\"text-align:left\">设置年轻代为并行收集。可与CMS收集同时使用。JDK 5.0以上版本，JVM根据系统配置自行设置，无需再设置此值。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:CMSFullGCsBeforeCompaction</code></td>\n<td style=\"text-align:left\">由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</code>，<code>-XX:CMSFullGCsBeforeCompaction=5</code>，表示运行GC5次后对内存空间进行压缩、整理。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+UseCMSCompactAtFullCollection</code></td>\n<td style=\"text-align:left\">打开对年老代的压缩。<strong>说明</strong> 该值可能会影响性能，但是可以消除碎片。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</code></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>用于辅助的GC典型配置参数</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">配置参数</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+PrintGC</code></td>\n<td style=\"text-align:left\">用于输出GC日志。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+PrintGCDetails</code></td>\n<td style=\"text-align:left\">用于输出GC日志。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+PrintGCTimeStamps</code></td>\n<td style=\"text-align:left\">用于输出GC时间戳（JVM启动到当前日期的总时长的时间戳形式）。示例如下：<code>0.855: [GC (Allocation Failure) [PSYoungGen: 33280K-&gt;5118K(38400K)] 33280K-&gt;5663K(125952K), 0.0067629 secs] [Times: user=0.01 sys=0.01, real=0.00 secs]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+PrintGCDateStamps</code></td>\n<td style=\"text-align:left\">用于输出GC时间戳（日期形式）。示例如下：<code>2022-01-27T16:22:20.885+0800: 0.299: [GC pause (G1 Evacuation Pause) (young), 0.0036685 secs]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+PrintHeapAtGC</code></td>\n<td style=\"text-align:left\">在进行GC前后打印出堆的信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-Xloggc:../logs/gc.log</code></td>\n<td style=\"text-align:left\">日志文件的输出路径。</td>\n</tr>\n</tbody>\n</table>\n<p>全部参数查看：https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html\n<img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309162923416.png\" alt=\"image-20220309162923416\" /></p>\n<h2 id=\"_1-2-常用命令\"> 1.2 常用命令</h2>\n<h3 id=\"_1-2-1-jps\"> 1.2.1 jps</h3>\n<blockquote>\n<p>查看java进程</p>\n</blockquote>\n<h3 id=\"_1-2-2-jinfo\"> 1.2.2 jinfo</h3>\n<p>(1)实时查看和调整JVM配置参数</p>\n<p>(2)查看</p>\n<div><pre><code>jinfo -flag name PID 查看某个java进程的name属性的值\n</code></pre>\n<div><span>1</span><br></div></div><p>(3)修改</p>\n<blockquote>\n<p>参数只有被标记为manageable的flags可以被实时修改</p>\n<p>jinfo -flag [+|-] PID</p>\n<p>jinfo -flag = PID</p>\n</blockquote>\n<p>(4)查看曾经赋过值的一些参数</p>\n<div><pre><code>jinfo -flags PID\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_1-2-3-jstat\"> 1.2.3 jstat</h3>\n<p>(1)查看虚拟机性能统计信息</p>\n<p>(2)查看类装载信息</p>\n<div><pre><code>jstat -class PID 1000 10 查看某个java进程的类装载信息，每1000毫秒输出一次，共输出10次\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310220302064.png\" alt=\"image-20220310220302064\" /></p>\n<p>(3)查看垃圾收集信息</p>\n<div><pre><code>jstat -gc PID 1000 10\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310220241447.png\" alt=\"image-20220310220241447\" /></p>\n<h3 id=\"_1-2-4-jstack\"> 1.2.4 jstack</h3>\n<p>(1)查看线程堆栈信息</p>\n<p>(2)用法</p>\n<div><pre><code>jstack PID\n</code></pre>\n<div><span>1</span><br></div></div><p>(3) 排查死锁</p>\n<ul>\n<li>DeadLockDemo</li>\n</ul>\n<div><pre><code><span>//运行主类</span>\n<span>public</span> <span>class</span> <span>DeadLockDemo</span>\n<span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span>\n    <span>{</span>\n        <span>DeadLock</span> d1<span>=</span><span>new</span> <span>DeadLock</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>DeadLock</span> d2<span>=</span><span>new</span> <span>DeadLock</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>Thread</span> t1<span>=</span><span>new</span> <span>Thread</span><span>(</span>d1<span>)</span><span>;</span>\n        <span>Thread</span> t2<span>=</span><span>new</span> <span>Thread</span><span>(</span>d2<span>)</span><span>;</span>\n        t1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        t2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>//定义锁对象</span>\n<span>class</span> <span>MyLock</span><span>{</span>\n    <span>public</span> <span>static</span> <span>Object</span> obj1<span>=</span><span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n    <span>public</span> <span>static</span> <span>Object</span> obj2<span>=</span><span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>//死锁代码</span>\n<span>class</span> <span>DeadLock</span> <span>implements</span> <span>Runnable</span><span>{</span>\n    <span>private</span> <span>boolean</span> flag<span>;</span>\n    <span>DeadLock</span><span>(</span><span>boolean</span> flag<span>)</span><span>{</span>\n        <span>this</span><span>.</span>flag<span>=</span>flag<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span><span>(</span>flag<span>)</span> <span>{</span>\n            <span>while</span><span>(</span><span>true</span><span>)</span> <span>{</span>\n                <span>synchronized</span><span>(</span><span>MyLock</span><span>.</span>obj1<span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"----if获得obj1锁\"</span><span>)</span><span>;</span>\n                    <span>synchronized</span><span>(</span><span>MyLock</span><span>.</span>obj2<span>)</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"----if获得obj2锁\"</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>else</span> <span>{</span>\n            <span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>\n                <span>synchronized</span><span>(</span><span>MyLock</span><span>.</span>obj2<span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"----否则获得obj2锁\"</span><span>)</span><span>;</span>\n                    <span>synchronized</span><span>(</span><span>MyLock</span><span>.</span>obj1<span>)</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"----否则获得obj1锁\"</span><span>)</span><span>;</span>\n\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><ul>\n<li>jstack 分析</li>\n</ul>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310220950543.png\" alt=\"\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310221042830.png\" alt=\"image-20220310221042830\" /></p>\n<h3 id=\"_1-2-5-jmap\"> 1.2.5 jmap</h3>\n<p>(1)生成堆转储快照</p>\n<p>(2)打印出堆内存相关信息</p>\n<div><pre><code>1.设置：-XX:+PrintFlagsFinal -Xms300M -Xmx300M\n2.查看jmap -heap PID\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310221505262.png\" alt=\"image-20220310221505262\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310221521362.png\" alt=\"image-20220310221521362\" /></p>\n<p>(3)dump出堆内存相关信息、</p>\n<div><pre><code>jmap -dump:format=b,file=heap.hprof PID\njmap -dump:format=b,file=heap.hprof 44808\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310221914338.png\" alt=\"image-20220310221914338\" /></p>\n<p>(4)要是在发生堆内存溢出的时候，能自动dump出该文件就好了</p>\n<blockquote>\n<p>一般在开发中，JVM参数可以加上下面两句，这样内存溢出时，会自动dump出该文件</p>\n</blockquote>\n<div><pre><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>设置堆内存大小: -Xms20M -Xmx20M\n启动，然后访问localhost:9090/heap，使得堆内存溢出\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>(5)关于dump下来的文件</p>\n<p>一般dump下来的文件可以结合工具来分析</p>\n<h2 id=\"_1-3-常用工具\"> 1.3 常用工具</h2>\n<h3 id=\"_1-3-1-jconsole\"> 1.3.1 jconsole</h3>\n<p>JConsole工具是JDK自带的可视化监控工具。查看java应用程序的运行概况、监控堆信息、永久区使用 情况、类加载情况等。</p>\n<blockquote>\n<p>启动命令：jconsole</p>\n</blockquote>\n<h3 id=\"_1-3-2-jvisualvm\"> 1.3.2 jvisualvm</h3>\n<blockquote>\n<p>启动命令：jvisualvm</p>\n</blockquote>\n<h4 id=\"_1-3-2-1-监控本地java进程\"> 1.3.2.1 监控本地Java进程</h4>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310222954259.png\" alt=\"image-20220310222954259\" /></p>\n<h4 id=\"_1-3-2-2-监控远端java进程\"> 1.3.2.2 监控远端Java进程</h4>\n<blockquote>\n<p>比如监控远端tomcat，演示部署在阿里云服务器上的tomcat</p>\n</blockquote>\n<p>(1)在visualvm中选中“远程”，右击“添加”</p>\n<p>(2)主机名上写服务器的ip地址，比如31.100.39.63，然后点击“确定”</p>\n<p>(3)右击该主机“31.100.39.63”，添加“JMX”[也就是通过JMX技术具体监控远端服务器哪个Java进程]</p>\n<p>(4)要想让服务器上的tomcat被连接，需要改一下 bin/catalina.sh 这个文件</p>\n<div><pre><code><span>JAVA_OPTS</span><span>=</span><span>\"<span>$JAVA_OPTS</span> -Dcom.sun.management.jmxremote -\nDjava.rmi.server.hostname=31.100.39.63 -Dcom.sun.management.jmxremote.port=8998\n-Dcom.sun.management.jmxremote.ssl=false -\nDcom.sun.management.jmxremote.authenticate=true -\nDcom.sun.management.jmxremote.access.file=../conf/jmxremote.access -\nDcom.sun.management.jmxremote.password.file=../conf/jmxremote.password\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>(5)在 ../conf 文件中添加两个文件jmxremote.access和jmxremote.password</p>\n<blockquote>\n<p>jmxremote.access 文件</p>\n<div><pre><code>guest readonly\nmanager readwrite\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></blockquote>\n<blockquote>\n<p>jmxremote.password 文件</p>\n<div><pre><code>guest guest\nmanager manager\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></blockquote>\n<p>授予权限 : chmod 600 * jmxremot *</p>\n<p>(6)将连接服务器地址改为公网ip地址</p>\n<div><pre><code>hostname -i 查看输出情况\n172.26.225.240 172.17.0.1\nvim /etc/hosts\n172.26.255.240 31.100.39.63\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>(7)设置上述端口对应的阿里云安全策略和防火墙策略</p>\n<p>(8)启动tomcat，来到bin目录</p>\n<div><pre><code>./startup.sh\t\n</code></pre>\n<div><span>1</span><br></div></div><p>(9)查看tomcat启动日志以及端口监听</p>\n<div><pre><code><span>tail</span> -f <span>..</span>/logs/catalina.out\n<span>lsof</span> -i tcp:8080\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>(10)查看8998监听情况，可以发现多开了几个端口</p>\n<div><pre><code>lsof -i:8998 得到PID\nnetstat -antup | grep PID\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>(11)在刚才的JMX中输入8998端口，并且输入用户名和密码则登录成功</p>\n<div><pre><code>端口:8998\n用户名:manager\n密码:manager\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_1-3-3-arthas\"> 1.3.3 Arthas</h3>\n<blockquote>\n<p>github ：https://github.com/alibaba/arthas</p>\n</blockquote>\n<blockquote>\n<p>Arthas 是Alibaba开源的Java诊断工具，采用命令行交互模式，是排查jvm相关问题的利器。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310224532713.png\" alt=\"\" /></p>\n</blockquote>\n<h4 id=\"_1-3-3-1-下载安装\"> 1.3.3.1 下载安装</h4>\n<div><pre><code>curl -O https://alibaba.github.io/arthas/arthas-boot.jar\njava -jar arthas-boot.jar\n# 然后可以选择一个Java进程\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Print usage</p>\n<div><pre><code>java -jar arthas-boot.jar -h\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_1-3-3-2-常用命令\"> 1.3.3.2 常用命令</h4>\n<div><pre><code>version:查看arthas版本号\nhelp:查看命名帮助信息\ncls:清空屏幕\nsession:查看当前会话信息\nquit:退出arthas客户端\n---\ndashboard:当前进程的实时数据面板\nthread:当前JVM的线程堆栈信息\njvm:查看当前JVM的信息\nsysprop:查看JVM的系统属性\n---\nsc:查看JVM已经加载的类信息\ndump:dump已经加载类的byte code到特定目录\njad:反编译指定已加载类的源码\n---\nmonitor:方法执行监控\nwatch:方法执行数据观测\ntrace:方法内部调用路径，并输出方法路径上的每个节点上耗时\nstack:输出当前方法被调用的调用路径\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"_1-3-4-mat\"> 1.3.4 MAT</h3>\n<blockquote>\n<p>Java堆分析器，用于查找内存泄漏\nHeap Dump，称为堆转储文件，是Java进程在某个时间内的快照\n下载地址 ：https://www.eclipse.org/mat/downloads.php</p>\n</blockquote>\n<h4 id=\"_1-3-4-1-dump信息包含的内容\"> 1.3.4.1 Dump信息包含的内容</h4>\n<ul>\n<li>All Objects</li>\n</ul>\n<p>Class, fields, primitive values and references</p>\n<ul>\n<li>All Classes</li>\n</ul>\n<p>Classloader, name, super class, static fields</p>\n<ul>\n<li>Garbage Collection Roots</li>\n</ul>\n<p>Objects defined to be reachable by the JVM</p>\n<ul>\n<li>Thread Stacks and Local Variables</li>\n</ul>\n<p>The call-stacks of threads at the moment of the snapshot, and per-frame information about local objects</p>\n<h4 id=\"_1-3-4-2-获取dump文件\"> 1.3.4.2 获取Dump文件</h4>\n<ul>\n<li>手动</li>\n</ul>\n<div><pre><code>jmap -dump:format=b,file=heap.hprof 44808\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>自动</li>\n</ul>\n<div><pre><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_1-3-4-3-使用\"> 1.3.4.3 使用</h4>\n<ul>\n<li>Histogram</li>\n</ul>\n<blockquote>\n<p>Histogram可以列出内存中的对象，对象的个数及其大小</p>\n</blockquote>\n<div><pre><code>Class Name:类名称，java类名\nObjects:类的对象的数量，这个对象被创建了多少个\nShallow Heap:一个对象内存的消耗大小，不包含对其他对象的引用\nRetained Heap:是shallow Heap的总和，即该对象被GC之后所能回收到内存的总和\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code>右击类名---&gt;List Objects---&gt;with incoming references---&gt;列出该类的实例\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>右击Java对象名---&gt;Merge Shortest Paths to GC Roots---&gt;exclude all ...---&gt;找到GC Root以及原因\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>Leak Suspects</li>\n</ul>\n<blockquote>\n<p>查找并分析内存泄漏的可能原因</p>\n</blockquote>\n<div><pre><code>Reports---&gt;Leak Suspects---&gt;Details\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>Top Consumers</li>\n</ul>\n<blockquote>\n<p>Top Consumers</p>\n</blockquote>\n<h3 id=\"_1-3-5-gc日志分析工具\"> 1.3.5 GC日志分析工具</h3>\n<div><pre><code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps\n-Xloggc:gc.log\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ul>\n<li>\n<p>在线 http://gceasy.io</p>\n</li>\n<li>\n<p><strong>GCViewer</strong></p>\n</li>\n</ul>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310215001216.png",
      "date_published": "2022-05-05T10:22:38.000Z",
      "date_modified": "2022-11-08T14:23:02.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM终篇-JVM分析",
      "url": "https://www.moremind.cn/md/java/jvm/JVM-5/",
      "id": "https://www.moremind.cn/md/java/jvm/JVM-5/",
      "content_html": "<h1 id=\"_1-jvm终结篇\"> 1 JVM终结篇</h1>\n<h2 id=\"_1-1-重新认知jvm\"> 1.1 重新认知JVM</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232017105.png\" alt=\"image-20220310232017105\" /></p>\n<h2 id=\"_1-2-gc优化\"> 1.2 GC优化</h2>\n<blockquote>\n<p>内存被使用了之后，难免会有不够用或者达到设定值的时候，就需要对内存空间进行垃圾回收。</p>\n</blockquote>\n<h3 id=\"_1-2-1-垃圾收集发生的时机\"> 1.2.1 垃圾收集发生的时机</h3>\n<blockquote>\n<p>GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。 当然，我们可以手动进行垃圾回收， 比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是说 System.gc()只是通知要回收，什么时候回收由JVM决定。 但是不建议手动调用该方法，因为消耗的资源比较 大。</p>\n</blockquote>\n<p>一般以下几种情况会发生垃圾回收:</p>\n<div><pre><code>（1）当Eden区或者S区不够用了\n（2）老年代空间不够用了\n（3）方法区空间不够用了\n（4）System.gc()\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_1-2-2-实验环境准备\"> 1.2.2 实验环境准备</h3>\n<h3 id=\"_1-2-3-gc日志文件\"> 1.2.3 GC日志文件</h3>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232235655.png\" alt=\"image-20220310232235655\" /></p>\n<blockquote>\n<p>要想分析日志的信息，得先拿到GC日志文件才行，所以得先配置一下，之前也看过这些参数。</p>\n</blockquote>\n<div><pre><code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps\n-Xloggc:gc.log\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>然后启动项目，可以看到默认使用的是ParallelGC</p>\n<h4 id=\"_1-2-3-1-parallel-gc日志\"> 1.2.3.1 Parallel GC日志</h4>\n<blockquote>\n<p>【吞吐量优先】</p>\n<div><pre><code>2019-06-10T23:21:53.305+0800: 1.303:\n[GC (Allocation Failure) [PSYoungGen: 65536K[Young区回收前]-&gt;10748K[Young区回收后]\n(76288K[Young区总大小])] 65536K[整个堆回收前]-&gt;15039K[整个堆回收后](251392K[整个堆总大小]),\n0.0113277 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意 如果回收的差值中间有出入，说明这部分空间是Old区释放出来的</p>\n</blockquote>\n<h4 id=\"_1-2-3-2-cms日志\"> 1.2.3.2 CMS日志</h4>\n<blockquote>\n<p>【停顿时间优先】</p>\n<p>参数设置：-XX:+UseConcMarkSweepGC -Xloggc:cms-gc.log</p>\n</blockquote>\n<h4 id=\"_1-2-3-3-g1日志\"> 1.2.3.3 G1日志</h4>\n<blockquote>\n<p>【停顿时间优先】</p>\n<p>参数设置：-XX:+UseG1GC -Xloggc:g1-gc.log</p>\n<p>理解G1日志格式：https://blogs.oracle.com/poonam/understanding-g1-gc-logs</p>\n<div><pre><code>-XX:+UseG1GC <span># 使用了G1垃圾收集器</span>\n<span># 什么时候发生的GC，相对的时间刻，GC发生的区域young，总共花费的时间，0.00478s，</span>\n<span># It is a stop-the-world activity and all</span>\n<span># the application threads are stopped at a safepoint during this time.</span>\n<span>2019</span>-12-18T16:06:46.508+0800: <span>0.458</span>: <span>[</span>GC pause <span>(</span>G1 Evacuation Pause<span>)</span> <span>(</span>young<span>)</span>,\n<span>0.0047804</span> secs<span>]</span>\n<span># 多少个垃圾回收线程，并行的时间</span>\n<span>[</span>Parallel Time: <span>3.0</span> ms, GC Workers: <span>4</span><span>]</span>\n<span># GC线程开始相对于上面的0.458的时间刻</span>\n<span>[</span>GC Worker Start <span>(</span>ms<span>)</span>: Min: <span>458.5</span>, Avg: <span>458.5</span>, Max: <span>458.5</span>, Diff: <span>0.0</span><span>]</span>\n<span># This gives us the time spent by each worker thread scanning the roots</span>\n<span># (globals, registers, thread stacks and VM data structures).</span>\n<span>[</span>Ext Root Scanning <span>(</span>ms<span>)</span>: Min: <span>0.2</span>, Avg: <span>0.4</span>, Max: <span>0.7</span>, Diff: <span>0.5</span>, Sum: <span>1.7</span><span>]</span>\n<span># Update RS gives us the time each thread spent in updating the Remembered Sets.</span>\n<span>[</span>Update RS <span>(</span>ms<span>)</span>: Min: <span>0.0</span>, Avg: <span>0.0</span>, Max: <span>0.0</span>, Diff: <span>0.0</span>, Sum: <span>0.0</span><span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></blockquote>\n<h3 id=\"_1-2-4-gc日志文件分析工具\"> 1.2.4 GC日志文件分析工具</h3>\n<h4 id=\"_1-2-4-1-gceasy\"> 1.2.4.1 gceasy</h4>\n<blockquote>\n<p>官网 ：https://gceasy.io</p>\n<p>可以比较不同的垃圾收集器的吞吐量和停顿时间</p>\n<p>比如打开cms-gc.log和g1-gc.log</p>\n</blockquote>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232816712.png\" alt=\"image-20220310232816712\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232830568.png\" alt=\"image-20220310232830568\" /></p>\n<h4 id=\"_1-2-4-2-gcviewer\"> 1.2.4.2 GCViewer</h4>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232844104.png\" alt=\"image-20220310232844104\" /></p>\n<h3 id=\"_1-2-5-g1调优与最佳指南\"> 1.2.5 G1调优与最佳指南</h3>\n<h4 id=\"_1-2-5-1-调优\"> 1.2.5.1 调优</h4>\n<blockquote>\n<p>是否选用G1垃圾收集器的判断依据</p>\n<p>https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html#use_cases</p>\n<div><pre><code>（1）50%以上的堆被存活对象占用\n（2）对象分配和晋升的速度变化非常大\n（3）垃圾回收时间比较长\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>思考 ：https://blogs.oracle.com/poonam/increased-heap-usage-with-g1-gc</p>\n</blockquote>\n<p>(1)使用G1GC垃圾收集器: -XX:+UseG1GC</p>\n<p>修改配置参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310233115552.png\" alt=\"image-20220310233115552\" /></p>\n<p>(2)调整内存大小再获取gc日志分析</p>\n<div><pre><code>-XX:MetaspaceSize=100M\n-Xms300M\n-Xmx300M\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>比如设置堆内存的大小，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310233227857.png\" alt=\"image-20220310233227857\" /></p>\n<p>(3)调整最大停顿时间</p>\n<div><pre><code>-XX:MaxGCPauseMillis=20 设置最大GC停顿时间指标\n</code></pre>\n<div><span>1</span><br></div></div><p>比如设置最大停顿时间，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310233319130.png\" alt=\"image-20220310233319130\" /></p>\n<p>(4)启动并发GC时堆内存占用百分比</p>\n<div><pre><code>-XX:InitiatingHeapOccupancyPercent=45 G1用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比例。值为 0 则表示“一直执行GC循环)&#39;. 默认值为 45 (例如, 全部的 45% 或者使用了45%).\n</code></pre>\n<div><span>1</span><br></div></div><p>比如设置该百分比参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310233428017.png\" alt=\"image-20220310233428017\" /></p>\n<h4 id=\"_1-2-5-2-最佳指南\"> 1.2.5.2 最佳指南</h4>\n<blockquote>\n<p>官网建议 ：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations</p>\n</blockquote>\n<p><strong>(1)不要手动设置新生代和老年代的大小，只要设置整个堆的大小</strong></p>\n<div><pre><code>G1收集器在运行过程中，会自己调整新生代和老年代的大小其实是通过adapt代的大小来调整对象晋升的速度和年龄，从而达到为收集器设置的暂停时间目标\n\n如果手动设置了大小就意味着放弃了G1的自动调优\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>(2)不断调优暂停时间目标</strong></p>\n<div><pre><code>一般情况下这个值设置到100ms或者200ms都是可以的(不同情况下会不一样)，但如果设置成50ms就不太合理。暂停时间设置的太短，就会导致出现G1跟不上垃圾产生的速度。最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。暂停时间只是一个目标，并不能总是得到满足。\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>(3)使用-XX:ConcGCThreads=n来增加标记线程的数量</strong></p>\n<div><pre><code>IHOP如果阀值设置过高，可能会遇到转移失败的风险，比如对象进行转移时空间不足。如果阀值设置过低，就会使标记周期运行过于频繁，并且有可能混合收集期回收不到空间。\n\nIHOP值如果设置合理，但是在并发周期时间过长时，可以尝试增加并发线程数，调高ConcGCThreads。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>(4)MixedGC调优</strong></p>\n<div><pre><code>-XX:InitiatingHeapOccupancyPercent\n-XX:G1MixedGCLiveThresholdPercent\n-XX:G1MixedGCCountTarger\n-XX:G1OldCSetRegionThresholdPercent\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>(5)适当增加堆内存大小</p>\n<h2 id=\"_1-3-高并发场景分析\"> 1.3 高并发场景分析</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311001043190.png\" alt=\"image-20220311001043190\" /></p>\n<h2 id=\"_1-4-jvm性能优化指南\"> 1.4 JVM性能优化指南</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311001107369.png\" alt=\"image-20220311001107369\" /></p>\n<h2 id=\"_1-5-常见问题思考\"> 1.5 常见问题思考</h2>\n<p><strong>（1）内存泄漏与内存溢出的区别</strong></p>\n<p>内存泄漏：对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。</p>\n<p>内存溢出：内存泄漏到一定的程度就会导致内存溢出，但是内存溢出也有可能是大对象导致的。</p>\n<p><strong>（2）young gc会有stw吗？</strong></p>\n<p>不管什么 GC，都会有 stop-the-world，只是发生时间的长短。</p>\n<p><strong>（3）major gc和full gc的区别</strong></p>\n<p><strong>major gc指的是老年代的gc，而full gc等于young+old+metaspace的gc。</strong></p>\n<p><strong>（4）G1与CMS的区别是什么</strong></p>\n<p>CMS 用于老年代的回收，而 G1 用于新生代和老年代的回收。 G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的产生。</p>\n<p><strong>（5）什么是直接内存</strong></p>\n<p>直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于Java堆。因此出于性能的考 虑，读写频繁的场合可能会考虑使用直接内存。</p>\n<p><strong>（6）不可达的对象一定要被回收吗？</strong></p>\n<p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对 象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此 对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机 将这两种情况视为没有必要执行。 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关 联，否则就会被真的回收。</p>\n<p><strong>（7）方法区中的无用类回收</strong></p>\n<p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满 足下面 3 个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然 被回收。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311003339439.png\" alt=\"image-20220311003339439\" /></p>\n<p><strong>（8）不同的引用</strong></p>\n<p>JDK1.2以后，Java对引用进行了扩充：强引用、软引用、弱引用和虚引用</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311002742261.png\" alt=\"image-20220311002742261\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311002930038.png\" alt=\"image-20220311002930038\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311003005058.png\" alt=\"image-20220311003005058\" /></p>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232017105.png",
      "date_published": "2022-05-05T10:22:38.000Z",
      "date_modified": "2022-07-02T17:06:40.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM内存图谱",
      "url": "https://www.moremind.cn/md/java/jvm/",
      "id": "https://www.moremind.cn/md/java/jvm/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-14T09:08:36.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "Java 字节码反编译成汇编-使用JITWatch",
      "url": "https://www.moremind.cn/md/java/jvm/java-jitwatch/",
      "id": "https://www.moremind.cn/md/java/jvm/java-jitwatch/",
      "content_html": "<h1 id=\"java-字节码反编译成汇编\"> Java 字节码反编译成汇编</h1>\n<blockquote>\n<p>本位以windows环境为前提，JDK版本为Oracle Sun JDK8-64位</p>\n</blockquote>\n<h2 id=\"hsdis环境准备\"> Hsdis环境准备</h2>\n<h3 id=\"_1-下载hsdis-amd64-dylib\"> 1.下载hsdis-amd64.dylib</h3>\n<blockquote>\n<p>下载地址如下：https://github.com/evolvedmicrobe/benchmarks/blob/master/hsdis-amd64.dylib</p>\n</blockquote>\n<h3 id=\"_2-下载hsdis-amd64-dll\"> 2.下载hsdis-amd64.dll</h3>\n<blockquote>\n<p>下载地址如下：https://github.com/atzhangsan/file_loaded</p>\n</blockquote>\n<h3 id=\"_3-配置hsdis-amd64-dylib和hsdis-amd64-dll\"> 3.配置hsdis-amd64.dylib和hsdis-amd64.dll</h3>\n<p>a.将下载好的hsdis-amd64.dll文件放置在JDK路径下<code>\\jre\\bin</code>目录下。</p>\n<blockquote>\n<p>e.g. C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\bin</p>\n</blockquote>\n<p>b.将下载好的hsdis-amd64.dylib文件放置在JDK路径下的<code>\\jre\\lib</code>目录下。</p>\n<blockquote>\n<p>e.g. C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib</p>\n</blockquote>\n<h3 id=\"_4-测试验证是否配置成功\"> 4.测试验证是否配置成功</h3>\n<p>使用命令<code>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -version</code>验证是否配置成功。如果出现如下所示则说明配置成功。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414230849483.png\" alt=\"image-20210414230849483\" /></p>\n<h3 id=\"_5-自行构建hsdis-如果你有兴趣的话\"> 5.自行构建hsdis(如果你有兴趣的话)</h3>\n<p>如果你有兴趣自行编译hsdis的话，可以参考如下的几个链接，然后把编译好的文件放在jdk的jre目录下的如上所<code>3</code>述路径。</p>\n<p>1.http://www.chrisnewland.com/building-hsdis-on-linux-amd64-on-debian-369</p>\n<p>2.http://psy-lob-saw.blogspot.com/2013/01/java-print-assembly.html</p>\n<h2 id=\"jitwatch环境\"> JITWatch环境</h2>\n<h3 id=\"_1-下载jitwatch\"> 1.下载JITWatch</h3>\n<blockquote>\n<p>下载路径如下：https://github.com/AdoptOpenJDK/jitwatch/releases</p>\n</blockquote>\n<p>如果你有兴趣的话，当然也可以参考官方文档进行编译。</p>\n<p>JITWatch链接如下：</p>\n<blockquote>\n<p>https://github.com/AdoptOpenJDK/jitwatch</p>\n</blockquote>\n<p>编译命令如下：</p>\n<div><pre><code>ant编译：\nant clean compile <span>test</span> run\nmaven编译：\nmvn clean compile <span>test</span> exec:java\ngradle编译：\ngradlew clean build run\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_2-配置运行jitwatch\"> 2.配置运行JITWatch</h3>\n<p>a.启动，使用<code>java -jar jitwatch-ui-1.4.0-shaded-win.jar</code>启动jitwatch，启动成功后如下所示</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414232505669.png\" alt=\"image-20210414232505669\" /></p>\n<p>b.配置，点击<code>sandbox</code>按钮打开窗口，再点击<code>Configure Sandbox</code>按钮，配置如下几个参数</p>\n<blockquote>\n<p>1.java classes目录</p>\n<p>2.java 运行目录为你本地的配置使用的JDK路径</p>\n<p>3.java运行参数，添加hsdis的运行参数配置</p>\n</blockquote>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414233652204.png\" alt=\"image-20210414233652204\" /></p>\n<p>c.运行，点击<code>open</code>按钮打开需要编译的java代码，点击<code>Run</code>按钮运行得到下图所示</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414232726380.png\" alt=\"image-20210414232726380\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414234418226.png\" alt=\"image-20210414234418226\" /></p>\n<h3 id=\"_3-jitwatch简单使用\"> 3.JITwatch简单使用</h3>\n<h4 id=\"模块化查看字节码和汇编码\"> 模块化查看字节码和汇编码</h4>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414234700267.png\" alt=\"image-20210414234700267\" /></p>\n<h4 id=\"使用toplist查看资源占用率\"> 使用topList查看资源占用率</h4>\n<p>在JITWatch窗口点击<code>TopList</code>按钮，即可查看资源占用率。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414235239556.png\" alt=\"image-20210414235239556\" /></p>\n<h4 id=\"更多资料\"> 更多资料</h4>\n<p>1.https://www.chrisnewland.com/images/jitwatch/HotSpot_Profiling_Using_JITWatch.pdf</p>\n<p>2.https://github.com/AdoptOpenJDK/jitwatch/wiki</p>\n<h2 id=\"参考文章\"> 参考文章</h2>\n<p>1.利用hsdis和JITWatch查看分析HotSpot JIT compiler生成的汇编代码.https://blog.csdn.net/hengyunabc/article/details/26898657</p>\n<p>2.JITWatch Wiki.https://github.com/AdoptOpenJDK/jitwatch/wiki</p>\n<blockquote>\n<p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=17nuh698omdi4</p>\n</blockquote>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414230849483.png",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-07-02T17:06:40.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "Java新特性",
      "url": "https://www.moremind.cn/md/java/new-feature/",
      "id": "https://www.moremind.cn/md/java/new-feature/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-New-Feature"
      ]
    },
    {
      "title": "java基础",
      "url": "https://www.moremind.cn/md/java/thread/",
      "id": "https://www.moremind.cn/md/java/thread/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Thread"
      ]
    },
    {
      "title": "线程池基础知识",
      "url": "https://www.moremind.cn/md/java/thread/thread-pool-basic/",
      "id": "https://www.moremind.cn/md/java/thread/thread-pool-basic/",
      "content_html": "<h2 id=\"_1-线程池的创建方式\"> 1.线程池的创建方式</h2>\n<h2 id=\"_2-线程池的关键参数\"> 2.线程池的关键参数</h2>\n<h2 id=\"_3-线程池设计的技巧\"> 3.线程池设计的技巧</h2>\n",
      "date_published": "2022-04-06T13:44:30.000Z",
      "date_modified": "2022-04-06T13:44:30.000Z",
      "authors": [
        {
          "name": "moremind"
        }
      ],
      "tags": [
        "Java-Thread"
      ]
    },
    {
      "title": "到底什么是线程安全和线程不安全？",
      "url": "https://www.moremind.cn/md/java/thread/thread-safety/",
      "id": "https://www.moremind.cn/md/java/thread/thread-safety/",
      "content_html": "<h2 id=\"_1-什么是线程安全\"> 1.什么是线程安全？</h2>\n<p>维基百科给出的定义如下：</p>\n<blockquote>\n<p>线程安全是程式设计中的术语，指<strong>某个函数、函数库</strong>在<strong>多线程环境</strong>中被调用时，能够正确地处理多个线程之间的<strong>共享变量</strong>，使程序功能正确完成。</p>\n</blockquote>\n<p>在《Java并发编程实战》一书中给出如下定义：</p>\n<blockquote>\n<p>一个对象是否需要是线程安全的，取决于它是否被多个线程访问。<strong>这只和对象在程序中是以何种方式被使用的有关，和对象本身具体是做什么的无关。</strong></p>\n</blockquote>\n<p>在《深入Java虚拟机》一书中给出如下定义：</p>\n<blockquote>\n<p>当多个线程访问同一个对象时，**如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，**调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。</p>\n</blockquote>\n<p>线程安全：在多线程同时访问一个资源时，线程间依照某种方式访问资源时，访问的结果总是能获取到正确的结果。</p>\n<h2 id=\"_2-java内存模型-jmm\"> 2.Java内存模型-JMM</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/16bf62d8c174d776.jpg\" alt=\"16bf62d8c174d776\" /></p>\n<p>上图描述了一个多线程执行场景。 线程 A 和线程 B 分别对主内存的<code>变量</code>进行读写操作。其中<strong>主内存</strong>中的<code>变量</code>为<code>共享变量</code>,也就是说此变量只此一份，多个线程间共享。但是线程不能直接读写主内存的<code>共享变量</code>，每个线程都有自己的<strong>工作内存</strong>，线程需要读写主内存的<code>共享变量</code>时需要先将该变量拷贝一份副本到自己的工作内存，然后在自己的工作内存中对该变量进行所有操作，线程工作内存对变量副本完成操作之后需要将结果同步至主内存。</p>\n<blockquote>\n<p>线程的工作内存是线程私有内存，线程间无法互相访问对方的工作内存。</p>\n</blockquote>\n<h2 id=\"_3-共享变量-共享资源\"> 3.共享变量(共享资源)</h2>\n<p>所谓共享变量，指的是多个线程都可以操作的变量。进程是分配资源的基本单位，线程是执行的基本单位。所以，多个线程之间是可以共享一部分进程中的数据的。在JVM中，Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可以操作保存在堆或者方法区中的同一个数据。那么，<strong>保存在堆和方法区中的变量就是Java中的共享变量。</strong></p>\n<p>那么，Java中哪些变量是存放在堆中，哪些变量是存放在方法区中，又有哪些变量是存放在栈中的呢？</p>\n<p>Java中共有三种变量，<strong>分别是类变量、成员变量和局部变量。他们分别存放在JVM的方法区、堆内存和栈内存中。</strong>（栈内存是程序线程独占空间）</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Variables</span> <span>{</span>\n\n    <span>/**\n     * 类变量\n     */</span>\n    <span>private</span> <span>static</span> <span>int</span> a<span>;</span>\n\n    <span>/**\n     * 成员变量\n     */</span>\n    <span>private</span> <span>int</span> b<span>;</span>\n\n    <span>/**\n     * 局部变量\n     * @param c\n     */</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>int</span> c<span>)</span><span>{</span>\n        <span>int</span> d<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>上面定义的三个变量中，变量a就是类变量，变量b就是成员变量，而变量c和d是局部变量。</p>\n<p>所以，变量a和b是共享变量，变量c和d是非共享变量。所以如果遇到多线程场景，对于变量a和b的操作是需要考虑线程安全的，而对于线程c和d的操作是不需要考虑线程安全的。</p>\n<h2 id=\"_4-线程安全的实现\"> 4.线程安全的实现</h2>\n<h3 id=\"_4-1-无状态实现\"> 4.1 无状态实现</h3>\n<p>在大多数情况下，多线程应用中的错误是错误地在多个线程之间共享状态的结果。</p>\n<p>因此，我们要研究的第一种方法是 <strong>使用无状态实现</strong>来实现线程安全。</p>\n<p>为了更好地理解这种方法，让我们考虑一个带有静态方法的简单工具类，该方法可以计算数字的阶乘：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MathUtils</span> <span>{</span>\n    \n    <span>public</span> <span>static</span> <span>BigInteger</span> <span>factorial</span><span>(</span><span>int</span> number<span>)</span> <span>{</span>\n        <span>BigInteger</span> f <span>=</span> <span>new</span> <span>BigInteger</span><span>(</span><span>\"1\"</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> number<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            f <span>=</span> f<span>.</span><span>multiply</span><span>(</span><span>BigInteger</span><span>.</span><span>valueOf</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> f<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong><code>factorial</code>方法是一种无状态确定性函数。</strong> 确定性是指：给定特定的输入，它将始终产生相同的输出。</p>\n<p>该方法<strong>既不依赖外部状态，也不维护自身的状态</strong>。因此，它被认为是线程安全的，并且可以同时被多个线程安全地调用。</p>\n<p>所有线程都可以安全地调用 <code>factorial</code> 方法，并且将获得预期结果，而不会互相干扰，也不会更改该方法为其他线程生成的输出。</p>\n<p>因此，<strong>无状态实现是实现线程安全的最简单方法</strong>。</p>\n<h3 id=\"_4-2-不可变的实现\"> 4.2  不可变的实现</h3>\n<p><strong>如果我们需要在不同线程之间共享状态，则可以通过使它们成为不可变对象来创建线程安全类</strong>。</p>\n<p>不变性是一个功能强大，与语言无关的概念，在Java中相当容易实现。</p>\n<p><strong>当类实例的内部状态在构造之后无法修改时，它是不可变的</strong>。</p>\n<p>在Java中创建不可变类的最简单方法是声明所有字段为 <em>private</em> 和 <em>final</em> ，且不提供 setter：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MessageService</span> <span>{</span>\n    \n    <span>private</span> <span>final</span> <span>String</span> message<span>;</span>\n \n    <span>public</span> <span>MessageService</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>message <span>=</span> message<span>;</span>\n    <span>}</span>\n    \n    <span>// 标准 getter</span>\n    \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>一个 <em>MessageService</em> 对象实际上是不可变的，因为它的状态在构造之后不能更改。因此，它是线程安全的。</p>\n<p>此外，如果 <em>MessageService</em> 实际上是<strong>可变</strong>的，但是多个线程仅对其具有<strong>只读</strong>访问权限，那么它也是线程安全的。</p>\n<p>因此，<strong>不变性是实现线程安全的另一种方法</strong>。</p>\n<h3 id=\"_4-3-线程私有-threadlocal-字段\"> 4.3 线程私有 (ThreadLocal) 字段</h3>\n<p>在面向对象编程（OOP）中，对象实际上需要通过字段维护状态并通过一种或多种方法来实现行为。</p>\n<p>如果我们确实需要维护状态，<strong>则可以通过使它们的字段成为线程局部的来创建不在线程之间共享状态的线程安全类。</strong></p>\n<p>通过简单地在 <em><a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html\" target=\"_blank\" rel=\"noopener noreferrer\">Thread</a></em> 类中定义私有字段，我们可以轻松创建其字段为线程局部的类。</p>\n<p>例如，我们可以定义一个存储整数数组的 <em>Thread</em> 类：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadA</span> <span>extends</span> <span>Thread</span> <span>{</span>\n    \n    <span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> numbers <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>)</span><span>;</span>\n    \n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        numbers<span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>而另一个类可能拥有一个字符串数组：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadB</span> <span>extends</span> <span>Thread</span> <span>{</span>\n    \n    <span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> letters <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>\"a\"</span><span>,</span> <span>\"b\"</span><span>,</span> <span>\"c\"</span><span>,</span> <span>\"d\"</span><span>,</span> <span>\"e\"</span><span>,</span> <span>\"f\"</span><span>)</span><span>;</span>\n    \n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        letters<span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>在这两种实现中，这些类都有其自己的状态，但是不与其他线程共享。因此，这些类是线程安全的。</strong></p>\n<p>同样，我们可以通过将 <em><a href=\"https://www.baeldung.com/java-threadlocal\" target=\"_blank\" rel=\"noopener noreferrer\">ThreadLocal</a></em> 实例分配给一个字段来创建线程私有字段。</p>\n<p>例如，让我们考虑以下 <em>StateHolder</em> 类：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>StateHolder</span> <span>{</span>\n    \n    <span>private</span> <span>final</span> <span>String</span> state<span>;</span>\n \n    <span>// 标准的构造函数和 getter</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们可以很容易地使其成为线程局部（ThreadLocal）变量，如下所示：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadState</span> <span>{</span>\n    \n    <span>public</span> <span>static</span> <span>final</span> <span>ThreadLocal</span><span><span>&lt;</span><span>StateHolder</span><span>></span></span> statePerThread <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>StateHolder</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n        \n        <span>@Override</span>\n        <span>protected</span> <span>StateHolder</span> <span>initialValue</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>StateHolder</span><span>(</span><span>\"active\"</span><span>)</span><span>;</span>  \n        <span>}</span>\n    <span>}</span><span>;</span>\n \n    <span>public</span> <span>static</span> <span>StateHolder</span> <span>getState</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> statePerThread<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>线程局部字段与普通类字段非常相似，不同之处在于，每个通过setter / getter访问它们的线程都将获得该字段的独立初始化副本，以便每个线程都有自己的状态。</p>\n<h3 id=\"_4-4-同步集合类\"> 4.4 同步集合类</h3>\n<p>通过使用<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html\" target=\"_blank\" rel=\"noopener noreferrer\">collections框架</a> 中包含的一组同步包装器，我们可以轻松地创建线程安全的<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html\" target=\"_blank\" rel=\"noopener noreferrer\">collections</a>。</p>\n<p>例如，我们可以使用以下<a href=\"https://www.baeldung.com/java-synchronized-collections\" target=\"_blank\" rel=\"noopener noreferrer\">同步包装之一</a>来创建线程安全的集合：</p>\n<div><pre><code>Collection&lt;Integer&gt; syncCollection = Collections.synchronizedCollection(new ArrayList&lt;&gt;());\nThread thread1 = new Thread(() -&gt; syncCollection.addAll(Arrays.asList(1, 2, 3, 4, 5, 6)));\nThread thread2 = new Thread(() -&gt; syncCollection.addAll(Arrays.asList(7, 8, 9, 10, 11, 12)));\nthread1.start();\nthread2.start();\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>让我们记住，同步集合在每种方法中都使用内在锁定（我们将在后面介绍内在锁定）。</p>\n<p>这意味着<strong>该方法一次只能由一个线程访问，而其他线程将被阻塞，直到该方法被第一个线程解锁。</strong></p>\n<p>因此，由于同步访问的基本逻辑，同步会对性能造成不利影响。</p>\n<h3 id=\"_4-5-支持并发的集合\"> 4.5 支持并发的集合</h3>\n<p>除了同步集合，我们可以使用并发集合来创建线程安全的集合。</p>\n<p>Java提供了 <em><a href=\"https://docs.oracle.com/javase/8/docs/api/?java/util/concurrent/package-summary.html\" target=\"_blank\" rel=\"noopener noreferrer\">java.util.concurrent</a></em> 包，其中包含多个并发集合，例如 <em><a href=\"https://docs.oracle.com/javase/8/docs/api/?java/util/concurrent/package-summary.html\" target=\"_blank\" rel=\"noopener noreferrer\">ConcurrentHashMap</a></em> ：</p>\n<div><pre><code>Map&lt;String,String&gt; concurrentMap = new ConcurrentHashMap&lt;&gt;();\nconcurrentMap.put(&quot;1&quot;, &quot;one&quot;);\nconcurrentMap.put(&quot;2&quot;, &quot;two&quot;);\nconcurrentMap.put(&quot;3&quot;, &quot;three&quot;);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>与同步对象不同，<strong>并发集合通过将其数据划分为段来实现线程安全</strong>。例如，在 <em>ConcurrentHashMap</em> 中，多个线程可以获取不同 Map 段上的锁，因此多个线程可以同时访问 <em>Map</em> 。</p>\n<p>由于并发线程访问的先天优势，<strong>并发集合类</strong>具备<strong>远超同步集合类更好的性能</strong>。</p>\n<p>值得一提的是，<strong>同步集合和并发集合仅使集合本身具有线程安全性，而不使content变得线程安全</strong>。</p>\n<h3 id=\"_4-6-原子化对象\"> 4.6 原子化对象</h3>\n<p>使用Java提供的一组<a href=\"https://www.baeldung.com/java-atomic-variables\" target=\"_blank\" rel=\"noopener noreferrer\">原子类</a>（包括 <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html\" target=\"_blank\" rel=\"noopener noreferrer\">AtomicInteger</a>，<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicLong.html\" target=\"_blank\" rel=\"noopener noreferrer\">AtomicLong</a>，<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicBoolean.html\" target=\"_blank\" rel=\"noopener noreferrer\">AtomicBoolean</a> 和 <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html\" target=\"_blank\" rel=\"noopener noreferrer\">AtomicReference</a> )也可以实现线程安全。</p>\n<p><strong>原子类使我们能够执行安全的原子操作，而无需使用同步</strong>。原子操作在单个机器级别的操作中执行。</p>\n<p>要了解解决的问题，让我们看下面的 <em>Counter</em> 类：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Counter</span> <span>{</span>\n    \n    <span>private</span> <span>int</span> counter <span>=</span> <span>0</span><span>;</span>\n    \n    <span>public</span> <span>void</span> <span>incrementCounter</span><span>(</span><span>)</span> <span>{</span>\n        counter <span>+=</span> <span>1</span><span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>int</span> <span>getCounter</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> counter<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>让我们假设在竞争条件下，两个线程同时访问 <code>increasingCounter()</code> 方法。</strong></p>\n<p>从理论上讲， <em>counter</em> 字段的最终值为2。但是我们不确定结果如何，因为线程在同一时间执行同一代码块，并且增量不是原子的。</p>\n<p>让我们使用 <em>AtomicInteger</em> 对象创建 <em>Counter</em> 类的线程安全实现：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>AtomicCounter</span> <span>{</span>\n    \n    <span>private</span> <span>final</span> <span>AtomicInteger</span> counter <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>\n    \n    <span>public</span> <span>void</span> <span>incrementCounter</span><span>(</span><span>)</span> <span>{</span>\n        counter<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>int</span> <span>getCounter</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> counter<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>这是线程安全的，因为在++增量执行多个操作的同时， <code>增量和获取</code> 是原子的</strong>。</p>\n<h3 id=\"_4-7-同步方法\"> 4.7 同步方法</h3>\n<p>尽管较早的方法对于集合和基元非常有用，但有时我们需要的控制权要强于此。</p>\n<p>因此，可用于实现线程安全的另一种常见方法是实现同步方法。</p>\n<p>简而言之，<strong>一次只能有一个线程可以访问同步方法，同时阻止其他线程对该方法的访问</strong>。其他线程将保持阻塞状态，直到第一个线程完成或该方法引发异常。</p>\n<p>我们可以通过使它成为同步方法，以另一种方式创建线程安全版本的 <em>creationCounter()</em> ：</p>\n<div><pre><code>public synchronized void incrementCounter() {\n    counter += 1;\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们通过与前缀的方法签名创建一个同步方法 synchronized 关键字。</p>\n<p>由于一次一个线程可以访问一个同步方法，因此一个线程将执行 <em>crementCounter()</em> 方法，而其他线程将执行相同的操作。任何重叠的执行都不会发生。</p>\n<p><strong>同步方法依赖于“内部锁”或“监视器锁”的使用</strong>。固有锁是与特定类实例关联的隐式内部实体。</p>\n<p>在多线程上下文中，术语 <em>monitor</em> 是指对关联对象执行锁的角色，因为它强制对一组指定的方法或语句进行排他访问。</p>\n<p><strong>当线程调用同步方法时，它将获取内部锁</strong>。线程完成执行方法后，它将释放锁，从而允许其他线程获取锁并获得对方法的访问。</p>\n<p>我们可以在实例方法，静态方法和语句（已同步的语句）中实现同步。</p>\n<h3 id=\"_4-8-同步语句\"> 4.8  同步语句</h3>\n<p>有时，如果我们只需要使方法的一部分成为线程安全的，那么同步整个方法可能就显得过分了。</p>\n<p>为了说明这个用例，让我们重构 <em>increascountCounter</em> 方法：</p>\n<div><pre><code>public void incrementCounter() {\n    // 此处可有额外不需同步的操作\n    // ...\n    synchronized(this) {\n        counter += 1; \n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>该示例很简单，但是它显示了如何创建同步语句。假设该方法现在执行了一些不需要同步的附加操作，我们仅通过将相关的状态修改部分包装在一个<strong>同步</strong>块中来对其进行<strong>同步</strong>。</p>\n<p>与同步方法不同，同步语句必须指定提供内部锁的对象，通常是<code>this</code>引用。</p>\n<p><strong>同步非常昂贵，因此使用此选项，我们尽可能只同步方法的相关部分</strong>。</p>\n<h3 id=\"_4-8-其他对象作为锁\"> 4.8 其他对象作为锁</h3>\n<p>我们可以通过将另一个对象用作监视器锁定，来稍微改善 <em>Counter</em> 类 的线程安全实现。</p>\n<p>这不仅可以在多线程环境中提供对共享资源的协调访问，<strong>还可以使用外部实体来强制对资源进行独占访问</strong>：</p>\n<div><pre><code>public class ObjectLockCounter {\n \n    private int counter = 0;\n    private final Object lock = new Object();\n    \n    public void incrementCounter() {\n        synchronized(lock) {\n            counter += 1;\n        }\n    }\n    \n    // 标准 getter\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>我们使用一个普通的 Object 实例来强制相互排斥。此实现稍好一些，因为它可以提高锁定级别的安全性。</p>\n<p>将 this 用于内部锁定时，<strong>攻击者可能会通过获取内部锁定并触发拒绝服务（DoS）条件来导致死锁。</strong></p>\n<p>相反，在使用其他对象时， <strong>无法从外部访问该私有实体</strong>。这使得攻击者更难获得锁定并导致死锁。</p>\n<h2 id=\"_5-参考文章\"> 5.参考文章</h2>\n<p>1.什么是线程安全?.https://www.jianshu.com/p/44831d1d10d3</p>\n<p>2.深入理解Java并发编程（一）：到底什么是线程安全.https://www.hollischuang.com/archives/3060</p>\n<p>3.Java 并发基础——线程安全性.https://www.cnblogs.com/NeilZhang/p/8682266.html</p>\n<p>4.什么是线程安全以及如何实现？https://segmentfault.com/a/1190000023187634</p>\n<p>5.你真的知道什么是线程安全吗？.https://www.hoohack.me/2020/09/01/what-is-thread-safe</p>\n<p>6.(解释的比较清楚，透彻的)图解 Java 线程安全.https://juejin.cn/post/6844903890224152584</p>\n<p>7.Java进阶（二）当我们说线程安全时，到底在说什么.http://www.jasongj.com/java/thread_safe/</p>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/16bf62d8c174d776.jpg",
      "date_published": "2022-01-17T14:28:59.000Z",
      "date_modified": "2022-07-02T17:06:40.000Z",
      "authors": [
        {
          "name": "moremind"
        }
      ],
      "tags": [
        "Java-Thread"
      ]
    },
    {
      "title": "Memecache",
      "url": "https://www.moremind.cn/md/middleware/cache/memcache/",
      "id": "https://www.moremind.cn/md/middleware/cache/memcache/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Memcache"
      ]
    },
    {
      "title": "Redis",
      "url": "https://www.moremind.cn/md/middleware/cache/redis/",
      "id": "https://www.moremind.cn/md/middleware/cache/redis/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Redis"
      ]
    },
    {
      "title": "分布式基础-共识、线性一致性与顺序一致性",
      "url": "https://www.moremind.cn/md/middleware/distributed-design/CAP%E7%90%86%E8%AE%BA-%E5%85%B1%E8%AF%86%E3%80%81%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7/",
      "id": "https://www.moremind.cn/md/middleware/distributed-design/CAP%E7%90%86%E8%AE%BA-%E5%85%B1%E8%AF%86%E3%80%81%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7/",
      "content_html": "<h2 id=\"说明\"> 说明</h2>\n<p>本文部分内容来自于：https://segmentfault.com/a/1190000022248118###</p>\n<p>本文将会根据该文章适当增减内容！</p>\n<h2 id=\"作者引言\"> 作者引言</h2>\n<p>etcd 是线性一致性读，而 zk 却是顺序一致性读，再加上各种共识、强弱一致的名词，看的时候总会混淆，这篇文档就列举下分布式系统中的那些&quot;一致性名词&quot;，引用了很多其他的文章，不过会多出一些例子来帮助理解。</p>\n<h2 id=\"_1-什么是一致性\"> 1.什么是一致性？</h2>\n<p>在谈到一致性这个词时，你会想到CAP理论的 consistency，或者 ACID 中的 consistency，或者 cache一致性协议的 coherence，还是 Raft/Paxos 中的 consensus？</p>\n<p>一致性这个词在不同的领域具有不同的含义，毕竟这个中文词在英文中对应了不同的术语，consistency，coherence，consensus三个单词统一翻译为”一致性”。因此在谈一致性之前，有必要对这几个概念做一个区分，否则很容易让人迷惑</p>\n<h3 id=\"_1-1-coherence\"> 1.1 coherence</h3>\n<p>Coherence 只出现在Cache Coherence 一词中，称为”缓存一致性”，研究多核场景，即怎么保证多个核上的CPU 缓存数据是一致的，一般是单机维度的，不算分布式领域，可以参考这篇文章<a href=\"https://www.infoq.cn/article/cache-coherency-primer/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.infoq.cn/article/cache-coherency-primer/</a></p>\n<h3 id=\"_1-2-consensus\"> 1.2 consensus</h3>\n<p>consensus准确的翻译是共识，即多个提议者达成共识的过程，例如Paxos，Raft 就是共识算法，paxos 是一种共识理论，分布式系统是他的场景，一致性是他的目标。</p>\n<p>一些常见的误解：使用了 Raft或者 paxos 的系统都是线性一致的（Linearizability 即强一致），其实不然，共识算法只能提供基础，要实现线性一致还需要在算法之上做出更多的努力。</p>\n<p>因为分布式系统引入了多个节点，节点规模越大，宕机、网络时延、网络分区就会成为常态，任何一个问题都可能导致节点之间的数据不一致，因此Paxos 和 Raft 准确来讲是用来解决一致性问题的共识算法，用于分布式场景，而非”缓存一致性“这种单机场景。所以很多文章也就简称”Paxos是分布式系统中的一致性算法“，</p>\n<p>一致性（Consistency）的含义比共识（consensus）要宽泛，一致性指的是多个副本对外呈现的状态。包括顺序一致性、线性一致性、最终一致性等。而共识特指达成一致的过程，但注意，共识并不意味着实现了一致性，一些情况下他是做不到的。</p>\n<h4 id=\"_1-2-1-paxos与raft\"> 1.2.1 Paxos与Raft</h4>\n<p>这里提一下Paxos，Paxos 其实是一类协议，Paxos 中包含 Basic Paxos、Multi-Paxos、Cheap Paxos 和其他的变种。Raft 就是 Multi-Paxos 的一个变种，Raft 通过简化 Multi-Paxos 的模型，实现了一种更容易让人理解和工程实现的共识算法，</p>\n<p>Paxos是第一个被证明完备的共识算法，能够让分布式网络中的节点在出现错误时仍然保持一致，当然前提是没有恶意节点，也就是拜占庭将军问题。在传统的分布式系统领域是不需要担心这种问题的，因为不论是分布式数据库、消息队列、分布式存储，你的机器都不会故意发送错误信息，最常见的问题反而是节点失去响应，所以它们在这种前提下，Paxos是足够用的。</p>\n<h3 id=\"_1-2-2-复制状态机\"> 1.2.2 复制状态机</h3>\n<p>consensus共识在实现机制上属于复制状态机(Replicated State Machine)的范畴，复制状态机是一种很有效的容错技术，基于复制日志来实现，每个 Server 存储着一份包含命令序列的日志文件，状态机会按顺序执行这些命令。因为日志中的命令和顺序都相同，因此所有节点会得到相同的数据。</p>\n<p>因此保证系统一致性就简化为保证操作日志的一致，这种复制日志的方式被大量运用，<code>如 GSF、HDFS、ZooKeeper和 etcd 都是这种机制</code>。</p>\n<h3 id=\"_1-2-3-区块链\"> 1.2.3 区块链</h3>\n<p>共识算法还有一个很重要的领域，就是比较火的区块链，比如工作量证明（POW）、权益证明（POS）和委托权益证明（DPOS）、置信度证明（PoB）等等，都是共识算法，这篇文章就列出来了 30 种</p>\n<p>大家熟知的zk、etcd这种之所以叫“传统分布式”，就是相对于区块链这种”新型分布式系统“而言的，都是多节点共同工作，只是区块链有几点特殊：</p>\n<ul>\n<li>区块链需要解决的是拜占庭将军问题，paxos之类的一致性算法无法对抗欺诈节点</li>\n<li>区块链中不存在中央控制方，没有一个节点可以控制或协调账本数据的生成</li>\n<li>区块链中的共识算法如果达不到一致性，则任何人都可以硬分叉，另建一个社区、一条链</li>\n<li>分布式系统的性能理论上可以无限提升，但区块链是以相对的低效率来换取公正，主流的公有链每秒只能处理几笔到几十笔交易</li>\n</ul>\n<h2 id=\"_1-3-consistency\"> 1.3 consistency</h2>\n<p>介绍完了Coherence和consensus共识，我们来看consistency一致性，也就是我们平时说的最多的 CAP、Base、ACID之类。</p>\n<p>最简单的，客户端C1将系统中的一个值K由V1更新为V2，客户端C2/C3/C4..需要立即读取到K的最新值</p>\n<p><code>一致性要求的是一致，并不是正确，如果所有节点一致给出一个”错误“的答案，那也叫一致性</code></p>\n<p>对于不同的场景，用户角度对于一致性的要求是不一样的，例如：</p>\n<ul>\n<li>银行系统：你在柜台存了一笔钱，同时你的朋友转账给你一笔钱，你的女朋友同时又在淘宝消费了一笔钱，你可能会感觉很乱，但你相信，最后你的余额一定是对的，银行可以慢一点，但不会把钱搞错。</li>\n<li>电商系统：你在淘宝看到一个库存为 5 的衣服，然后你快速下单，但是被提示”库存不足，无法购买“，你会觉得自己动作太慢，被人抢走了，不太关心库存为啥显示 5。</li>\n<li>论坛小站：你注册一个论坛，需要手机验证码，点完发送之后，一直没有响应，过了一天你才收到了这条短信，不过小站而已，不注册也就罢了。</li>\n</ul>\n<p>上面是夸张了的用户情况，在实际业务中，一致性也是分等级的，如强一致性和弱一致性，怎么使用要看具体情况和系统的容忍度。</p>\n<p>强一致性和弱一致性只是一种统称，按照从强到弱，可以划分为</p>\n<ul>\n<li>\n<p>线性一致性Linearizability consistency ，也称原子一致性或严格一致性指的是程序在执行的历史中在存在可线性化点P的执行模型，这意味着一个操作将在程序的调用和返回之间的某个点P起作用。这里“起作用”的意思是被系统中并发运行的所有其他线程所感知。\n关于线性一致性的理论基础可以参看维基百科：https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7</p>\n<ul>\n<li>线性一致性最重要的性质就是其“局部性”（Local property, 或可组合性 - Compositional），即数个线性一致单对象历史的组合也是线性一致的。</li>\n<li>线性一致性的非阻塞性(Non-blocking property)：线程P对完全操作(total function)的调用永远不会阻塞。</li>\n</ul>\n</li>\n<li>\n<p>顺序一致性 Sequential consistency\n关于顺序一致性的理论即可参看维基百科：https://en.wikipedia.org/wiki/Sequential_consistency</p>\n</li>\n<li>\n<p>因果一致性 Causal consistency</p>\n</li>\n<li>\n<p>最终一致性 Eventual consistency</p>\n</li>\n</ul>\n<p>强一致性包括线性一致性和顺序一致性，其他的如最终一致都是弱一致性。</p>\n<p>关于强和弱的定义，可以参考剑桥大学的slide(https://www.cl.cam.ac.uk/teaching/0910/ConcDistS/11a-cons-tx.pdf)</p>\n<div><pre><code>Strong consistency\n– ensures that only consistent state can be seen.\n\n* All replicas return the same value when queried for the attribute of an object * All replicas return the same value when queried for the attribute of an object. This may be achieved at a cost – high latency.\n\nWeak consistency\n – for when the “fast access” requirement dominates.\n\n* update some replica, e.g. the closest or some designated replica\n* the updated replica sends up date messages to all other replicas.\n* different replicas can return different values for the queried attribute of the object the value should be returned, or “not known”, with a timestamp\n* in the long term all updates must propagate to all replicas …….\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>强一致性集群中，对任何一个节点发起请求都会得到相同的回复，但将产生相对高的延迟。而弱一致性具有更低的响应延迟，但可能会回复过期的数据，最终一致性即是经过一段时间后终会到达一致的弱一致性。</p>\n<h2 id=\"_2-背景\"> 2.背景</h2>\n<p>如买最后一张车票，两个售票处分别通过某种方式确认过这张票的存在。这时，两家售票处几乎同时分别来了一个乘客要买这张票，从各自“观察”看来，自己一方的乘客都是先到的，这种情况下，怎么能达成对结果的共识呢？看起来很容易，卖给物理时间上率先提交请求的乘客即可。</p>\n<p>如买最后一张车票，两个售票处分别通过某种方式确认过这张票的存在。这时，两家售票处几乎同时分别来了一个乘客要买这张票，从各自“观察”看来，自己一方的乘客都是先到的，这种情况下，怎么能达成对结果的共识呢？看起来很容易，卖给物理时间上率先提交请求的乘客即可。</p>\n<p>这也是解决分布式系统领域很多问题的核心秘诀：把不同时空发生的多个事件进行全局唯一排序，而且这个顺序还得是大家都认可的，排了序，一个一个处理就行了，和单机没有任何区别（不考虑突然故障情况，只考虑共识机制）</p>\n<p>如果存在可靠的物理时钟，实现排序往往更为简单。高精度的石英钟的漂移率为 10的-7 次方，最准确的原子震荡时钟的漂移率为 10的-13 次方。Google 曾在其分布式数据库 Spanner 中采用基于原子时钟和 GPS 的“TrueTime”方案，能够将不同数据中心的时间偏差控制在 10ms 置信区间。在不考虑成本的前提下，这种方案简单、有效。然而，计算机系统的时钟误差要大得多，这就造成分布式系统达成一致顺序十分具有挑战，或者说基本不可能。</p>\n<p>要实现绝对理想的严格一致性（Strict Consistency）代价很大。除非系统不发生任何故障，而且所有节点之间的通信无需任何时间，此时整个系统其实就等价于一台机器了。因此根据实际需求的不用，人们可能选择不同强度的一致性。</p>\n<h3 id=\"_2-1-顺序一致性-sequential-consistency\"> 2.1 顺序一致性(Sequential Consistency)</h3>\n<p>虽然强度上 线性一致性 &gt; 顺序一致性，但因为顺序一致性出现的时间比较早(1979年)，线性是在顺序的基础上的加强(1990 年)。因此先介绍下<code>顺序一致性</code></p>\n<p>顺序一致性也算强一致性的一种，他的原理比较晦涩，论文看这里(https://www.microsoft.com/en-us/research/publication/make-multiprocessor-computer-correctly-executes-multiprocess-programs/)</p>\n<h4 id=\"_2-1-1-顺序一致性理论基础\"> 2.1.1 顺序一致性理论基础</h4>\n<p>文章参看：https://en.wikipedia.org/wiki/Sequential_consistency</p>\n<p>顺序一致性：任何执行的结果都与所有处理器的操作都按某种顺序执行一样，并且每个单独的处理器的操作按照其程序指定的顺序出现在这个顺序中</p>\n<p>即程序在同一处理器（或线程）上的执行顺序与程序顺序相同，而程序在不同处理器（或线程）上的执行顺序是未定义的。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Sequential_consistency.svg.png\" alt=\"\" /></p>\n<p>A1、B1和C1之间的执行顺序被保留，即A1在B1之前运行，B1在C1之前。 A2 和 B2 相同。 但是，由于处理器之间的执行顺序未定义，B2 可能在 C1 之前或之后运行（B2 可能在物理上运行在 C1 之前，但 B2 的效果可能在 C1 之后看到，这与“B2 在 C1 之后运行”相同）</p>\n<h4 id=\"_2-1-2-顺序一致性解释说明\"> 2.1.2 顺序一致性解释说明</h4>\n<p>举例说明1：下面的图满足了顺序一致，但不满足线性一致。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/1651442386-b708bbfb6397fbcb_fix732.png\" alt=\"\" /></p>\n<ul>\n<li>x 和 y 的初始值为 0</li>\n<li>Write(x,4)代表写入 x=4，Read(y,2)为读取 y =2</li>\n</ul>\n<p>从图上看，进程P1，P2的一致性并没有冲突。因为从这两个进程的角度来看，顺序应该是这样的：</p>\n<div><pre><code>Write(y,2), Read(x,0), Write(x,4), Read(y,2)\n</code></pre>\n<div><span>1</span><br></div></div><p>这个顺序对于两个进程内部的读写顺序都是合理的，只是这个顺序与全局时钟下看到的顺序并不一样。在全局时钟的观点来看，P2进程对变量X的读操作在P1进程对变量X的写操作之后，然而P2读出来的却是旧的数据0</p>\n<p>举例说明 2:</p>\n<p>假设我们有个分布式 KV 系统，以下是四个进程 对其的操作顺序和结果:</p>\n<p>--表示持续的时间，因为一次写入或者读取，客户端从发起到响应是有时间的，发起早的客户端，不一定拿到数据就早，有可能因为网络延迟反而会更晚。</p>\n<p>情况 1：</p>\n<div><pre><code>A: --W(x,1)----------------------\nB:  --W(x,2)----------------------\nC:                      -R(x,1)-   --R(x,2)-\nD:                 -R(x,1)-      --R(x,2)--\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>情况 2：</p>\n<div><pre><code>A: --W(x,1)----------------------\nB:  --W(x,2)----------------------\nC:                      -R(x,2)-   --R(x,1)-\nD:                 -R(x,2)-      --R(x,1)--\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面情况1和2都是满足顺序一致性的，C 和 D 拿的顺序都是 1-2，或 2-1，只要CD 的顺序一致，就是满足顺序一致性。只是从全局看来，情况1更真实，情况2就显得”错误“了，因为情况2是这样的顺序</p>\n<p>B W(x,2) -&gt; A W(x,1) -&gt; C R(x,2) -&gt; D R(x,2) -&gt; C R(x,1) -&gt; D R(x,1)</p>\n<p>不过一致性不保证正确性，所以这仍然是一个顺序一致。再加一种情况 3：</p>\n<p>情况 3：</p>\n<div><pre><code>A: --W(x,1)----------------------\nB:  --W(x,2)----------------------\nC:                      -R(x,2)-   --R(x,1)-\nD:                 -R(x,1)-      --R(x,2)--\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>情况 3 就不属于顺序一致了，因为C 和 D 两个进程的读取顺序不同了。</p>\n<p>回到情况 2，C 和 D 拿数据发起的时间是不同的，且有重叠，有可能 C 拿到 1 的时候，D 已经拿到了 2，这就导致了不同的客户端在相同的时间获取了不一样的数据，但其实这种模式在现实中的用的挺广泛的：</p>\n<p>如：你在Twitter上写了2条推文，你的操作会耗费一定的时间渗透进一层层的缓存系统，不同的朋友将在不同的时间看到你的信息，但每个朋友都会以相同顺序看到了你的2条推文，不会是乱序。只是一个朋友已经看到了第二条，一个朋友才刚看到第一条，不过没关系，他总会看到两条，顺序没错就行，无伤大雅。</p>\n<p>但有些时候，顺序一致是不满足要求的，举例说明 3：</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/1366819531-888b0a6395021757_fix732.jpg\" alt=\"\" /></p>\n<p>从时间轴上可以看到，B0 发生在 A0 之前，读取到的 x 值为0。B2 发生在 A0 之后，读取到的 x 值为1。而读操作 B1，C0，C1 与写操作 A0 在时间轴上有重叠，因此他们可能读取到旧的值0，也可能读取到新的值1。注意，C1 发生在 B1 之后（二者在时间轴上没有重叠），但是 B1 看到 x 的新值，C1 反而看到的是旧值。即对用户来说，x 的值发生了回跳。</p>\n<p>即要求任何一次读都能读到最新数据，和全局时钟一致。对比例1，既满足顺序一致又满足线性一一致应该是这样的：</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/877dbbf6-9aff-4a92-8f77-b4a3e7c65a1c.jpg\" alt=\"\" /></p>\n<p>每个读操作都读到了该变量的最新写的结果，同时两个进程看到的操作顺序与全局时钟的顺序一样，都是Write(y,2), Read(x,4), Write(x,4), Read(y,2)</p>\n<h4 id=\"_2-1-3-zookeeper\"> 2.1.3 ZooKeeper</h4>\n<p>一种说法是<code></code>ZooKeeper<code></code>是最终一致性，因为由于多副本、以及保证大多数成功的<code>Zab</code>协议，当一个客户端进程写入一个新值，另外一个客户端进程不能保证马上就能读到这个值，但是能保证最终能读取到这个值。</p>\n<p>另外一种说法是 <code>ZooKeeper</code>的<code>Zab</code>协议类似于<code>Paxos</code>协议，提供了强一致性。</p>\n<p>但这两种说法都不准确，<code>ZooKeeper</code> `文档中明确写明它的一致性是 Sequential consistency即顺序一致。</p>\n<p>ZooKeeper中针对同一个Follower A提交的写请求request1、request2，某些Follower虽然可能不能在请求提交成功后立即看到（也就是强一致性），但经过自身与Leader之间的同步后，这些Follower在看到这两个请求时，一定是先看到request1，然后再看到request2，两个请求之间不会乱序，即顺序一致性</p>\n<p>其实，实现上ZooKeeper 的一致性更复杂一些，ZooKeeper 的读操作是 sequential consistency 的，ZooKeeper 的写操作是 linearizability 的，关于这个说法，ZooKeeper 的官方文档中没有写出来，但是在社区的邮件组有详细的讨论。ZooKeeper 的论文《Modular Composition of Coordination Services》 中也有提到这个观点。</p>\n<p>总结一下，可以这么理解 ZooKeeper：<code>从整体（read 操作 +write 操作）上来说是 sequential consistency，写操作实现了 Linearizability。</code></p>\n<h3 id=\"_2-2-线性一致性-linearizability\"> 2.2 线性一致性 (Linearizability)</h3>\n<p>线性一致性又被称为强一致性、严格一致性、原子一致性。是程序能实现的最高的一致性模型，也是分布式系统用户最期望的一致性。CAP 中的 C 一般就指它</p>\n<p>顺序一致性中进程只关心大家认同的顺序一样就行，不需要与全局时钟一致，线性就更严格，从这种偏序（partial order）要达到全序（total order）</p>\n<p>要求是：</p>\n<ul>\n<li>1.任何一次读都能读到某个数据的最近一次写的数据。</li>\n<li>2.系统中的所有进程，看到的操作顺序，都与全局时钟下的顺序一致。</li>\n</ul>\n<p>以上面的例 3 继续讨论：</p>\n<p><code>B1 看到 x 的新值，C1 反而看到的是旧值。即对用户来说，x 的值发生了回跳。</code></p>\n<p>在线性一致的系统中，如果 B1 看到的 x 值为1，则 C1 看到的值也一定为1。任何操作在该系统生效的时刻都对应时间轴上的一个点。如果我们把这些时刻连接起来，如下图中紫线所示，则这条线会一直沿时间轴向前，不会反向回跳。所以任何操作都需要互相比较决定，谁发生在前，谁发生在后。例如 B1 发生在 A0 前，C1 发生在 A0 后。而在前面顺序一致性模型中，我们无法比较诸如 B1 和 A0 的先后关系。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/2201764988-da7292edc8dce321_fix732.png\" alt=\"\" /></p>\n<h4 id=\"_2-2-1-etcd-与-raft\"> 2.2.1 etcd 与 raft</h4>\n<p>上面提到ZooKeeper的写是线性一致性，读是顺序一致性。而 etcd读写都做了线性一致，即 etcd 是标准的强一致性保证。</p>\n<p>etcd是基于raft来实现的，raft是共识算法，虽然共识和一致性的关系很微妙，经常一起讨论，但共识算法只是提供基础，要实现线性一致还需要在算法之上做出更多的努力如库封装，代码实现等。如raft中对于一致性读给出了两种方案，来保证处理这次读请求的一定是 Leader：</p>\n<ul>\n<li>ReadIndex</li>\n<li>LeaseRead</li>\n</ul>\n<p>基于 raft 的软件有很多，如 etcd、tidb、SOFAJRaft等，这些软件在实现一致读时都是基于这两种方式。</p>\n<p>关于 etcd 的选主架构这里不做描述，可以看这篇文章(http://www.xuyasong.com/?p=1706)，这里对ReadIndex和Lease Read做下解释，即etcd 中线性一致性读的具体实现</p>\n<p>由于在 Raft 算法中，写操作成功仅仅意味着日志达成了一致（已经落盘），而并不能确保当前状态机也已经 apply 了日志。状态机 apply 日志的行为在大多数 Raft 算法的实现中都是异步的，所以此时读取状态机并不能准确反应数据的状态，很可能会读到过期数据。</p>\n<p>基于以上这个原因，要想实现线性一致性读，一个较为简单通用的策略就是：每次读操作的时候记录此时集群的 commited index，当状态机的 apply index 大于或等于 commited index 时才读取数据并返回。由于此时状态机已经把读请求发起时的已提交日志进行了 apply 动作，所以此时状态机的状态就可以反应读请求发起时的状态，符合线性一致性读的要求。这便是 ReadIndex 算法。</p>\n<p>那如何准确获取集群的 commited index ？如果获取到的 committed index 不准确，那么以不准确的 committed index 为基准的 ReadIndex 算法将可能拿到过期数据。</p>\n<p>为了确保 committed index 的准确，我们需要：</p>\n<ul>\n<li>让 leader 来处理读请求；</li>\n<li>如果 follower 收到读请求，将请求 forward 给 leader；</li>\n<li>确保当前 leader 仍然是 leader；</li>\n</ul>\n<p>leader 会发起一次广播请求，如果还能收到大多数节点的应答，则说明此时 leader 还是 leader。这点非常关键，如果没有这个环节，leader 有可能因网络分区等原因已不再是 leader，如果读请求依然由过期的 leader 处理，那么就将有可能读到过去的数据。</p>\n<p>这样，我们从 leader 获取到的 commited index 就作为此次读请求的 ReadIndex。</p>\n<p>以网络分区为例：</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/2725083767-f0135ee44ccfa95c_fix732.png\" alt=\"\" /></p>\n<p>如上图所示：</p>\n<ul>\n<li>初始状态时集群有 5 个节点：A、B、C、D 和 E，其中 A 是 leader；</li>\n<li>发生网络隔离，集群被分割成两部分，一个 A 和 B，另外一个是 C、D 和 E。虽然 A 会持续向其他几个节点发送 heartbeat，但由于网络隔离，C、D 和 E 将无法接收到 A 的 heartbeat。默认地，A 不处理向 follower 节点发送 heartbeat 失败（此处为网络超时）的情况（协议没有明确说明 heartbeat 是一个必须收到 follower ack 的双向过程）；</li>\n<li>C、D 和 E 组成的分区在经过一定时间没有收到 leader 的 heartbeat 后，触发 election timeout，此时 C 成为 leader。此时，原来的 5 节点集群因网络分区分割成两个集群：小集群 A 和 B，A 为 leader；大集群 C、D 和 E，C 为 leader；</li>\n<li>此时有客户端进行读写操作。在 Raft 算法中，客户端无法感知集群的 leader 变化（更无法感知服务端有网络隔离的事件发生）。客户端在向集群发起读写请求时，一般是从集群的节点中随机挑选一个进行访问。如果客户端一开始选择 C 节点，并成功写入数据（C 节点集群已经 commit 操作日志），然后因客户端某些原因（比如断线重连），选择节点 A 进行读操作。由于 A 并不知道另外 3 个节点已经组成当前集群的大多数并写入了新的数据，所以节点 A 无法返回准确的数据。此时客户端将读到过期数据。不过相应地，如果此时客户端向节点 A 发起写操作，那么写操作将失败，因为 A 因网络隔离无法收到大多数节点的写入响应；</li>\n<li>针对上述情况，其实节点 C、D 和 E 组成的新集群才是当前 5 节点集群中的大多数，读写操作应该发生在这个集群中而不是原来的小集群（节点 A 和 B）。如果此时节点 A 能感知它已经不再是集群的 leader，那么节点 A 将不再处理读写请求。于是，我们可以在 leader 处理读请求时，发起一次 check quorum 环节：leader 向集群的所有节点发起广播，如果还能收到大多数节点的响应，处理读请求。当 leader 还能收到集群大多数节点的响应，说明 leader 还是当前集群的有效 leader，拥有当前集群完整的数据。否则，读请求失败，将迫使客户端重新选择新的节点进行读写操作。</li>\n</ul>\n<p>这样一来，Raft 算法就可以保障 CAP 中的 C 和 P，但无法保障 A：网络分区时并不是所有节点都可响应请求，少数节点的分区将无法进行服务，从而不符合 Availability。因此，Raft 算法是 CP 类型的一致性算法。</p>\n<p>Raft算法在线可视化：http://www.kailing.pub/raft/index.html</p>\n<p>Raft保证读请求Linearizability的方法：</p>\n<ul>\n<li>1.Leader把每次读请求作为一条日志记录，以日志复制的形式提交，并应用到状态机后，读取状态机中的数据返回。（一次RTT、一次磁盘写）</li>\n<li>2.使用Leader Lease，保证整个集群只有一个Leader，Leader接收到都请求后，记录下当前的commitIndex为readIndex，当applyIndex大于等于readIndex 后，则可以读取状态机中的数据返回。（0次RTT、0次磁盘写）</li>\n<li>3.不使用Leader Lease，而是当Leader通过以下两点来保证整个集群中只有其一个正常工作的Leader：（1）在每个Term开始时，由于新选出的Leader可能不知道上一个Term的commitIndex，所以需要先在当前新的Term提交一条空操作的日志；（2）Leader每次接到读请求后，向多数节点发送心跳确认自己的Leader身份。之后的读流程与Leader Lease的做法相同。（一次RTT、0次磁盘写）</li>\n<li>4.从Follower节点读：Follower先向Leader询问readIndex，Leader收到Follower的请求后依然要通过2或3中的方法确认自己Leader的身份，然后返回当前的commitIndex作为readIndex，Follower拿到readIndex后，等待本地的applyIndex大于等于readIndex后，即可读取状态机中的数据返回。（2次或1次RTT、0次磁盘写）</li>\n</ul>\n<h3 id=\"_2-3-linearizability-和-serializability\"> 2.3 Linearizability 和 Serializability</h3>\n<p>Serializability是数据库领域的概念，而Linearizability是分布式系统、并发编程领域的东西，在这个分布式SQL时代，自然Linearizability和Serializability会经常一起出现。</p>\n<ul>\n<li>Serializability: 数据库领域的ACID中的I。 数据库的四种隔离级别，由弱到强分别是Read Uncommitted,Read Committed(RC),Repeatable Read(RR)和Serializable。</li>\n</ul>\n<p>Serializable的含义是：对并发事务包含的操作进行调度后的结果和某种把这些事务一个接一个的执行之后的结果一样。最简单的一种调度实现就是真的把所有的事务进行排队，一个个的执行，显然这满足Serializability，问题就是性能。可以看出Serializability是与数据库事务相关的一个概念，一个事务包含多个读，写操作，这些操作由涉及到多个数据对象。</p>\n<ul>\n<li>Linearizability: 针对单个操作，单个数据对象而说的。属于CAP中C这个范畴。一个数据被更新后，能够立马被后续的读操作读到。</li>\n<li>Strict Serializability: 同时满足Serializability和Linearizability。</li>\n</ul>\n<p>举个最简单的例子：两个事务T1,T2，T1先开始，更新数据对象o，T1提交。接着T2开始，读数据对象o，提交。以下两种调度：</p>\n<ul>\n<li>T1,T2，满足Serializability，也满足Linearizability。</li>\n<li>T2,T1，满足Serializability，不满足Linearizability，因为T1之前更新的数据T2读不到。</li>\n</ul>\n<h3 id=\"_2-4-因果一致性-causal-consistency\"> 2.4 因果一致性 Causal consistency</h3>\n<p>因果一致性，属于弱一致性，因为在Causal consistency中，只对有因果关系的事件有顺序要求。</p>\n<p>没有因果一致性时会发生如下情形：</p>\n<ul>\n<li>夏侯铁柱在朋友圈发表状态“我戒指丢了”</li>\n<li>夏侯铁柱在同一条状态下评论“我找到啦”</li>\n<li>诸葛建国在同一条状态下评论“太棒了”</li>\n<li>远在美国的键盘侠看到“我戒指丢了”“太棒了”，开始喷诸葛建国</li>\n<li>远在美国的键盘侠看到“我戒指丢了”“我找到啦”“太棒了”，意识到喷错人了</li>\n</ul>\n<p>所以很多系统采用因果一致性系统来避免这种问题，例如微信的朋友圈就采用了因果一致性，可以参考：</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/1010129001-db65cd52447018fa_fix732.png\" alt=\"\" /></p>\n<h3 id=\"_2-5-最终一致性-eventual-consistency\"> 2.5 最终一致性 Eventual consistency</h3>\n<p>最终一致性这个词大家听到的次数应该是最多的，也是弱一致性，不过因为大多数场景下用户可以接受，应用也就比较广泛。</p>\n<p>理念：不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。</p>\n<p>简单说，就是在一段时间后，节点间的数据会最终达到一致状态。不过最终一致性的要求非常低，除了像gossip这样明确以最终一致性为卖点的协议外，包括redis主备、mongoDB、乃至mysql热备都可以算是最终一致性，甚至如果我记录操作日志，然后在副本故障了100天之后手动在副本上执行日志以达成一致，也算是符合最终一致性的定义。有人说最终一致性就是没有一致性，因为没人可以知道什么时候算是最终。</p>\n<p>上边提到的因果一致性可以理解为是最终一致性的变种, 如果进程 A 通知进程 B 它已经更新了一个数据项，那么进程 B 的后续访问将返回更新后的值，并且写操作将被保证取代前一次写入。和进程 A 没有因果关系的 C 的访问将遵循正常的最终一致性规则。</p>\n<p>最终一致其实分支很多，以下都是他的变种：</p>\n<ul>\n<li>Causal consistency（因果一致性）</li>\n<li>Read-your-writes consistency （读己所写一致性）</li>\n<li>Session consistency （会话一致性）</li>\n<li>Monotonic read consistency （单调读一致性）</li>\n<li>Monotonic write consistency （单调写一致性）</li>\n</ul>\n<p>后面要提到的 BASE理论中的 E，就是Eventual consistency最终一致</p>\n<h3 id=\"_2-6-acid理论\"> 2.6 ACID理论</h3>\n<p>ACID 是处理事务的原则，一般特指数据库的一致性约束，ACID 一致性完全与数据库规则相关，包括约束，级联，触发器等。在事务开始之前和事务结束以后，都必须遵守这些不变量，保证数据库的完整性不被破坏，因此 ACID 中的 C 表示数据库执行事务前后状态的一致性，防止非法事务导致数据库被破坏。比如银行系统 A 和 B 两个账户的余额总和为 100，那么无论 A, B 之间怎么转换，这个余额和是不变，前后一致的。</p>\n<p>这里的C代表的一致性：事务必须遵循数据库的已定义规则和约束，例如约束，级联和触发器。因此，任何写入数据库的数据都必须有效，并且完成的任何事务都会改变数据库的状态。没有事务可以创建无效的数据状态。注意，这与CAP定理中定义的“一致性”是不同的。</p>\n<p>ACID 可以翻译为酸，相对应的是碱，也就是 BASE，不过提BASE之前要先说下 CAP，毕竟 BASE是基于 CAP 提出的折中理论</p>\n<h3 id=\"_2-7-cap理论\"> 2.7 CAP理论</h3>\n<p>CAP 理论中的 C 也就是我们常说的分布式系统中的一致性，更确切地说，指的是分布式一致性中的一种: 也就是前面讲的线性一致性(Linearizability)，也叫做原子一致性(Atomic consistency)。</p>\n<p>CAP 理论也是个被滥用的词汇，关于 CAP 的正确定义可参考cap faq。很多时候我们会用 CAP 模型去评估一个分布式系统，但这篇文章会告诉你 CAP 理论的局限性，因为按照 CAP 理论，很多系统包括 MongoDB，ZooKeeper 既不满足一致性(线性一致性)，也不满足可用性(任意一个工作中的节点都要可以处理请求)，但这并不意味着它们不是优秀的系统，而是 CAP 定理本身的局限性(没有考虑处理延迟，容错等)。</p>\n<h3 id=\"_2-8-base理论\"> 2.8 BASE理论</h3>\n<p>正因为 CAP 中的一致性和可用性是强一致性和高可用，后来又有人基于 CAP 理论 提出了BASE 理论，即基本可用(Basically Available）、软状态(Soft State)、最终一致性(Eventual Consistency)。BASE的核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方法来使系统达到最终一致性。显然，最终一致性弱于 CAP 中的 线性一致性。很多分布式系统都是基于 BASE 中的”基本可用”和”最终一致性”来实现的，比如 MySQL/PostgreSQL Replication 异步复制。</p>\n<h4 id=\"_2-9-acid一致性与cap一致性的区别\"> 2.9 ACID一致性与CAP一致性的区别</h4>\n<p>ACID一致性是有关数据库规则，如果数据表结构定义一个字段值是唯一的，那么一致性系统将解决所有操作中导致这个字段值非唯一性的情况，如果带有一个外键的一行记录被删除，那么其外键相关记录也应该被删除，这就是ACID一致性的意思。</p>\n<p>CAP理论的一致性是保证同样一个数据在所有不同服务器上的拷贝都是相同的，这是一种逻辑保证，而不是物理，因为光速限制，在不同服务器上这种复制是需要时间的，集群通过阻止客户端查看不同节点上还未同步的数据维持逻辑视图。</p>\n<p>当跨分布式系统提供ACID时，这两个概念会混淆在一起，Google’s Spanner system能够提供分布式系统的ACID，其包含ACID+CAP设计，也就是两阶段提交 2PC+ 多副本同步机制（如 Paxos）</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/2202406457-8e83973265136d95_fix732.png\" alt=\"\" /></p>\n<h4 id=\"_2-10-acid-2pc-3pc-tcc-paxos-关系\"> 2.10 ACID/2PC/3PC/TCC/Paxos 关系</h4>\n<p>ACID 是处理事务的原则，限定了原子性、一致性、隔离性、持久性。ACID、CAP、BASE这些都只是理论，只是在实现时的目标或者折中，ACID 专注于分布式事务，CAP 和 BASE是分布式通用理论。</p>\n<p>解决分布式事务时有 2pc、3pc、tcc 等方式，通过增加协调者来进行协商，里面也有最终一致的思想。</p>\n<p>而Paxos协议与分布式事务并不是同一层面的东西，Paxos用于解决多个副本之间的一致性问题。比如日志同步，保证各个节点的日志一致性，选主的唯一性。简而言之，2PC用于保证多个数据分片上事务的原子性，Paxos协议用于保证同一个数据分片在多个副本的一致性，所以两者可以是互补的关系，不是替代关系。对于2PC协调者单点问题，可以利用Paxos协议解决，当协调者出问题时，选一个新的协调者继续提供服务。原理上Paxos和 2PC相似，但目的上是不同的。etcd 中也有事务的操作，比如迷你事务</p>\n<h3 id=\"_3-参考\"> 3.参考</h3>\n<ul>\n<li>https://zhuanlan.zhihu.com/p/27360832</li>\n<li>https://www.itcodemonkey.com/article/3932.html</li>\n<li>https://zookeeper.apache.org/doc/r3.4.9/zookeeperProgrammers.html#ch_zkGuarantees</li>\n<li>https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/</li>\n<li>https://feilengcui008.github.io/post/raft%E8%AF%BB%E8%AF%B7%E6%B1%82/</li>\n<li>http://codefever.github.io/2019/09/17/raft-linearizable-read/</li>\n<li>https://blog.csdn.net/chao2016/article/details/81149674</li>\n<li>https://lentil1016.cn/consistencies-and-raft/</li>\n<li>https://www.jdon.com/artichect/acid-cap.html</li>\n<li>https://en.wikipedia.org/wiki/Sequential_consistency</li>\n<li>https://en.wikipedia.org/wiki/Linearizability</li>\n<li>https://en.wikipedia.org/wiki/Serializability</li>\n</ul>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Sequential_consistency.svg.png",
      "date_published": "2022-11-14T04:22:09.000Z",
      "date_modified": "2022-11-14T05:20:28.000Z",
      "authors": [
        {
          "name": "徐亚松"
        }
      ],
      "tags": []
    },
    {
      "title": "Kafka",
      "url": "https://www.moremind.cn/md/middleware/message/kafka/",
      "id": "https://www.moremind.cn/md/middleware/message/kafka/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Kafka"
      ]
    },
    {
      "title": "RabbitMQ",
      "url": "https://www.moremind.cn/md/middleware/message/rabbitmq/",
      "id": "https://www.moremind.cn/md/middleware/message/rabbitmq/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "RabbitMQ"
      ]
    },
    {
      "title": "RocketMQ",
      "url": "https://www.moremind.cn/md/middleware/message/rocketmq/",
      "id": "https://www.moremind.cn/md/middleware/message/rocketmq/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "RocketMQ"
      ]
    },
    {
      "title": "spring 知识图谱",
      "url": "https://www.moremind.cn/md/spring/spring-framework/",
      "id": "https://www.moremind.cn/md/spring/spring-framework/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Spring"
      ]
    },
    {
      "title": "Spring AOP详解",
      "url": "https://www.moremind.cn/md/spring/spring-framework/spring-aop/",
      "id": "https://www.moremind.cn/md/spring/spring-framework/spring-aop/",
      "content_html": "",
      "date_published": "2021-03-26T00:00:00.000Z",
      "date_modified": "2022-01-17T15:11:57.000Z",
      "authors": [
        {
          "name": "moremind"
        }
      ],
      "tags": [
        "Spring"
      ]
    },
    {
      "title": "Spring DI详解",
      "url": "https://www.moremind.cn/md/spring/spring-framework/spring-di/",
      "id": "https://www.moremind.cn/md/spring/spring-framework/spring-di/",
      "content_html": "",
      "date_published": "2021-03-26T00:00:00.000Z",
      "date_modified": "2022-01-17T15:11:57.000Z",
      "authors": [
        {
          "name": "moremind"
        }
      ],
      "tags": [
        "Spring"
      ]
    },
    {
      "title": "Spring IOC详解",
      "url": "https://www.moremind.cn/md/spring/spring-framework/spring-ioc/",
      "id": "https://www.moremind.cn/md/spring/spring-framework/spring-ioc/",
      "content_html": "",
      "date_published": "2021-03-26T00:00:00.000Z",
      "date_modified": "2022-01-17T15:11:57.000Z",
      "authors": [
        {
          "name": "moremind"
        }
      ],
      "tags": [
        "Spring"
      ]
    },
    {
      "title": "springboot",
      "url": "https://www.moremind.cn/md/spring/springboot/",
      "id": "https://www.moremind.cn/md/spring/springboot/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "SpringBoot"
      ]
    },
    {
      "title": "springcloud",
      "url": "https://www.moremind.cn/md/spring/springcloud/",
      "id": "https://www.moremind.cn/md/spring/springcloud/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "SpringCloud"
      ]
    },
    {
      "title": "springwebflux",
      "url": "https://www.moremind.cn/md/spring/springwebflux/",
      "id": "https://www.moremind.cn/md/spring/springwebflux/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-14T09:08:36.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "算法",
      "url": "https://www.moremind.cn/md/tools/docker/",
      "id": "https://www.moremind.cn/md/tools/docker/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-14T10:01:55.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Docker"
      ]
    },
    {
      "title": "Git基本简介",
      "url": "https://www.moremind.cn/md/tools/git/",
      "id": "https://www.moremind.cn/md/tools/git/",
      "content_html": "\n<h1 id=\"git与svn的基本介绍\"> git与svn的基本介绍</h1>\n<h2 id=\"git与svn\"> git与svn</h2>\n<h3 id=\"svn\"> svn</h3>\n<p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。一般公司用svn的比较多，至于原因,嘿嘿嘿....</p>\n<h3 id=\"git\"> git</h3>\n<p>git是一个分布式版本控制系统，没有中心服务器，每个人的电脑就是一个版本库，你的电脑上的Gitrepository就是你的版本库，那多人之间是如何合作的呢？这样，</p>\n<blockquote>\n<p>A在A的电脑上修改了A.Gitrepository里面的文件,而B在B的电脑上修改了clone过来的A.Gitrepository，你们两个只要把各自的修改推送给对方就行了，这就是为什么你就是没有网络也能使用版本控制。</p>\n</blockquote>\n<h1 id=\"下载\"> 下载</h1>\n<h2 id=\"网址\"> 网址</h2>\n<p><a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener noreferrer\">git-download</a></p>\n<h2 id=\"选择你的os版本即可\"> 选择你的OS版本即可</h2>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git.png\" alt=\"git\" /></p>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git.png",
      "date_published": "2022-01-14T10:01:55.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "git 进阶操作命令",
      "url": "https://www.moremind.cn/md/tools/git/git-advanced-command/",
      "id": "https://www.moremind.cn/md/tools/git/git-advanced-command/",
      "content_html": "<h1 id=\"工作区与暂存区\"> 工作区与暂存区</h1>\n<h2 id=\"工作区\"> 工作区</h2>\n<div><p>提示</p>\n<p>工作区就是在你电脑上的Repository下的某一个工作目录，比如：F:\\Repository\\test01这个目录。test01这个目录就是工作区，或者你新建的任何一个目录，都是工作区（.git隐藏目录下并非工作区）</p>\n</div>\n\n<h2 id=\"暂存区\"> 暂存区</h2>\n<p>Repository目录下有一个（.git隐藏目录），这个就是控制版本的版本控制库。</p>\n<div><p>提示</p>\n<p>（.git隐藏目录）存储了Git为我们创建的各种信息，包括版本信息，暂存区（这是最重要的），还有分支信息（Git已经为我们创建了一个master分支），还有一些配置信息等。</p>\n</div>\n<p>接下来在Repository目录下新建一个test.txt文件，在里面写入123456，然后进行下面的这些操作。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add_commit3.png\" alt=\"git_add_commit3\" /></p>\n<p>继续在test.txt中添加一行数据，然后使用git status查看信息。git会提示你有文件需要git add 并且git commit。</p>\n<p>继续下面的操作！---把同一个文件提交到同一个暂存区中，并且使用commit提交到一个分支中。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_status_add_commit.png\" alt=\"git_status_add_commit\" /></p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_status_commit.png\" alt=\"git_status_commit\" /></p>\n<p>这次将所有文件提交到一个分支（master分支）中了，可以使用git log查看你提交的所有分支。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_log4.png\" alt=\"git_log4\" /></p>\n<p>这样看起来很碍眼，而且版本较多的话，看起来的确不方便，所有推荐使用</p>\n<div><pre><code>git log --pretty=oneline\n</code></pre>\n<div><span>1</span><br></div></div><p>接下来，你可以使用<a href=\"https://finen.top/git-basic-command/#more\" target=\"_blank\" rel=\"noopener noreferrer\">上一篇git基础教程</a>讲过的方法对版本进行操作。基本命令请点击链接去查看...</p>\n<h1 id=\"撤销修改与删除文件操作\"> 撤销修改与删除文件操作</h1>\n<h2 id=\"撤销修改\"> 撤销修改</h2>\n<h3 id=\"最简单的方法-手动修改\"> 最简单的方法：手动修改</h3>\n<p>在你记得你修改了那些地方的情况下，直接手动撤销那些你不要的东西即可。</p>\n<h3 id=\"使用之前所使用的命令进行版本回滚\"> 使用之前所使用的命令进行版本回滚</h3>\n<p>具体命令如下：</p>\n<div><pre><code>git log --pretty=oneline\n\ngit reset --hard HEAD^\n\ngit reset --hard HEAD~*\n\ngit reflog\n\ngit reset --hard 版本号\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>你可以使用这些办法进行你所需要的回滚。</p>\n<h3 id=\"使用git-checkout-test-txt-一点要带文件名-不然会创建分支\"> 使用git checkout -- test.txt <font color=\"red\">一点要带文件名</font>，不然会创建分支！</h3>\n<p>git checkout --test.txt 分为两种状态</p>\n<div><pre><code>git checkout --test.txt\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<ol>\n<li>test.txt文件修改后，你没有使用git add命令对其进行提交到暂存区。使用git checkout --test.txt会回退到之前的一个版本。<strong>相当于回滚到你最后提交的那个版本。而刚刚修改的内容也将全部丢失。</strong></li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>另一种情况就是你已经使用git add提交文件到暂存区了。那这样使用git checkout --test.txt 就会<strong>保存已经在暂存区的内容。而没有写入暂存区的内容则会全部丢失。</strong></li>\n</ol>\n</blockquote>\n<p>接下来使用git进行操作查看。</p>\n<p>首先在test.txt文件中添加一行数据 654321，然后使用git add命令提交到暂存区。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add2.png\" alt=\"git_add2\" /></p>\n<p>接着再在test.txt文件中添加一行数据 222222，然后我们不使用git add命令提交文件到暂存区。</p>\n<p>最后我们使用git checkout --test.txt命令撤销修改，在查看文件。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_checkout.png\" alt=\"git_checkout\" /></p>\n<p>跟上面的结论是一样的。</p>\n<h2 id=\"删除文件\"> 删除文件</h2>\n<h3 id=\"rm-命令-linux下的软删除命令\"> rm 命令（linux下的软删除命令）</h3>\n<p>假如有人提交了tesxt02.txt的文件，但是这个文件缺失不需要的，我们可以使用rm test02.txt，然后在git commit就可以了。</p>\n<div><pre><code>新建一个test02.txt 文件\ngit add test02.txt\ngit commit -m &quot;提交test02文件&quot;\nrm test02.txt\ngit commit -m &quot;删除test02文件&quot;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add_commit4.png\" alt=\"git_commit4\" /></p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/rm.png\" alt=\"rm\" /></p>\n<p>说明已经删除了文件并且已经commit了，当然假如你删除错误的话，你也可以回滚版本。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_reflog2.png\" alt=\"git_reflog\" /></p>\n<p>假如你已经使用rm test02.txt命令，但是却没有使用git commit命令呢？又改如何恢复文件？你可以使用下面的命令:</p>\n<div><pre><code>git checkout --test02.txt\n</code></pre>\n<div><span>1</span><br></div></div><p>rm之前：</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_rm.png\" alt=\"rm_before\" /></p>\n<p>rm 之后：</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_rm2.png\" alt=\"git_rm_after\" /></p>\n<p>然后我们不使用git commit命令，使用git checkout -- test02.txt</p>\n<p>使用git checkout -- test02.txt之后</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_rm_after.png\" alt=\"git_check_out\" /></p>\n<p>文件又恢复了，恢复多个文件也是同理。</p>\n<hr>\n<div><pre><code> 下面会涉及删除与撤销的操作!请继续浏览！\n</code></pre>\n</div><hr>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add_commit3.png",
      "date_published": "2018-03-28T00:00:00.000Z",
      "date_modified": "2022-01-14T10:01:55.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "git 基本操作命令",
      "url": "https://www.moremind.cn/md/tools/git/git-basic-command/",
      "id": "https://www.moremind.cn/md/tools/git/git-basic-command/",
      "content_html": "<h1 id=\"git基本命令\"> git基本命令</h1>\n<p>0.你必须安装了git才能继续往下看。\n1.新建一个目录(在你磁盘空闲较多的地方，新建一个目录(名称Repository))===&gt;这个Repository就是上面说的你的本地仓库，然后右键选择Git Bash(Git 命令行)，在目录下输入以下命令：</p>\n<div><pre><code>git config <span>-</span><span>-</span>global user.name \"username\"\n\ngit config <span>-</span><span>-</span>global user.email \"youremail\"\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>这里的<font color=\"red\">username</font>就是你刚刚注册的用户名，<font color=\"red\">email</font>就是刚刚注册邮箱。</p>\n</blockquote>\n<h2 id=\"git-init\"> git init</h2>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_init.png\" alt=\"git_init\" /></p>\n<p>此时，你就创建了一个本地仓库了。可以在你的本地查看一下：</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_intit2.png\" alt=\"git\" /></p>\n<h2 id=\"git-add-把项目提交到git仓库\"> git add （把项目提交到git仓库）</h2>\n<p>新建一个demo.txt的文件，并且在里面写入123456789</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add.png\" alt=\"git_add\" /></p>\n<p>这样就说明你已经把文件提交到文件暂存区了，接下来使用下一个命令你就可以在本地仓库看到了。</p>\n<h2 id=\"git-commit\"> git commit</h2>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_commit.png\" alt=\"git_commit\" /></p>\n<blockquote>\n<p>这里的<font color=\"red\"> -m</font>就是你提交的注释，记得以后写一定要使用注释！这是一个好习惯！</p>\n</blockquote>\n<h2 id=\"git-status-查看状态\"> git status ---查看状态</h2>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_status.png\" alt=\"git_status\" /></p>\n<blockquote>\n<p>没有什么东西需要提交，别急，我们在刚刚的demo.txt中<font color =\"red\">追加一个0000</font>,记得保存文件。</p>\n</blockquote>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_status_1.png\" alt=\"git_status2\" /></p>\n<blockquote>\n<p>修改之后就已经有了文件修改的信息，并且git提示你需要commit！所以你需要使用上面的git commit 提交！</p>\n</blockquote>\n<h2 id=\"git-diff\"> git diff</h2>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_diff.png\" alt=\"git_diff\" /></p>\n<blockquote>\n<p>git diff就是比对文件，红色的是告诉你，那是原来的，绿色的就是告诉添加了信息。</p>\n</blockquote>\n<blockquote>\n<p>之后你就可以放心的提交你的版本了。</p>\n</blockquote>\n<p><strong>你需要执行git add， git commit -m &quot;xxxx&quot;</strong>，必须通过add提交到文件暂存区。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add_commit.png\" alt=\"git_add_commit1\" /></p>\n<h1 id=\"版本控制-回退\"> 版本控制---回退</h1>\n<h2 id=\"git-log\"> git log</h2>\n<p>在使用git的时候一定要会使用日志功能。</p>\n<p>首先我们在demo.txt中添加一行数据<font color=\"red\">0000123456789</font>,然后git add ，git commit.</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add_commit2.png\" alt=\"git_diff_add_commit\" /></p>\n<p>接下来使用git log打印日志</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_log.png\" alt=\"git_log\" /></p>\n<h2 id=\"版本回滚-git-reset-hard-head\"> 版本回滚---git reset --hard HEAD^</h2>\n<p>上面提到使用git log打印所有版本，其实有更简单的办法。</p>\n<div><pre><code>git log --pretty=oneline\n</code></pre>\n<div><span>1</span><br></div></div><p>这个可以自己去尝试哟，这个只会提示你的<font color=\"red\">版本号</font>跟<font color=\"red\">提交的信息</font>。</p>\n<div><pre><code>git reset --hard HEAD^\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_hard.png\" alt=\"git_hard\" /></p>\n<blockquote>\n<p>现在可以打开你的demo.txt看看里面还有什么内容了。是不是少了最后添加的一行数据，只有一行数据了。回滚到添加0000的版本了。</p>\n</blockquote>\n<p><strong>超级回滚：</strong></p>\n<p>你需要回滚50个版本，总不能输入50个^号，所以有下面这种更简单的办法。</p>\n<div><pre><code>git reset --hard HEAD~50\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"cat命令\"> cat命令</h2>\n<p>使用cat查看内容。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/cat.png\" alt=\"cat\" /></p>\n<p>然后你可以使用git log 查看一下存在的版本</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_log3.png\" alt=\"git_log3\" /></p>\n<p>加入你要回滚到添加了<font color=\"red\">0000123456789</font>的版本该怎么办呢？使用下一个命令+下下个命令！！！</p>\n<h2 id=\"git-reflog\"> git reflog</h2>\n<blockquote>\n<p>这个命令是告诉你所有操作的版本信息</p>\n</blockquote>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_reflog.png\" alt=\"git_reflog\" /></p>\n<p>看到版本号了---a0ca311，接下来就可以使用这个版本号进行回滚到添加<font color=\"red\">0000123456789</font>的那个版本了。</p>\n<h2 id=\"git-reset-hard-版本号\"> git reset --hard 版本号</h2>\n<p>下面是回滚到我的版本</p>\n<div><pre><code>git reset --hard a0ca311\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_hard.png\" alt=\"git_hard\" /></p>\n<p>接下来，打开你的demo.txt文档看一下是否已经有<font color=\"red\">0000123456789</font>了。</p>\n<p>或者你可以使用以下命令</p>\n<div><pre><code>cat demo.txt\n</code></pre>\n<div><span>1</span><br></div></div><hr>\n<div><pre><code> 下面会涉及删除与撤销的操作!请继续浏览！\n</code></pre>\n</div><hr>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_init.png",
      "date_published": "2018-03-28T00:00:00.000Z",
      "date_modified": "2022-01-14T10:01:55.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "git 分支操作命令",
      "url": "https://www.moremind.cn/md/tools/git/git-branch-command/",
      "id": "https://www.moremind.cn/md/tools/git/git-branch-command/",
      "content_html": "<h1 id=\"git分支操作\"> git分支操作</h1>\n<h2 id=\"创建与合并分支\"> 创建与合并分支</h2>\n<p>在版本回滚与更新中，git都是用master分支作为主线，通过时间顺序进行更新或者回滚。</p>\n<h3 id=\"创建分支\"> 创建分支</h3>\n<div><pre><code>git checkout -b dev \n==（相当于）\ngit branch dev\ngit checkout dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>查看分支信息：</p>\n<div><pre><code>git branch\n</code></pre>\n<div><span>1</span><br></div></div>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_branch.png\" alt=\"git_branch\" /></p>\n<p>现在已经在dev分支目录下，接下来可以在demo.txt中添加信息，我们添加一行数据：1111111111111</p>\n<p>此时，我们在dev目录下添加内容，并且提交到暂存区，然后commit。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_branch3.png\" alt=\"git_branch\" /></p>\n<p>接着，我们将目前分支切换到master主分支，查看文件新添加的内容是否存在。使用以下命令：</p>\n<div><pre><code>git checkout master\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_branch4.png\" alt=\"git_branch4\" /></p>\n<p>然后，发现master分支上并没有我们想要看到的内容，所以我们需要合并两个分支。</p>\n<h3 id=\"合并分支\"> 合并分支</h3>\n<div><pre><code>git merge 分支名\n</code></pre>\n<div><span>1</span><br></div></div><p>在master分之下合并分dev分支。使用以下命令：</p>\n<div><pre><code>git merger dev\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_merge.png\" alt=\"git_merge\" /></p>\n<p>合并完成后即可删除没有用的额分支了，使用以下命令进行删除分支：</p>\n<div><pre><code>git branch -d dev\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_delete.png\" alt=\"git_branch_delete\" /></p>\n<p>所有命令总结：</p>\n<div><pre><code>查看分支：git branch\n创建分支：git branch name\n切换分支：git checkout name\n创建+切换分支：git checkout -b name\n合并某个分支到当前分支：git merge name\n删除某个分支：git branch -d name\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"处理分支矛盾\"> 处理分支矛盾</h3>\n<p>新建一个分支，并且other中添加数据：2222222222222，并且检查文件。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_branch_other.png\" alt=\"git_branch_other\" /></p>\n<p>切换分支到master之中，并且master分支中增加内容：3333333333333，在增加之前使用cat命令，查看master坟之中是否存在2222222222222，增加后是否存在3333333333333。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_checkout1.png\" alt=\"git_checkout2\" /></p>\n<p>master分支数据如上，接下来我们继续合并分支。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_merge2.png\" alt=\"git_merge\" /></p>\n<p>由于我之前在master分支写了一个2222222的信息，，所以这有一个2222222222222222222/33333333333333333这样的信息。不过这样的错误信息也不影响分支是错误。<font color=\"red\">Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存。修改后就是上面的最后一个图。</font></p>\n<p>然后我们就可以git log查看commit后的信息，在此我就截图了哈。</p>\n<h3 id=\"分支策略\"> 分支策略</h3>\n<div><pre><code>1.创建一个dev分支。\n2.修改demo.txt内容。\n3.添加到暂存区。\n4.切换回主分支(master)。\n5.合并dev分支，使用命令 git merge –no-ff -m &quot;注释&quot; dev\n6.查看历史记录\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>具体命令如下：</p>\n<div><pre><code>git checkout -b dev\n在demo.txt文件中添加数据4444444444444\ngit add demo.txt\ngit commit -m &quot;add merge&quot;\ngit merge --no-ff -m &quot;merge with no-ff&quot; dev\ngit log 或者git log --graph --pretty=oneline --abbrev-commit\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_dev.png\" alt=\"git_dev\" /></p>\n<p><strong>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</strong></p>\n<h2 id=\"bug分支\"> Bug分支</h2>\n<p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p>\n<p>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。命令如下：</p>\n<div><pre><code>git checkout -b dev \n修改demo.txt文件添加数据：5555555555555\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_branch5.png\" alt=\"git_branch5\" /></p>\n<p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。</p>\n<p>隐藏分支：</p>\n<div><pre><code>git stash\ngit status\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_stash.png\" alt=\"git_stash\" /></p>\n<p>首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_bug.png\" alt=\"git_bug\" /></p>\n<p>修改后合并分支，然后删除bug分支即可。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_bug2.png\" alt=\"git_bug2\" /></p>\n<p>接着，我们继续回到dev分支下：</p>\n<div><pre><code>git checkout dev\ngit status\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>发现并没有文件，是因为stash隐藏了，所以我们需要从stash恢复。恢复命令如下：</p>\n<div><pre><code>git stash list\ngit stash apply\ngit stash drop\ncat demo.txt\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>或者：</p>\n<div><pre><code>git stash list\ngit stash pop\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_stash3.png\" alt=\"git_stash\" /></p>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_branch.png",
      "date_published": "2018-03-28T00:00:00.000Z",
      "date_modified": "2022-01-14T10:01:55.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "git多人合作开发操作命令",
      "url": "https://www.moremind.cn/md/tools/git/git-cooperate-develop-command/",
      "id": "https://www.moremind.cn/md/tools/git/git-cooperate-develop-command/",
      "content_html": "<h1 id=\"git远程分支操作\"> git远程分支操作</h1>\n<h2 id=\"查看远程仓库信息\"> 查看远程仓库信息</h2>\n<div><pre><code>git remote\ngit remote -v\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>\n<h2 id=\"推送分支\"> 推送分支</h2>\n<div><pre><code>git push origin master\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_remote3.png\" alt=\"git_remote\" /></p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_push.png\" alt=\"git_push\" /></p>\n<p>也可以推送到其他分支：</p>\n<div><pre><code>git push origin dev\n</code></pre>\n<div><span>1</span><br></div></div><p>那么一般情况下，那些分支要推送呢？</p>\n<blockquote>\n<ol>\n<li>master分支是主分支，因此要时刻与远程同步。</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</li>\n</ol>\n</blockquote>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_push2.png\" alt=\"git_push2\" /></p>\n<h2 id=\"抓取分支\"> 抓取分支</h2>\n<p>多人协作时，大家都会往master分支上推送各自的修改。新建一个目录名字叫testgit3。</p>\n<p>现在我们的伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_clone2.png\" alt=\"git_clone2\" /></p>\n<div><pre><code>git checkout –b dev \ngit reset --hard origin/dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>在dev下重置起点，即可，git checkout -b dev origin/dev 错误的。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_checkout3.png\" alt=\"git\" /></p>\n<p>接下来在demo.txt的文件中添加数据6666666666666数据，然后提交到分支即可。</p>\n<div><pre><code>git add demo.txt\ngit commit -m &quot;添加666的数据&quot;\ngit pusu origin dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_push4.png\" alt=\"git_push3\" /></p>\n<p>小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改,添加了数据6666666666666，也试图推送到远程库:</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_push_dev.png\" alt=\"git_push_dev\" /></p>\n<p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</p>\n<div><pre><code>git pull\ngit branch --set-upstream dev origin/dev\ngit pull\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后此时会出现冲突，所以需要解决冲突，使用前面讲过的分支策略进行解决。然后在执行：</p>\n<div><pre><code>git add demo.txt\ngit commit -m &quot;****&quot;\ngit push origin dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>多人协作工作模式一般是这样的：</p>\n<ol>\n<li>\n<p>首先，可以试图用git push origin branch-name推送自己的修改.</p>\n</li>\n<li>\n<p>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。</p>\n</li>\n<li>\n<p>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。</p>\n</li>\n</ol>\n<h2 id=\"推荐阅读\"> 推荐阅读</h2>\n<p><strong><a href=\"https://www.gitbook.com/book/bingohuang/progit2/details\" target=\"_blank\" rel=\"noopener noreferrer\">ProGit中文版</a></strong></p>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_remote3.png",
      "date_published": "2018-03-28T00:00:00.000Z",
      "date_modified": "2022-01-14T10:01:55.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "git 远端操作命令",
      "url": "https://www.moremind.cn/md/tools/git/git-remote-command/",
      "id": "https://www.moremind.cn/md/tools/git/git-remote-command/",
      "content_html": "<h1 id=\"git远程仓库-github\"> git远程仓库-github</h1>\n<h2 id=\"配置远程仓库-创建ssh-key-检查用户目录\"> 配置远程仓库-创建SSH Key-检查用户目录</h2>\n<p>检查用户目录下有没有id_rsa 和 id_rsa.pub，如果没有这两个文件就使用下面的这个命令生成密钥。</p>\n<div><pre><code>ssh-keygen -t rsa –C &quot;youremail@example.com&quot;\n</code></pre>\n<div><span>1</span><br></div></div>\n<h2 id=\"在github中设置ssh\"> 在github中设置ssh</h2>\n<p>登录github，打开settings的SSH and GPG keys，选择New SSH key就可以填充SSH key的相关信息。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/ssh.png\" alt=\"ssh\" /></p>\n<p>填写title，然后将id_rsa.pub里面的密钥复制到Key中，然后点击Add SSH key即可。</p>\n<h2 id=\"选择new-repository-添加仓库\"> 选择New Repository(添加仓库)</h2>\n<p>新建一个目录TestGit,将所有文件复制到TestGit目录下。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_1.png\" alt=\"git_1\" /></p>\n<p>然年使用命令创建一个一个本地仓库</p>\n<div><pre><code>git init\ngit add demo.txt\ngit add test.txt\ngit test02.txt\n\ngit commit -m &quot;新建文件&quot;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_remote.png\" alt=\"git_remote\" /></p>\n<p>现在把你的目录推送到TestGit远程仓库中</p>\n<div><pre><code>git remote add origin https://github.com/hirCodd/TestGit.git\n\ngit push -u origin master\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_upload.png\" alt=\"git_3\" /></p>\n<p>由于远程库是空的，我们第一次推送master分支时，加上了<font color=\"red\"> –u参数</font>，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。使用</p>\n<div><pre><code>git push origin master\n</code></pre>\n<div><span>1</span><br></div></div><p>现在查看远端仓库，如下，已经有相关的文件了。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_2.png\" alt=\"git_3\" /></p>\n<p>以后你修改了bug，就可以使用git push origin master推送到github，这样你就拥有分布式版本仓库了。</p>\n<h1 id=\"从远端仓库克隆\"> 从远端仓库克隆</h1>\n<p>使用以下命令：</p>\n<div><pre><code>git clone url\n</code></pre>\n<div><span>1</span><br></div></div><p>首先现在远端创建一个仓库</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_clone.png\" alt=\"git_clone\" /></p>\n<p>使用命令即可从远端clone文件下来</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_clone2.png\" alt=\"git_clone2\" /></p>\n<hr>\n<div><pre><code> 下面会涉及删除与撤销的操作!请继续浏览！\n</code></pre>\n</div><hr>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/ssh.png",
      "date_published": "2018-03-28T00:00:00.000Z",
      "date_modified": "2022-01-14T10:01:55.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "算法",
      "url": "https://www.moremind.cn/md/tools/k8s/",
      "id": "https://www.moremind.cn/md/tools/k8s/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-14T10:01:55.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Kubernates"
      ]
    },
    {
      "title": "算法",
      "url": "https://www.moremind.cn/md/tools/linux/",
      "id": "https://www.moremind.cn/md/tools/linux/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-14T10:01:55.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "Maven",
      "url": "https://www.moremind.cn/md/tools/maven/",
      "id": "https://www.moremind.cn/md/tools/maven/",
      "content_html": "<h1 id=\"maven知识点\"> Maven知识点</h1>\n<h2 id=\"mavan打包工具的使用\"> Mavan打包工具的使用</h2>\n",
      "date_published": "2022-01-21T15:41:02.000Z",
      "date_modified": "2022-01-21T16:14:37.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Maven"
      ]
    },
    {
      "title": "Maven对Springboot项目配置文件、依赖分离打包",
      "url": "https://www.moremind.cn/md/tools/maven/maven-assembly/",
      "id": "https://www.moremind.cn/md/tools/maven/maven-assembly/",
      "content_html": "<h1 id=\"maven对springboot项目配置文件、依赖分离打包\"> Maven对Springboot项目配置文件、依赖分离打包</h1>\n<h2 id=\"_1-使用maven-assembly-plugin进行配置分离\"> 1.使用maven-assembly-plugin进行配置分离</h2>\n<blockquote>\n<p>assembly.xml配置文件</p>\n</blockquote>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>assembly</span><span>></span></span>\n    <span>&lt;!-- 可自定义，这里指定的是项目环境 --></span>\n    <span>&lt;!-- xxx.tar.gz  --></span>\n    <span><span><span>&lt;</span>id</span><span>></span></span>${name}<span><span><span>&lt;/</span>id</span><span>></span></span>\n\n    <span>&lt;!-- 打包的类型，如果有N个，将会打N个类型的包 --></span>\n    <span><span><span>&lt;</span>formats</span><span>></span></span>\n        <span><span><span>&lt;</span>format</span><span>></span></span>tar.gz<span><span><span>&lt;/</span>format</span><span>></span></span>\n        <span><span><span>&lt;</span>format</span><span>></span></span>zip<span><span><span>&lt;/</span>format</span><span>></span></span>\n    <span><span><span>&lt;/</span>formats</span><span>></span></span>\n\n    <span><span><span>&lt;</span>includeBaseDirectory</span><span>></span></span>true<span><span><span>&lt;/</span>includeBaseDirectory</span><span>></span></span>\n\n    <span><span><span>&lt;</span>fileSets</span><span>></span></span>\n        <span>&lt;!-- 配置文件打包-打包至config目录下 --></span>\n        <span><span><span>&lt;</span>fileSet</span><span>></span></span>\n            <span><span><span>&lt;</span>directory</span><span>></span></span>src/main/resources/<span><span><span>&lt;/</span>directory</span><span>></span></span>\n            <span><span><span>&lt;</span>outputDirectory</span><span>></span></span>config<span><span><span>&lt;/</span>outputDirectory</span><span>></span></span>\n            <span><span><span>&lt;</span>fileMode</span><span>></span></span>0644<span><span><span>&lt;/</span>fileMode</span><span>></span></span>\n            <span><span><span>&lt;</span>includes</span><span>></span></span>\n                <span><span><span>&lt;</span>include</span><span>></span></span>application.yml<span><span><span>&lt;/</span>include</span><span>></span></span>\n                <span><span><span>&lt;</span>include</span><span>></span></span>*.xml<span><span><span>&lt;/</span>include</span><span>></span></span>\n                <span><span><span>&lt;</span>include</span><span>></span></span>*.properties<span><span><span>&lt;/</span>include</span><span>></span></span>\n            <span><span><span>&lt;/</span>includes</span><span>></span></span>\n        <span><span><span>&lt;/</span>fileSet</span><span>></span></span>\n        <span>&lt;!-- 启动文件目录 --></span>\n        <span><span><span>&lt;</span>fileSet</span><span>></span></span>\n            <span><span><span>&lt;</span>directory</span><span>></span></span>${basedir}/src/main/bin<span><span><span>&lt;/</span>directory</span><span>></span></span>\n            <span><span><span>&lt;</span>outputDirectory</span><span>></span></span>bin<span><span><span>&lt;/</span>outputDirectory</span><span>></span></span>\n            <span><span><span>&lt;</span>fileMode</span><span>></span></span>0755<span><span><span>&lt;/</span>fileMode</span><span>></span></span>\n            <span><span><span>&lt;</span>includes</span><span>></span></span>\n                <span><span><span>&lt;</span>include</span><span>></span></span>**.sh<span><span><span>&lt;/</span>include</span><span>></span></span>\n                <span><span><span>&lt;</span>include</span><span>></span></span>**.bat<span><span><span>&lt;/</span>include</span><span>></span></span>\n            <span><span><span>&lt;/</span>includes</span><span>></span></span>\n        <span><span><span>&lt;/</span>fileSet</span><span>></span></span>\n    <span><span><span>&lt;/</span>fileSets</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependencySets</span><span>></span></span>\n        <span><span><span>&lt;</span>dependencySet</span><span>></span></span>\n            <span>&lt;!-- 依赖库 --></span>\n            <span><span><span>&lt;</span>outputDirectory</span><span>></span></span>lib<span><span><span>&lt;/</span>outputDirectory</span><span>></span></span>\n            <span><span><span>&lt;</span>scope</span><span>></span></span>runtime<span><span><span>&lt;/</span>scope</span><span>></span></span>\n            <span><span><span>&lt;</span>fileMode</span><span>></span></span>0755<span><span><span>&lt;/</span>fileMode</span><span>></span></span>\n            <span><span><span>&lt;</span>excludes</span><span>></span></span>\n                <span><span><span>&lt;</span>exclude</span><span>></span></span>${project.groupId}:${project.artifactId}<span><span><span>&lt;/</span>exclude</span><span>></span></span>\n            <span><span><span>&lt;/</span>excludes</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependencySet</span><span>></span></span>\n        <span><span><span>&lt;</span>dependencySet</span><span>></span></span>\n            <span><span><span>&lt;</span>outputDirectory</span><span>></span></span>boot<span><span><span>&lt;/</span>outputDirectory</span><span>></span></span>\n            <span><span><span>&lt;</span>fileMode</span><span>></span></span>0755<span><span><span>&lt;/</span>fileMode</span><span>></span></span>\n            <span><span><span>&lt;</span>includes</span><span>></span></span>\n                <span><span><span>&lt;</span>include</span><span>></span></span>${project.groupId}:${project.artifactId}<span><span><span>&lt;/</span>include</span><span>></span></span>\n            <span><span><span>&lt;/</span>includes</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependencySet</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependencySets</span><span>></span></span>\n<span><span><span>&lt;/</span>assembly</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h2 id=\"_2-pom-xml文件build节点的配置\"> 2.pom.xml文件build节点的配置</h2>\n<blockquote>\n<p>pom.xml配置文件</p>\n</blockquote>\n<div><pre><code>    <span><span><span>&lt;</span>build</span><span>></span></span>\n        <span>&lt;!-- 打包后的启动jar名称 --></span>\n        <span><span><span>&lt;</span>finalName</span><span>></span></span>app-name<span><span><span>&lt;/</span>finalName</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span>&lt;!-- 用于排除jar中依赖包 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>layout</span><span>></span></span>ZIP<span><span><span>&lt;/</span>layout</span><span>></span></span>\n                    <span><span><span>&lt;</span>includes</span><span>></span></span>\n                        <span>&lt;!-- 项目启动jar包中排除依赖包 --></span>\n                        <span><span><span>&lt;</span>include</span><span>></span></span>\n                            <span><span><span>&lt;</span>groupId</span><span>></span></span>non-exists<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                            <span><span><span>&lt;</span>artifactId</span><span>></span></span>non-exists<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                        <span><span><span>&lt;/</span>include</span><span>></span></span>\n                    <span><span><span>&lt;/</span>includes</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- 将依赖cp到lib目录下 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-dependency-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>3.1.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;</span>executions</span><span>></span></span>\n                    <span><span><span>&lt;</span>execution</span><span>></span></span>\n                        <span><span><span>&lt;</span>phase</span><span>></span></span>prepare-package<span><span><span>&lt;/</span>phase</span><span>></span></span>\n                        <span><span><span>&lt;</span>goals</span><span>></span></span>\n                            <span><span><span>&lt;</span>goal</span><span>></span></span>copy-dependencies<span><span><span>&lt;/</span>goal</span><span>></span></span>\n                        <span><span><span>&lt;/</span>goals</span><span>></span></span>\n                        <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                            <span>&lt;!--依赖输出目录--></span>\n                            <span><span><span>&lt;</span>outputDirectory</span><span>></span></span>target/lib<span><span><span>&lt;/</span>outputDirectory</span><span>></span></span>\n                            <span><span><span>&lt;</span>overWriteReleases</span><span>></span></span>false<span><span><span>&lt;/</span>overWriteReleases</span><span>></span></span>\n                            <span><span><span>&lt;</span>overWriteSnapshots</span><span>></span></span>false<span><span><span>&lt;/</span>overWriteSnapshots</span><span>></span></span>\n                            <span><span><span>&lt;</span>overWriteIfNewer</span><span>></span></span>true<span><span><span>&lt;/</span>overWriteIfNewer</span><span>></span></span>\n                            <span><span><span>&lt;</span>includeScope</span><span>></span></span>compile<span><span><span>&lt;/</span>includeScope</span><span>></span></span>\n                        <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;/</span>execution</span><span>></span></span>\n                <span><span><span>&lt;/</span>executions</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- maven编译 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-compiler-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span>&lt;!-- 不同版本需要制定具体的版本进行编译 --></span>\n                    <span><span><span>&lt;</span>source</span><span>></span></span>${java.version}<span><span><span>&lt;/</span>source</span><span>></span></span>\n                    <span><span><span>&lt;</span>target</span><span>></span></span>${java.version}<span><span><span>&lt;/</span>target</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- 打包时跳过测试 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-surefire-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>2.22.1<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>skipTests</span><span>></span></span>true<span><span><span>&lt;/</span>skipTests</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- 将项目中代码文件打成jar包 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-jar-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>3.1.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>excludes</span><span>></span></span>\n                        <span>&lt;!-- 打包后的jar包中不包括配置文件 --></span>\n                        <span>&lt;!-- 通常是指classpath下目录下的文件，这样可以避免编写时的找不到相应文件 --></span>\n                        <span><span><span>&lt;</span>exclude</span><span>></span></span>*.xml<span><span><span>&lt;/</span>exclude</span><span>></span></span>\n                        <span><span><span>&lt;</span>exclude</span><span>></span></span>*.properties<span><span><span>&lt;/</span>exclude</span><span>></span></span>\n                        <span><span><span>&lt;</span>exclude</span><span>></span></span>*.yml<span><span><span>&lt;/</span>exclude</span><span>></span></span>\n                    <span><span><span>&lt;/</span>excludes</span><span>></span></span>\n                    <span><span><span>&lt;</span>archive</span><span>></span></span>\n                        <span><span><span>&lt;</span>manifest</span><span>></span></span>\n                            <span>&lt;!-- 项目启动类 --></span>\n                            <span><span><span>&lt;</span>mainClass</span><span>></span></span>cn.moremind.app.SpringBootApplication<span><span><span>&lt;/</span>mainClass</span><span>></span></span>\n                            <span>&lt;!-- 依赖的jar的目录前缀 --></span>\n                            <span><span><span>&lt;</span>classpathPrefix</span><span>></span></span>../lib/<span><span><span>&lt;/</span>classpathPrefix</span><span>></span></span>\n                            <span><span><span>&lt;</span>addClasspath</span><span>></span></span>true<span><span><span>&lt;/</span>addClasspath</span><span>></span></span>\n                        <span><span><span>&lt;/</span>manifest</span><span>></span></span>\n                        <span>&lt;!-- 将config目录加入classpath目录 --></span>\n                        <span><span><span>&lt;</span>manifestEntries</span><span>></span></span>\n                            <span><span><span>&lt;</span>Class-Path</span><span>></span></span>../config/<span><span><span>&lt;/</span>Class-Path</span><span>></span></span>\n                        <span><span><span>&lt;/</span>manifestEntries</span><span>></span></span>\n                    <span><span><span>&lt;/</span>archive</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- 打包插件 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-assembly-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>3.1.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>descriptors</span><span>></span></span>\n                        <span><span><span>&lt;</span>descriptor</span><span>></span></span>src/main/assembly/assembly.xml<span><span><span>&lt;/</span>descriptor</span><span>></span></span>\n                    <span><span><span>&lt;/</span>descriptors</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n                <span><span><span>&lt;</span>executions</span><span>></span></span>\n                    <span><span><span>&lt;</span>execution</span><span>></span></span>\n                        <span><span><span>&lt;</span>id</span><span>></span></span>make-assembly<span><span><span>&lt;/</span>id</span><span>></span></span>\n                        <span><span><span>&lt;</span>phase</span><span>></span></span>package<span><span><span>&lt;/</span>phase</span><span>></span></span>\n                        <span><span><span>&lt;</span>goals</span><span>></span></span>\n                            <span><span><span>&lt;</span>goal</span><span>></span></span>single<span><span><span>&lt;/</span>goal</span><span>></span></span>\n                        <span><span><span>&lt;/</span>goals</span><span>></span></span>\n                    <span><span><span>&lt;/</span>execution</span><span>></span></span>\n                <span><span><span>&lt;/</span>executions</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br></div></div><h2 id=\"_3-编写shell脚本或者bat脚本\"> 3.编写shell脚本或者bat脚本</h2>\n<p>1.直接运行 java -jar xxxx.jar即可</p>\n<p>2.编写shell/bash脚本</p>\n<p>在bin目录下编写脚本文件如下：</p>\n<p>shell</p>\n<div><pre><code><span>#! /bin/sh</span>\n\n<span>HOME</span> <span>=</span> <span>'/opt/xxx/boot'</span>\nJAR_HOME <span>=</span> <span>'xxx.jar'</span>\n\n<span>cd</span> <span>$HOME</span>\n<span>nohup</span> java -jar <span>$JAR_HOME</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>bash</p>\n<div><pre><code>@echo off\nrem <span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>\nrem windows startup script\nrem\nrem <span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>\nrem startup jar\n\njava -jar <span>..</span>/boot/xxx.jar\n\npause\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_4-项目目录如下\"> 4.项目目录如下</h2>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/blog/images/maven/1565327770486.png\" alt=\"1565327770486\" /></p>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/blog/images/maven/1565327770486.png",
      "date_published": "2022-01-21T16:14:37.000Z",
      "date_modified": "2022-01-21T16:14:37.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Maven"
      ]
    },
    {
      "title": "Blog Home",
      "url": "https://www.moremind.cn/",
      "id": "https://www.moremind.cn/",
      "content_html": "\n",
      "date_published": "2022-01-12T12:29:41.000Z",
      "date_modified": "2022-01-18T16:47:42.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": []
    }
  ]
}