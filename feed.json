{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Moremind's Blog",
  "home_page_url": "https://www.moremind.cn/",
  "feed_url": "https://www.moremind.cn/feed.json",
  "description": "Stay Hungry, Stay Foolish!",
  "author": {
    "name": "Moremind"
  },
  "items": [
    {
      "title": "My Book For 2022",
      "url": "https://www.moremind.cn/book/",
      "id": "https://www.moremind.cn/book/",
      "content_html": "<h2 id=\"_2022-阅读书籍\"> 2022 阅读书籍</h2>\n<h3 id=\"专业书籍\"> 专业书籍</h3>\n<ul>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> Plan A</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> Plan B</label></li>\n</ul>\n<h3 id=\"非专业书籍\"> 非专业书籍</h3>\n<ul>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-2\"><label for=\"task-item-2\"> 结构性改革-中国经济的问题与对策</label></li>\n</ul>\n",
      "date_published": "2022-01-01T00:00:00.000Z",
      "date_modified": "2022-04-06T13:44:30.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": []
    },
    {
      "title": "友链",
      "url": "https://www.moremind.cn/friends/",
      "id": "https://www.moremind.cn/friends/",
      "content_html": "<h3 id=\"左领右舍\"> 左领右舍</h3>\n<table>\n<thead>\n<tr>\n<th>✌️✌️名称</th>\n<th style=\"text-align:left\">👍👍链接</th>\n<th style=\"text-align:center\">简介🎉 💯</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>南瓜慢说</td>\n<td style=\"text-align:left\"><a href=\"https://www.pkslow.com/\" target=\"_blank\" rel=\"noopener noreferrer\">南瓜慢说</a></td>\n<td style=\"text-align:center\">a niubility man</td>\n</tr>\n<tr>\n<td>赵俊</td>\n<td style=\"text-align:left\"><a href=\"http://www.zhaojun.im/\" target=\"_blank\" rel=\"noopener noreferrer\">赵俊的博客</a></td>\n<td style=\"text-align:center\">一个 Java 学习者的博客</td>\n</tr>\n<tr>\n<td>R'Blog</td>\n<td style=\"text-align:left\"><a href=\"http://bolg.rvich.com/\" target=\"_blank\" rel=\"noopener noreferrer\">R'Blog</a></td>\n<td style=\"text-align:center\">分享资源</td>\n</tr>\n<tr>\n<td>随遇而安</td>\n<td style=\"text-align:left\"><a href=\"https://www.iszy.cc/\" target=\"_blank\" rel=\"noopener noreferrer\">随遇而安</a></td>\n<td style=\"text-align:center\">技术分享&amp;生活吐槽</td>\n</tr>\n<tr>\n<td>GongJS</td>\n<td style=\"text-align:left\"><a href=\"https://gongjs.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">GongJS</a></td>\n<td style=\"text-align:center\">Talk is cheap,show me the code.</td>\n</tr>\n<tr>\n<td>谭升的博客</td>\n<td style=\"text-align:left\"><a href=\"https://face2ai.com\" target=\"_blank\" rel=\"noopener noreferrer\">谭升的博客</a></td>\n<td style=\"text-align:center\">人工智能算法，数学基础类原创博客</td>\n</tr>\n<tr>\n<td>冰水鉴心的博客</td>\n<td style=\"text-align:left\"><a href=\"https://xq773939719.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">冰水鉴心的博客</a></td>\n<td style=\"text-align:center\">.软工渣.编程痴.开发宅.系统迷.强迫症</td>\n</tr>\n<tr>\n<td>LmCjl在线工具</td>\n<td style=\"text-align:left\"><a href=\"https://www.lmcjl.com\" target=\"_blank\" rel=\"noopener noreferrer\">LmCjl在线工具</a></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>YuYe</td>\n<td style=\"text-align:left\"><a href=\"https://chenyeah.com/\" target=\"_blank\" rel=\"noopener noreferrer\">YuYe</a></td>\n<td style=\"text-align:center\">专注于前端技术</td>\n</tr>\n<tr>\n<td>笨小孩杂谈</td>\n<td style=\"text-align:left\"><a href=\"https://rocky-191.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">笨小孩杂谈</a></td>\n<td style=\"text-align:center\">专注前端技术</td>\n</tr>\n<tr>\n<td>yoko blog</td>\n<td style=\"text-align:left\"><a href=\"https://pengrl.com\" target=\"_blank\" rel=\"noopener noreferrer\">yoko blog</a></td>\n<td style=\"text-align:center\">目前主要写些c++和Go语言方面的博客</td>\n</tr>\n<tr>\n<td>六阿哥博客</td>\n<td style=\"text-align:left\"><a href=\"https://blog.6ag.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">六阿哥博客</a></td>\n<td style=\"text-align:center\">记录一个程序员的成长历程</td>\n</tr>\n<tr>\n<td>枫糖</td>\n<td style=\"text-align:left\"><a href=\"https://blog.maplesugar.top\" target=\"_blank\" rel=\"noopener noreferrer\">枫糖</a></td>\n<td style=\"text-align:center\">From rookie to master</td>\n</tr>\n<tr>\n<td>Serence</td>\n<td style=\"text-align:left\"><a href=\"https://blog.blinkstar.cn\" target=\"_blank\" rel=\"noopener noreferrer\">Serence</a></td>\n<td style=\"text-align:center\">一个程序员 + 文艺青年的博客</td>\n</tr>\n<tr>\n<td>羽叶丶</td>\n<td style=\"text-align:left\"><a href=\"https://yuye.fun\" target=\"_blank\" rel=\"noopener noreferrer\">羽叶丶</a></td>\n<td style=\"text-align:center\">羽叶丶的个人博客</td>\n</tr>\n<tr>\n<td>飞跃高山和大洋的🐟</td>\n<td style=\"text-align:left\"><a href=\"https://timspan.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">飞跃高山和大洋的🐟</a></td>\n<td style=\"text-align:center\">前端</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"优秀技术博客\"> 优秀技术博客</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th style=\"text-align:left\">链接</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>美团技术团队</td>\n<td style=\"text-align:left\"><a href=\"https://tech.meituan.com/\" target=\"_blank\" rel=\"noopener noreferrer\">美团技术团队</a></td>\n<td style=\"text-align:center\">美团技术团队相关文档</td>\n</tr>\n<tr>\n<td>FEX技术周刊</td>\n<td style=\"text-align:left\"><a href=\"http://fex.baidu.com/\" target=\"_blank\" rel=\"noopener noreferrer\">FEX技术周刊</a></td>\n<td style=\"text-align:center\">FEX技术周刊</td>\n</tr>\n<tr>\n<td>前端精读周刊</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/dt-fe/weekly\" target=\"_blank\" rel=\"noopener noreferrer\">前端精读周刊</a></td>\n<td style=\"text-align:center\">前端精读周刊</td>\n</tr>\n<tr>\n<td>前端资源汇总仓库</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/helloqingfeng/Awsome-Front-End-learning-resource\" target=\"_blank\" rel=\"noopener noreferrer\">前端资源汇总仓库</a></td>\n<td style=\"text-align:center\">前端资源汇总仓库</td>\n</tr>\n<tr>\n<td>后端架构师技术图谱</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/xingshaocheng/architect-awesome\" target=\"_blank\" rel=\"noopener noreferrer\">后端架构师技术图谱</a></td>\n<td style=\"text-align:center\">后端架构师技术图谱</td>\n</tr>\n<tr>\n<td>CS-NOTES</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/CyC2018/CS-Notes\" target=\"_blank\" rel=\"noopener noreferrer\">CS-NOTES</a></td>\n<td style=\"text-align:center\">CS-NOTES</td>\n</tr>\n<tr>\n<td>JAVA-进阶</td>\n<td style=\"text-align:left\"><a href=\"https://doocs.gitee.io/advanced-java/#/\" target=\"_blank\" rel=\"noopener noreferrer\">JAVA-进阶</a></td>\n<td style=\"text-align:center\">JAVA-进阶</td>\n</tr>\n<tr>\n<td>经典编程书籍大全</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/jobbole/awesome-programming-books\" target=\"_blank\" rel=\"noopener noreferrer\">经典编程书籍大全</a></td>\n<td style=\"text-align:center\">经典编程书籍大全</td>\n</tr>\n<tr>\n<td>代码日志</td>\n<td style=\"text-align:left\"><a href=\"https://codeday.me/\" target=\"_blank\" rel=\"noopener noreferrer\">代码日志</a></td>\n<td style=\"text-align:center\">代码日志</td>\n</tr>\n<tr>\n<td>阿里中间件团队博客</td>\n<td style=\"text-align:left\"><a href=\"http://jm.taobao.org/\" target=\"_blank\" rel=\"noopener noreferrer\">阿里中间件团队博客</a></td>\n<td style=\"text-align:center\">阿里中间件团队博客</td>\n</tr>\n<tr>\n<td>自然语言处理</td>\n<td style=\"text-align:left\"><a href=\"http://www.hankcs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">自然语言处理</a></td>\n<td style=\"text-align:center\">自然语言处理</td>\n</tr>\n<tr>\n<td>崔庆才的个人博客</td>\n<td style=\"text-align:left\"><a href=\"https://cuiqingcai.com/\" target=\"_blank\" rel=\"noopener noreferrer\">崔庆才的个人博客</a></td>\n<td style=\"text-align:center\">崔庆才的个人博客</td>\n</tr>\n<tr>\n<td>Frank</td>\n<td style=\"text-align:left\"><a href=\"https://www.frankfeekr.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">Frank</a></td>\n<td style=\"text-align:center\">Frank的个人博客</td>\n</tr>\n<tr>\n<td>并发编程网</td>\n<td style=\"text-align:left\"><a href=\"http://ifeve.com/\" target=\"_blank\" rel=\"noopener noreferrer\">并发编程网</a></td>\n<td style=\"text-align:center\">并发编程网</td>\n</tr>\n<tr>\n<td>java与cs-base</td>\n<td style=\"text-align:left\"><a href=\"http://java.isture.com/\" target=\"_blank\" rel=\"noopener noreferrer\">java与cs-base</a></td>\n<td style=\"text-align:center\">java与cs-base</td>\n</tr>\n</tbody>\n</table>\n<div><p>提示</p>\n<p>欢迎留言提交互加友链!最好提供你网站的简介哟<br>\n如果您需要更改您的链接或者链接有错误，请联系我: <a href=\"mailto:hefengen@hotmail.com\">hefengen@hotmail.com</a></p>\n</div>\n<div><p>我的个人链接</p>\n<p>昵称：Finen<br>\n链接：https://www.finen.top/<br>\n头像链接：https://finen-1251602255.cos.ap-shanghai.myqcloud.com/file/pic/finen.png<br>\n介绍：Stay Hungry! Stay Foolish!</p>\n</div>\n",
      "date_published": "2018-04-28T00:00:00.000Z",
      "date_modified": "2022-08-18T16:17:44.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": []
    },
    {
      "title": "Project home",
      "url": "https://www.moremind.cn/home/",
      "id": "https://www.moremind.cn/home/",
      "content_html": "<p>This is an example of a normal homepage. You can place your main content here.</p>\n<p>To use this layout, you need to set <code>home: true</code> in the page front matter.</p>\n<p>For related descriptions of configuration items, please see <a href=\"https://vuepress-theme-hope.github.io/guide/layout/home/\" target=\"_blank\" rel=\"noopener noreferrer\">Project HomePage Layout Config</a>.</p>\n",
      "date_published": "2022-01-12T12:29:41.000Z",
      "date_modified": "2022-01-12T12:29:41.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": []
    },
    {
      "title": "Intro Page",
      "url": "https://www.moremind.cn/intro/",
      "id": "https://www.moremind.cn/intro/",
      "content_html": "<h1 id=\"intro-page\"> Intro Page</h1>\n<p>Place your introducation and profile here.</p>\n",
      "date_published": "2022-01-12T12:29:41.000Z",
      "date_modified": "2022-01-14T09:08:36.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": []
    },
    {
      "title": "算法",
      "url": "https://www.moremind.cn/md/construct/construct/",
      "id": "https://www.moremind.cn/md/construct/construct/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-13T16:50:45.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "算法",
      "url": "https://www.moremind.cn/md/construct/design/",
      "id": "https://www.moremind.cn/md/construct/design/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-13T16:50:45.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "算法",
      "url": "https://www.moremind.cn/md/cs/alg/",
      "id": "https://www.moremind.cn/md/cs/alg/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-13T16:50:45.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "数据结构",
      "url": "https://www.moremind.cn/md/cs/datastructure/",
      "id": "https://www.moremind.cn/md/cs/datastructure/",
      "content_html": "<p>JVM 内存分析图\nJVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-13T16:50:45.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "计算机网络",
      "url": "https://www.moremind.cn/md/cs/network/",
      "id": "https://www.moremind.cn/md/cs/network/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-13T16:50:45.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "操作系统",
      "url": "https://www.moremind.cn/md/cs/os/",
      "id": "https://www.moremind.cn/md/cs/os/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-13T16:50:45.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "hibernate",
      "url": "https://www.moremind.cn/md/data-persistence/hibernate/",
      "id": "https://www.moremind.cn/md/data-persistence/hibernate/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Hibernate"
      ]
    },
    {
      "title": "jpa",
      "url": "https://www.moremind.cn/md/data-persistence/jpa/",
      "id": "https://www.moremind.cn/md/data-persistence/jpa/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "JPA"
      ]
    },
    {
      "title": "mybatis-进阶",
      "url": "https://www.moremind.cn/md/data-persistence/mybatis-advance/",
      "id": "https://www.moremind.cn/md/data-persistence/mybatis-advance/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-21T15:41:02.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Mybaits"
      ]
    },
    {
      "title": "mybatis",
      "url": "https://www.moremind.cn/md/data-persistence/mybatis/",
      "id": "https://www.moremind.cn/md/data-persistence/mybatis/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Mybaits"
      ]
    },
    {
      "title": "数据库进阶",
      "url": "https://www.moremind.cn/md/db/db-advance/",
      "id": "https://www.moremind.cn/md/db/db-advance/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-14T17:15:37.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Relation-Database"
      ]
    },
    {
      "title": "数据库知识体系",
      "url": "https://www.moremind.cn/md/db/db-basic/",
      "id": "https://www.moremind.cn/md/db/db-basic/",
      "content_html": "<p>数据库基础知识体系</p>\n",
      "date_published": "2022-01-14T17:15:37.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Relation-Database"
      ]
    },
    {
      "title": "MySQL知识体系",
      "url": "https://www.moremind.cn/md/db/db-mysql/",
      "id": "https://www.moremind.cn/md/db/db-mysql/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-21T15:41:02.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "MySQL"
      ]
    },
    {
      "title": "Elasticsearch知识体系",
      "url": "https://www.moremind.cn/md/db/db-nosql-elasticsearch/",
      "id": "https://www.moremind.cn/md/db/db-nosql-elasticsearch/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-21T15:41:02.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Elasticsearch"
      ]
    },
    {
      "title": "Redis知识体系",
      "url": "https://www.moremind.cn/md/db/db-nosql-redis/",
      "id": "https://www.moremind.cn/md/db/db-nosql-redis/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-21T15:41:02.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Redis"
      ]
    },
    {
      "title": "java基础",
      "url": "https://www.moremind.cn/md/java/basic/",
      "id": "https://www.moremind.cn/md/java/basic/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Basic"
      ]
    },
    {
      "title": "ArrayList源码解析",
      "url": "https://www.moremind.cn/md/java/collection/ArrayList-Source/",
      "id": "https://www.moremind.cn/md/java/collection/ArrayList-Source/",
      "content_html": "<h2 id=\"arraylist是什么\"> ArrayList是什么?</h2>\n<h2 id=\"为什么要使用arraylist\"> 为什么要使用ArrayList?</h2>\n<h2 id=\"在什么环境下使用arraylist\"> 在什么环境下使用ArrayList?</h2>\n<h2 id=\"怎么使用arraylist\"> 怎么使用ArrayList?</h2>\n<h3 id=\"基本api\"> 基本API</h3>\n<h3 id=\"基本源码\"> 基本源码</h3>\n",
      "date_published": "2022-02-24T09:46:27.000Z",
      "date_modified": "2022-04-18T08:35:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Collection"
      ]
    },
    {
      "title": "HashSet源码解析",
      "url": "https://www.moremind.cn/md/java/collection/HashMap&HashSet-Source/",
      "id": "https://www.moremind.cn/md/java/collection/HashMap&HashSet-Source/",
      "content_html": "<h2 id=\"集合关系图谱\"> 集合关系图谱</h2>\n<blockquote>\n<p>Java集合框架包括Collection和Map，Collection主要用于存储对象，Map主要用用于存储键值对数据。</p>\n</blockquote>\n<h2 id=\"collection\"> Collection</h2>\n<h3 id=\"list\"> List</h3>\n<h4 id=\"arraylist\"> ArrayList</h4>\n<h4 id=\"linkedlist\"> LinkedList</h4>\n<h3 id=\"set\"> Set</h3>\n<h4 id=\"hashset\"> Hashset</h4>\n<h4 id=\"linkedhashset\"> LinkedHashSet</h4>\n<h3 id=\"queue\"> Queue</h3>\n<h4 id=\"deque\"> Deque</h4>\n<h4 id=\"arraydeque\"> ArrayDeque</h4>\n",
      "date_published": "2022-04-06T13:44:30.000Z",
      "date_modified": "2022-04-06T13:44:30.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Collection"
      ]
    },
    {
      "title": "LinkedList源码解析",
      "url": "https://www.moremind.cn/md/java/collection/LinkedList-Source/",
      "id": "https://www.moremind.cn/md/java/collection/LinkedList-Source/",
      "content_html": "<h2 id=\"集合关系图谱\"> 集合关系图谱</h2>\n<blockquote>\n<p>Java集合框架包括Collection和Map，Collection主要用于存储对象，Map主要用用于存储键值对数据。</p>\n</blockquote>\n<h2 id=\"collection\"> Collection</h2>\n<h3 id=\"list\"> List</h3>\n<h4 id=\"arraylist\"> ArrayList</h4>\n<h4 id=\"linkedlist\"> LinkedList</h4>\n<h3 id=\"set\"> Set</h3>\n<h4 id=\"hashset\"> Hashset</h4>\n<h4 id=\"linkedhashset\"> LinkedHashSet</h4>\n<h3 id=\"queue\"> Queue</h3>\n<h4 id=\"deque\"> Deque</h4>\n<h4 id=\"arraydeque\"> ArrayDeque</h4>\n",
      "date_published": "2022-02-24T09:46:27.000Z",
      "date_modified": "2022-02-25T06:53:23.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Collection"
      ]
    },
    {
      "title": "java集合框架知识图谱",
      "url": "https://www.moremind.cn/md/java/collection/",
      "id": "https://www.moremind.cn/md/java/collection/",
      "content_html": "<h2 id=\"集合关系图谱\"> 集合关系图谱</h2>\n<blockquote>\n<p>Java集合框架包括Collection和Map，Collection主要用于存储对象，Map主要用用于存储键值对数据。\n<img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Java-collection-cheat-sheet.PNG\" alt=\"Java-Collection\" /></p>\n</blockquote>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>容器，就是可以容纳其他Java对象的对象。*Java Collections Framework(JCF)*为Java开发者提供了通用的容器，其始于JDK 1.2，优点是:</p>\n<ul>\n<li>降低编程难度</li>\n<li>提高程序性能</li>\n<li>提高API间的互操作性</li>\n<li>降低学习难度</li>\n<li>降低设计和实现相关API的难度</li>\n<li>增加程序的重用性\nJava容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</li>\n</ul>\n<h2 id=\"collection\"> Collection</h2>\n<h3 id=\"list\"> List</h3>\n<h4 id=\"arraylist简介\"> ArrayList简介</h4>\n<p>1.ArrayList继承自<code>AbstractList</code>，实现了<code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code>接口。</p>\n<p>2.底层基于动态数组实现容量大小动态变化（容量可自动增长）。</p>\n<p>3.允许<code>null</code>的存在。</p>\n<p>4.ArrayList是支持快速访问、复制、序列化的。基于动态数组实现，支持。</p>\n<p>5.ArrayList是非同步的。</p>\n<p>6.ArrayList的iterator和listIterator方法返回的迭代器是fail-fast的。</p>\n<h4 id=\"linkedlist\"> LinkedList</h4>\n<p>1.LinkedList继承自<code>AbstractSequentialList</code>，实现了<code>List</code>、<code>Deque</code>、<code>Cloneable</code>、<code>Serializable</code>接口，LinkedList是基于链表实现的，只能顺序访问。</p>\n<p>2.<code>LinkedList</code>插入和删除方面要优于<code>ArrayList</code>。</p>\n<p>3.LinkedList是非同步的。</p>\n<p>4.LinkedList的iterator和listIterator方法返回的迭代器是fail-fast的。</p>\n<h3 id=\"set\"> Set</h3>\n<h4 id=\"hashset\"> Hashset</h4>\n<p>1.HashSet继承自<code>AbstractSet</code>,实现了<code>Set</code>、<code>Cloneable</code>、<code>Serializable</code>接口,底层是一个HashMap。</p>\n<p>2.HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。</p>\n<p>3.HashSet中元素都是无序的(即存取顺序不一致)；</p>\n<p>4.HashSet没有下标选取，只能通过增强for循环或者迭代器取出元素；</p>\n<p>5.HashSet是非同步的；</p>\n<p>6.HashSet的iterator方法返回的迭代器是fail-fast的。</p>\n<h4 id=\"linkedhashset\"> LinkedHashSet</h4>\n<p>1.LinkedHashSet继承自<code>HashSet</code>，实现了<code>Set</code>、<code>Cloneable</code>接口，底层其实是一个LinkedHashMap。</p>\n<p>2.不能保证插入和输出的顺序一致。</p>\n<p>3.不允许重复的元素插入，可以插入null。</p>\n<p>4.HashSet的iterator方法返回的迭代器是fail-fast的。</p>\n<h4 id=\"treeset\"> TreeSet</h4>\n<p>1.TreeSet继承自<code>AbstractSet</code>，实现了NavigableSet、Cloneable、Serializable接口。</p>\n<p>2.一种基于<code>TreeMap</code>的<code>NavigableSet</code>实现,意味着它支持一系列的导航方法。</p>\n<p>3.TreeSet是有序的Set集合,通过<code>TreeMap</code>实现的一个有序的、不可重复的集合，底层维护的是红黑树结构。</p>\n<p>4.TreeSet的iterator方法返回的迭代器是fail-fast的。</p>\n<h3 id=\"queue\"> Queue</h3>\n<h4 id=\"arraydeque\"> ArrayDeque</h4>\n<p>1.ArrayDeque是Deque接口的一个实现，使用了可变数组，所以没有容量上的限制。</p>\n<p>2.ArrayDeque是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。</p>\n<p>3.ArrayDeque是Deque的实现类，可以作为栈来使用，效率高于Stack；\n也可以作为队列来使用，效率高于LinkedList。</p>\n<p>4.ArrayDeque不支持null值。</p>\n<p>5.ArrayDeque的iterator方法返回的迭代器是fail-fast的。</p>\n<p>6.ArrayDeque两端都可以操作,支持双向迭代器遍历。</p>\n<h4 id=\"priorityqueue\"> PriorityQueue</h4>\n<p>1.PriorityQueue继承自<code>AbstractQueue</code>，实现了<code>Serializable</code>接口。</p>\n<p>2.PriorityQueue队列元素根据自然排序或者根据具体的比较器排序。</p>\n<p>3.PriorityQueue实例化时若未指定初始容量，默认容量为11。</p>\n<p>4.PriorityQueue自动扩容。如果容量小于64，两倍增长扩容；否则增长50%,PriorityQueue是无边界容器。</p>\n<p>5.PriorityQueue的迭代器不具有以特定顺序访问队列元素。</p>\n<p>6.PriorityQueue不支持<code>null</code>元素。</p>\n<p>7.PriorityQueue入队出队的时间复杂度O(log(n))</p>\n<h2 id=\"map\"> Map</h2>\n<h3 id=\"hashmap\"> HashMap</h3>\n<p>1.HashMap继承自<code>AbstractMap</code>,实现<code>Map</code>、<code>Cloneable</code>、<code>Serializable</code>接口。</p>\n<p>2.HashMap 基于哈希表的Map接口实现，是以 key-value 存储形式存在，即主要用来存放键值对。</p>\n<p>3.HashMap 的实现不是同步的，这意味着它不是线程安全的。</p>\n<p>4.HashMap 中的映射不是有序的(即存取顺序不一致)。</p>\n<p>5.JDK1.5-JDK1.7实现的结果是数组+链表，JDK1.8实现结构是数组+链表+红黑树。</p>\n<p>6.HashMap key值能为null,value值可以为null，且key值不允许重复。</p>\n<p>7.HashMap的iterator方法返回的迭代器是fail-fastl的。</p>\n<h3 id=\"linkedhashmap\"> LinkedHashMap</h3>\n<p>1.LinkedHashMap继承自<code>HashMap</code>,实现了<code>Map</code>接口。</p>\n<p>2.LinkedHashMap维护了一个Entry的双向链表，保证了插入的Entry中的顺序。</p>\n<p>3.使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</p>\n<p>4.LinkedHashMap的iterator方法返回的迭代器是fail-fastl的。</p>\n<h3 id=\"treemap\"> TreeMap</h3>\n<p>1.TreeMap 继承自AbstractMap，实现了<code>NavigableMap</code>、<code>Cloneable</code>、<code>Serializable接口</code>。</p>\n<p>2.TreeMap不允许出现重复的key。</p>\n<p>3.TreeMap可以插入null键，null值。</p>\n<p>4.TreeMap可以对元素进行排序。</p>\n<p>5.TreeMap无序集合（插入和遍历顺序不一致）。</p>\n<p>6.TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的Comparator进行排序，具体取决于使用的构造方法。</p>\n<p>7.TreeMap的iterator方法返回的迭代器是fail-fastl的。</p>\n<h3 id=\"hashtable\"> HashTable</h3>\n<p>1.与HashMap一样，Hashtable也是一个散列表，是以key-value存储形式存在，即主要用来存放键值对；</p>\n<p>2.与HashMap不同，Hashtable的函数都是同步的，这意味着它是线程安全的；</p>\n<p>3.Hashtable的key、value都不可以为null，并且，Hashtable中的映射不是有序的；</p>\n<p>4.实现结构是数组+单向链表。</p>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/Java-collection-cheat-sheet.PNG",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-07-02T17:06:40.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Collection"
      ]
    },
    {
      "title": "TreeMap&TreeSet源码解析",
      "url": "https://www.moremind.cn/md/java/collection/TreeMap&TreeSet-Source/",
      "id": "https://www.moremind.cn/md/java/collection/TreeMap&TreeSet-Source/",
      "content_html": "<h2 id=\"集合关系图谱\"> 集合关系图谱</h2>\n<blockquote>\n<p>Java集合框架包括Collection和Map，Collection主要用于存储对象，Map主要用用于存储键值对数据。</p>\n</blockquote>\n<h2 id=\"collection\"> Collection</h2>\n<h3 id=\"list\"> List</h3>\n<h4 id=\"arraylist\"> ArrayList</h4>\n<h4 id=\"linkedlist\"> LinkedList</h4>\n<h3 id=\"set\"> Set</h3>\n<h4 id=\"hashset\"> Hashset</h4>\n<h4 id=\"linkedhashset\"> LinkedHashSet</h4>\n<h3 id=\"queue\"> Queue</h3>\n<h4 id=\"deque\"> Deque</h4>\n<h4 id=\"arraydeque\"> ArrayDeque</h4>\n",
      "date_published": "2022-04-06T13:44:30.000Z",
      "date_modified": "2022-04-06T13:44:30.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Collection"
      ]
    },
    {
      "title": "Java IO框架图谱",
      "url": "https://www.moremind.cn/md/java/io/",
      "id": "https://www.moremind.cn/md/java/io/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-17T14:28:59.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-IO"
      ]
    },
    {
      "title": "JVM前奏-JVM堆栈内存简析",
      "url": "https://www.moremind.cn/md/java/jvm/JVM-1/",
      "id": "https://www.moremind.cn/md/java/jvm/JVM-1/",
      "content_html": "<h2 id=\"_1-官网\"> 1 官网</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310000943157.png\" alt=\"image-20220310000943157\" /></p>\n<h3 id=\"_1-1-jdk8\"> 1.1 JDK8</h3>\n<h3 id=\"_1-2-the-relation-of-jdk-jre-jvm\"> 1.2 The relation of JDK/JRE/JVM</h3>\n<p>Reference -&gt; Developer Guides -&gt; 定位到:https://docs.oracle.com/javase/8/docs/index.html</p>\n<blockquote>\n<p>JDK 8 is a superset of JRE 8, and contains everything that is in JRE 8, plus tools such as the compilers and debuggers necessary for developing applets and applications. JRE 8 provides the libraries, the Java Virtual Machine (JVM), and other components to run applets and applications written in the Java programming language. Note that the JRE includes components not required by the Java SE specification, including both standard and non-standard Java components.</p>\n</blockquote>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309202058012.png\" alt=\"image-20220309202058012\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309203220133.png\" alt=\"image-20220309203220133\" /></p>\n<h2 id=\"_2-源码到类文件\"> 2 源码到类文件</h2>\n<h3 id=\"_2-1-源码\"> 2.1 源码</h3>\n<div><pre><code><span>class</span> <span>Person</span><span>{</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n    <span>private</span> <span>static</span> <span>String</span> address<span>;</span>\n    <span>private</span> <span>final</span> <span>static</span> <span>String</span> hobby<span>=</span><span>\"Programming\"</span><span>;</span>\n    <span>public</span> <span>void</span> <span>say</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"person say...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>int</span> <span>calc</span><span>(</span><span>int</span> op1<span>,</span><span>int</span> op2<span>)</span><span>{</span>\n        <span>return</span> op1<span>+</span>op2<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_2-2-编译过程\"> 2.2 编译过程</h3>\n<blockquote>\n<p>Person.java -&gt; 词法分析器 -&gt; tokens流 -&gt; 语法分析器 -&gt; 语法树/抽象语法树 -&gt; 语义分析器 -&gt; 注解抽象语法树 -&gt; 字节码生成器 -&gt; Person.class文件</p>\n</blockquote>\n<h3 id=\"_2-3-类文件-class文件\"> 2.3 类文件(Class文件)</h3>\n<p>官网The class File Format :https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</p>\n<div><pre><code>cafe babe 0000 0034 0027 0a00 0600 1809\n0019 001a 0800 1b0a 001c 001d 0700 1e07\n001f 0100 046e 616d 6501 0012 4c6a 6176\n612f 6c61 6e67 2f53 7472 696e 673b 0100\n0361 6765 0100 0149 0100 0761 6464 7265\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309204252776.png\" alt=\"image-20220309204252776\" /></p>\n<p><strong>minor_version, major_version</strong></p>\n<div><pre><code>minor_version, major_version\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>constant_pool_count</strong></p>\n<p>0027 对应十进制27，代表常量池中27个常量</p>\n<div><pre><code>ClassFile {\n    u4             magic;\n    u2             minor_version;\n    u2             major_version;\n    u2             constant_pool_count;\n    cp_info        constant_pool[constant_pool_count-1];\n    u2             access_flags;\n    u2             this_class;\n    u2             super_class;\n    u2             interfaces_count;\n    u2             interfaces[interfaces_count];\n    u2             fields_count;\n    field_info     fields[fields_count];\n    u2             methods_count;\n    method_info    methods[methods_count];\n    u2             attributes_count;\n    attribute_info attributes[attributes_count];\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>.class字节码文件</strong></p>\n<div><pre><code>魔数与class文件版本\n常量池\n访问标志\n类索引、父类索引、接口索引\n字段表集合\n方法表集合\n属性表集合\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"_3-类文件到虚拟机-类加载机制\"> 3 类文件到虚拟机(类加载机制)</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309204625348.png\" alt=\"image-20220309204625348\" /></p>\n<h3 id=\"_3-1-装载-load\"> 3.1 装载(Load)</h3>\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html\" target=\"_blank\" rel=\"noopener noreferrer\">Chapter 5. Loading, Linking, and Initializing (oracle.com)</a></p>\n<p>a.找到类文件所在的位置---:磁盘--&gt;类装载器ClassLoader --&gt; 寻找类</p>\n<p>b.类文件的信息交给JVM  --&gt; 类文件字节码流静态存储结构 --&gt; JVM里卖弄的某一块区域</p>\n<p>c.类文件所对应的对象Class ---&gt; JVM</p>\n<p>查找和导入class文件 --&gt; JVM --&gt; 堆</p>\n<div><pre><code>(1)通过一个类的全限定名获取定义此类的二进制字节流\n(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-2-链接-link\"> 3.2 链接(Link)</h3>\n<h4 id=\"_3-2-1-验证-verify-保证被加载类的正确性\"> 3.2.1 验证(Verify):保证被加载类的正确性</h4>\n<ul>\n<li>\n<p>文件格式验证</p>\n</li>\n<li>\n<p>元数据验证</p>\n</li>\n<li>\n<p>字节码验证</p>\n</li>\n<li>\n<p>符号引用验证</p>\n</li>\n</ul>\n<h4 id=\"_3-2-2-准备-prepare\"> 3.2.2 准备(Prepare)</h4>\n<p><strong>为类的静态变量分配内存，并将其初始化为默认值</strong></p>\n<p>static int num = 10; // 在准备阶段为num分配内存空间，并初始化其值为0</p>\n<h4 id=\"_3-2-3-解析-resolve\"> 3.2.3 解析(Resolve)</h4>\n<p><strong>把类中的符号引用转换为直接引用</strong></p>\n<p>地址：String str =地址是什么，直接对应到内存中某个地址指向。</p>\n<h3 id=\"_3-3-初始化-initialize\"> 3.3 初始化(Initialize)</h3>\n<p>对类的静态变量，静态代码块执行初始化操作</p>\n<p>static int num = 10; // 此时，num才会被真正的赋值为10</p>\n<h3 id=\"_3-4-类加载机制图解\"> 3.4 类加载机制图解</h3>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309205334127.png\" alt=\"image-20220309205334127\" /></p>\n<h2 id=\"_4-类装载器classloader\"> 4 类装载器ClassLoader</h2>\n<p>在装载(Load)阶段，其中第(1)步:通过类的全限定名获取其定义的二进制字节流，需要借助类装载 器完成，顾名思义，就是用来装载Class文件的。</p>\n<p>(1)通过一个类的全限定名获取定义此类的二进制字节流。</p>\n<h3 id=\"_4-1-分类\"> 4.1 分类</h3>\n<p>1）Bootstrap ClassLoader 负责加载$JAVA_HOME中 jre/lib/rt.jar 里所有的class或 Xbootclassoath选项指定的jar包。由C++实现，不是ClassLoader子类。</p>\n<p>2）Extension ClassLoader 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中 jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。</p>\n<p>3）App ClassLoader 负责加载classpath中指定的jar包及 Djava.class.path 所指定目录下的类和 jar包。</p>\n<p>4）Custom ClassLoader 通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据 自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。</p>\n<h3 id=\"_4-2-图解\"> 4.2 图解</h3>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309205433326.png\" alt=\"image-20220309205433326\" /></p>\n<h3 id=\"_4-3-加载原则\"> 4.3 加载原则</h3>\n<p><strong>检查某个类是否已经加载：顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检 查，只要某个Classloader已加载，就视为已加载此类，保证此类只所有ClassLoader加载一次。</strong></p>\n<p><strong>加载的顺序：加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</strong></p>\n<p><strong>双亲委派机制：</strong></p>\n<blockquote>\n<p>定义：如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把 这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就 成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>\n</blockquote>\n<blockquote>\n<p>优势：Java类随着加载它的类加载器一起具备了一种带有优先级的层次关系。比如，Java中的 Object类，它存放在rt.jar之中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型 最顶端的启动类加载器进行加载，因此Object在各种类加载环境中都是同一个类。如果不采用 双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的Object 类。</p>\n</blockquote>\n<blockquote>\n<p>破坏：可以继承ClassLoader类，然后重写其中的loadClass方法，其他方式大家可以自己了解 拓展一下。</p>\n</blockquote>\n<h2 id=\"_5-运行时数据区-run-time-data-areas\"> 5 运行时数据区(Run-Time Data Areas)</h2>\n<p>在装载阶段的第(2),(3)步可以发现有运行时数据，堆，方法区等名词</p>\n<p>(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>\n<p>(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</p>\n<p>说白了就是类文件被类装载器装载进来之后，类中的内容(比如变量，常量，方法，对象等这些数 据得要有个去处，也就是要存储起来，存储的位置肯定是在JVM中有对应的空间)</p>\n<h3 id=\"_5-1-官网概括\"> 5.1 官网概括</h3>\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5\" target=\"_blank\" rel=\"noopener noreferrer\">Chapter 2. The Structure of the Java Virtual Machine (oracle.com)</a></p>\n<div><pre><code>The Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these data areas are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits. Other data areas are per thread. Per-thread data areas are created when a thread is created and destroyed when the thread exits\n\n&gt;&gt;&gt; Java 虚拟机定义了在程序执行期间使用的各种运行时数据区域。 其中一些数据区是在 Java 虚拟机启动时创建的，只有在 Java 虚拟机退出时才会被销毁。 其他数据区域是每个线程。 每线程数据区在创建线程时创建，在线程退出时销毁\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_5-2-图解\"> 5.2 图解</h3>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309213359201.png\" alt=\"image-20220309213359201\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309211847128.png\" alt=\"image-20220309211847128\" /></p>\n<h3 id=\"_5-3-常规理解\"> 5.3 常规理解</h3>\n<h4 id=\"_5-3-1-method-area-方法区-类信息、常量、静态变量、即使编译器编译之后的代码\"> 5.3.1 Method Area(方法区):类信息、常量、静态变量、即使编译器编译之后的代码</h4>\n<blockquote>\n<p>在JDK1.8中，方法区存放运行时常量池、方法数据、方法的代码和构造方法，包括类中的实例化方法和接口初始化方法。\n存放如下数据：</p>\n</blockquote>\n<div><pre><code><span>// 该类型数据存放在方法区</span>\n<span>public</span> <span>static</span> <span>final</span> CONSTSANT <span>=</span> <span>\"constant\"</span><span>;</span>\n\n<span>// 方法区存放方法以及方法的代码</span>\n<span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n   <span>// 该方法存放在方法区</span>\n   <span>public</span> <span>Test</span><span>(</span><span>)</span> <span>{</span>\n   <span>}</span>\n   \n   <span>// 该方法存放在方法区</span>\n   <span>public</span> <span>void</span> <span>testMethod</span><span>(</span><span>)</span> <span>{</span>\n   <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>interface</span> <span>IXXService</span><span>(</span><span>)</span> <span>{</span>\n   <span>// 该方法存放在方法区</span>\n   <span>default</span> <span>void</span> test <span>(</span><span>)</span> <span>{</span>\n       \n   <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code>The Java Virtual Machine has a method area that is shared among all Java Virtual\nMachine threads.\n&gt;&gt; 方法区只有一个，线程共享的内存区域【线程非安全】，生命周期是跟虚拟机一样的。\n\nIt stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods (§2.9) used in class and instance initialization and interface initialization.\n&gt;&gt; 类信息、常量、静态变量、即使编译器编译之后的代码。\n\nThe method area is created on virtual machine start-up.\n\nAlthough the method area is logically part of the heap【逻辑上是属于堆的一部分】, simple implementations may choose not to either garbage collect or compact it.\n垃圾回收不太会讨论方法区的垃圾回收\n\nIf memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an OutOfMemoryError.\n&gt;&gt; OOM\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>方法区是各个线程共享的内存区域，在虚拟机启动时创建。</strong></p>\n<p><strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong></p>\n<p><strong>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-Heap(非堆)，目 的是与Java堆区分开来。</strong></p>\n<p><strong>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</strong></p>\n<blockquote>\n<p>此时回看装载阶段的第2步：(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据 结构</p>\n</blockquote>\n<p>如果这时候把从Class文件到装载的第(1)和(2)步合并起来理解的话，可以画个图</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309211440247.png\" alt=\"image-20220309211440247\" /></p>\n<p><strong>(1)方法区在JDK 8中就是Metaspace，在JDK6或7中就是Perm Space (2)Run-Time Constant Pool</strong></p>\n<p><strong>(2)Run-Time Constant Pool</strong></p>\n<p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，</p>\n<p>还有一项信息就是常量池，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在 类加载后进 入方法区的运行时常量池中存放。</p>\n<blockquote>\n<p>Each run-time constant pool is allocated from the Java Virtual Machine's method area (§2.5.4).s</p>\n<p>每个运行时常量池都是从 Java 虚拟机的方法中分配的区域 (§2.5.4).s</p>\n</blockquote>\n<h4 id=\"_5-3-2-heap-堆-对象或者数组\"> 5.3.2 Heap(堆):对象或者数组</h4>\n<p>Java堆是Java虚拟机所管理内存中最大的一块，在虚拟机启动时创建，被所有线程共享。</p>\n<p>Java对象实例以及数组都在堆上分配。</p>\n<div><pre><code>The Java Virtual Machine has a heap that is shared among all Java Virtual Machine threads. \n堆只有一个，线程共享内存区域的【线程非安全】，生命周期跟虚拟机一样。\n\nThe heap is the run-time data area from which memory for all class instances and arrays is allocated.\n存储数据包括：对象或者数组\n\nThe heap is created on virtual machine start-up. \n\nIf a computation requires more heap than can be made available by the automatic storage management system, the Java Virtual Machine throws an OutOfMemoryError.\n【如果内存不够，也会发生OOM】\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>此时回看装载阶段的第3步：(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方 法区中这些数据的访问入口</p>\n<p>此时装载(1)(2)(3)的图可以改动一下</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309211847128.png\" alt=\"image-20220309211847128\" /></p>\n<h4 id=\"_5-3-3-java-virtual-machine-stacks-虚拟机栈-局部变量、操作数、返回数\"> 5.3.3 Java Virtual Machine Stacks(虚拟机栈):局部变量、操作数、返回数</h4>\n<div><pre><code>Each Java Virtual Machine thread has a private Java Virtual Machine stack,\ncreated at the same time as the thread. A Java Virtual Machine stack stores\nframes (§2.6)\n【每个线程独有的线程栈】\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一个线程的创建代表一个栈，每个方法被当前线程调用了，就代表一个栈帧。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309220003612.png\" alt=\"image-20220309220003612\" /></p>\n<div><pre><code>If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a StackOverflowError.\n【StackOverflowError】\n\nIf Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an OutOfMemoryError.\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<p>经过上面的分析，类加载机制的装载过程已经完成，后续的链接，初始化也会相应的生效。</p>\n<p>假如目前的阶段是初始化完成了，后续做啥呢？肯定是Use使用咯，不用的话这样折腾来折腾去 有什么意义？那怎样才能被使用到？换句话说里面内容怎样才能被执行？比如通过主函数main调 用其他方法，这种方式实际上是main线程执行之后调用的方法，即要想使用里面的各种内容，得 要以线程为单位，执行相应的方法才行。</p>\n<p>那一个线程执行的状态如何维护？一个线程可以执行多少个方法？这样的关系怎么维护呢？</p>\n</blockquote>\n<p>虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。换句话说，一个Java线程的运行 状态，由一个虚拟机栈来保存，所以虚拟机栈肯定是线程私有的，独有的，随着线程的创建而创建。</p>\n<p>每一个被线程执行的方法，为该栈中的栈帧，即每个方法对应一个栈帧。</p>\n<p>调用一个方法，就会向栈中压入一个栈帧；一个方法调用完成，就会把该栈帧从栈中弹出。</p>\n<h4 id=\"_5-3-4-the-pc-register-程序计数器\"> 5.3.4 The pc Register(程序计数器)</h4>\n<blockquote>\n<p>我们都知道一个JVM进程中有多个线程在执行，而线程中的内容是否能够拥有执行权，是根据 CPU调度来的。</p>\n<p>假如线程A正在执行到某个地方，突然失去了CPU的执行权，切换到线程B了，然后当线程A再获 得CPU执行权的时候，怎么能继续执行呢？这就是需要在线程中维护一个变量，记录线程执行到 的位置。</p>\n</blockquote>\n<p>程序计数器占用的内存空间很小，由于Java虚拟机的多线程是通过线程轮流切换，并分配处理器执行时 间的方式来实现的，在任意时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能够 恢复到正确的执行位置，每条线程需要有一个独立的程序计数器(线程私有)。</p>\n<p>如果线程正在执行Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；</p>\n<p>如果正在执行的是Native方法，则这个计数器为空。</p>\n<div><pre><code>The Java Virtual Machine can support many threads of execution at once (JLS §17). Each Java Virtual Machine thread has its own pc (program counter)register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method (§2.6) for that thread. If that method is not native, the pc register contains the address of the Java Virtual Machine instruction currently being executed. If the method currently being executed by the thread is native, the value of the Java Virtual Machine&#39;s pcregister is undefined. The Java Virtual Machine&#39;s pc register is wide enough to hold a returnAddress or a native pointer on the specific platform\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_5-3-5-native-method-stacks-本地方法栈\"> 5.3.5 Native Method Stacks(本地方法栈)</h4>\n<div><pre><code>An implementation of the Java Virtual Machine may use conventional stacks, colloquially called &quot;C stacks,&quot; to support native methods (methods written in a language other than the Java programming language).\n\n&gt;&gt; Java 虚拟机的实现可以使用传统的堆栈，通俗地称为“C 堆栈”，以支持本地方法（以 Java 编程语言以外的语言编写的方法）\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果当前线程执行的方法是Native类型的，这些方法就会在本地方法栈中执行。</p>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310000943157.png",
      "date_published": "2022-05-05T10:22:38.000Z",
      "date_modified": "2022-07-02T17:06:40.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM进行时-JVM堆栈内存详解",
      "url": "https://www.moremind.cn/md/java/jvm/JVM-2/",
      "id": "https://www.moremind.cn/md/java/jvm/JVM-2/",
      "content_html": "<h2 id=\"_1-结合字节码指令理解java虚拟机栈和栈帧\"> 1 结合字节码指令理解Java虚拟机栈和栈帧</h2>\n<blockquote>\n<p>官网 ：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6</p>\n<p>栈帧：每个栈帧对应一个被调用的方法，可以理解为一个方法的运行空间。</p>\n</blockquote>\n<p>每个栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向运行时常量池的引用(A reference to the run-time constant pool)、方法返回地址(Return Address)和附加信息。</p>\n<div><pre><code>每个栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向运行时常量池的引用(A reference to the run-time constant pool)、方法返回地址(Return Address)和附加信息。\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>操作数栈:以压栈和出栈的方式存储操作数的\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>动态链接:每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>方法返回地址:当一个方法开始执行后,只有两种方式可以退出，一种是遇到方法返回的字节码指令；一种是遇见异常，并且这个异常没有在方法体内得到处理。\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309223600414.png\" alt=\"image-20220309223600414\" /></p>\n<div><pre><code><span>class</span> <span>Person</span><span>{</span>\n    <span>private</span> <span>String</span> name<span>=</span><span>\"Jack\"</span><span>;</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n    <span>private</span> <span>final</span> <span>double</span> salary<span>=</span><span>100</span><span>;</span>\n    <span>private</span> <span>static</span> <span>String</span> address<span>;</span>\n    <span>private</span> <span>final</span> <span>static</span> <span>String</span> hobby<span>=</span><span>\"Programming\"</span><span>;</span>\n    <span>public</span> <span>void</span> <span>say</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"person say...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>int</span> <span>calc</span><span>(</span><span>int</span> op1<span>,</span><span>int</span> op2<span>)</span><span>{</span>\n        op1<span>=</span><span>3</span><span>;</span>\n        <span>int</span> result<span>=</span>op1<span>+</span>op2<span>;</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>order</span><span>(</span><span>)</span><span>{</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>\n        <span>calc</span><span>(</span><span>1</span><span>,</span><span>2</span><span>)</span><span>;</span>\n        <span>order</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>\n<p>此时你需要一个能够看懂反编译指令的宝典</p>\n<p>比如官网的：https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</p>\n</blockquote>\n<div><pre><code><span>class</span> <span>Person</span> <span>{</span>\n  <span>Person</span><span>(</span><span>)</span><span>;</span>\n    <span>Code</span><span>:</span>\n       <span>0</span><span>:</span> aload_0\n       <span>1</span><span>:</span> invokespecial #<span>1</span>                  <span>// Method java/lang/Object.\"&lt;init>\":()V</span>\n       <span>4</span><span>:</span> aload_0\n       <span>5</span><span>:</span> ldc           #<span>2</span>                  <span>// String Jack</span>\n       <span>7</span><span>:</span> putfield      #<span>3</span>                  <span>// Field name:Ljava/lang/String;</span>\n      <span>10</span><span>:</span> aload_0\n      <span>11</span><span>:</span> ldc2_w        #<span>4</span>                  <span>// double 100.0d</span>\n      <span>14</span><span>:</span> putfield      #<span>6</span>                  <span>// Field salary:D</span>\n      <span>17</span><span>:</span> <span>return</span>\n\n  <span>public</span> <span>void</span> <span>say</span><span>(</span><span>)</span><span>;</span>\n    <span>Code</span><span>:</span>\n       <span>0</span><span>:</span> getstatic     #<span>7</span>                  <span>// Field java/lang/System.out:Ljava/io/PrintStream;</span>\n       <span>3</span><span>:</span> ldc           #<span>8</span>                  <span>// String person say...</span>\n       <span>5</span><span>:</span> invokevirtual #<span>9</span>                  <span>// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>\n       <span>8</span><span>:</span> <span>return</span>\n\n  <span>public</span> <span>static</span> <span>int</span> <span>calc</span><span>(</span><span>int</span><span>,</span> <span>int</span><span>)</span><span>;</span>\n    <span>Code</span><span>:</span>\n       <span>0</span><span>:</span> iconst_3  <span>//将int类型常量3压入[操作数栈]</span>\n       <span>1</span><span>:</span> istore_0  <span>//将int类型值存入局部变量表[局部变量0] ==> op = 3</span>\n       <span>2</span><span>:</span> iload_0   <span>//从[局部变量0]中装载int类型值入栈</span>\n       <span>3</span><span>:</span> iload_1   <span>//从[局部变量1]中装载int类型值入栈</span>\n       <span>4</span><span>:</span> iadd      <span>//将栈顶元素弹出栈，执行int类型的加法，结果入栈</span>\n       <span>5</span><span>:</span> istore_2  <span>//将栈顶int类型值保存到[局部变量2]中</span>\n       <span>6</span><span>:</span> iload_2   <span>//从[局部变量2]中装载int类型值入栈</span>\n       <span>7</span><span>:</span> ireturn   <span>//从方法中返回int类型的数据</span>\n\n  <span>public</span> <span>static</span> <span>void</span> <span>order</span><span>(</span><span>)</span><span>;</span>\n    <span>Code</span><span>:</span>\n       <span>0</span><span>:</span> <span>return</span>\n\n  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span><span>java<span>.</span>lang<span>.</span></span>String</span><span>[</span><span>]</span><span>)</span><span>;</span>\n    <span>Code</span><span>:</span>\n       <span>0</span><span>:</span> iconst_1\n       <span>1</span><span>:</span> iconst_2\n       <span>2</span><span>:</span> invokestatic  #<span>10</span>                 <span>// Method calc:(II)I</span>\n       <span>5</span><span>:</span> pop\n       <span>6</span><span>:</span> invokestatic  #<span>11</span>                 <span>// Method order:()V</span>\n       <span>9</span><span>:</span> <span>return</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309223510002.png\" alt=\"image-20220309223510002\" /></p>\n<h2 id=\"_2-折腾一下\"> 2 折腾一下</h2>\n<h3 id=\"_2-1栈指向堆\"> 2.1栈指向堆</h3>\n<p>如果在栈帧中有一个变量，类型为引用类型，比如Object obj=new Object()，这时候就是典型的栈中元素指向堆中的对象。</p>\n<div><pre><code><span>class</span> <span>Person</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>order</span><span>(</span><span>)</span> <span>{</span>\n        <span>Object</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309230040459.png\" alt=\"image-20220309230040459\" /></p>\n<h3 id=\"_2-2-方法区指向堆\"> 2.2 方法区指向堆</h3>\n<p>方法区中会存放静态变量，常量等数据。如果是下面这种情况，就是典型的方法区中元素指向堆中的对象。</p>\n<div><pre><code><span>class</span> <span>Person</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>Object</span> obj<span>=</span><span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span> <span>// 方法区指向堆</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309230410111.png\" alt=\"image-20220309230410111\" /></p>\n<h3 id=\"_2-3-堆指向方法区\"> 2.3 堆指向方法区</h3>\n<p>方法区中会包含类的信息，堆中会有对象，那怎么知道对象是哪个类创建的呢？</p>\n<p>思考 ：一个对象怎么知道它是由哪个类创建出来的？怎么记录？这就需要了解一个Java对象的具体信息咯。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309230858070.png\" alt=\"image-20220309230858070\" /></p>\n<h3 id=\"_2-4-java对象内存布局\"> 2.4 Java对象内存布局</h3>\n<p>一个Java对象在内存中包括3个部分：对象头、实例数据和对齐填充</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309230913143.png\" alt=\"image-20220309230913143\" /></p>\n<h2 id=\"_3-内存模型\"> 3 内存模型</h2>\n<h3 id=\"_3-1-图解\"> 3.1 图解</h3>\n<div><pre><code>一块是非堆区，一块是堆区。\n堆区分为两大块，一个是Old区，一个是Young区。\nYoung区分为两大块，一个是Survivor区（S0+S1），一块是Eden区。 Eden:S0:S1=8:1:1\nS0和S1一样大，也可以叫From和To。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309233401625.png\" alt=\"image-20220309233401625\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309233506458.png\" alt=\"image-20220309233506458\" /></p>\n<p>根据之前对于Heap的介绍可以知道，一般对象和数组的创建会在堆中分配内存空间，关键是堆中有这么多区 域，那一个对象的创建到底在哪个区域呢？</p>\n<h3 id=\"_3-2-对象创建所在区域\"> 3.2 对象创建所在区域</h3>\n<p>一般情况下，新创建的对象都会被分配到Eden区，一些特殊的大的对象会直接分配到Old区。</p>\n<blockquote>\n<p>比如有对象A，B，C等创建在Eden区，但是Eden区的内存空间肯定有限，比如有100M，假如已经使用了 100M或者达到一个设定的临界值，这时候就需要对Eden内存空间进行清理，即垃圾收集(Garbage Collect)， 这样的GC我们称之为Minor GC，Minor GC指得是Young区的GC。 经过GC之后，有些对象就会被清理掉，有些对象可能还存活着，对于存活着的对象需要将其复制到Survivor 区，然后再清空Eden区中的这些对象。</p>\n</blockquote>\n<h3 id=\"_3-3-survivor区详解\"> 3.3 Survivor区详解</h3>\n<p>由图解可以看出，Survivor区分为两块S0和S1，也可以叫做From和To。</p>\n<p>在同一个时间点上，S0和S1只能有一个区有数据，另外一个是空的。</p>\n<blockquote>\n<p>接着上面的GC来说，比如一开始只有Eden区和From中有对象，To中是空的。</p>\n<p>此时进行一次GC操作，From区中对象的年龄就会+1，我们知道Eden区中所有存活的对象会被复制到To区， From区中还能存活的对象会有两个去处。</p>\n<p>若对象年龄达到之前设置好的年龄阈值，此时对象会被移动到Old区，如果Eden区和From区没有达到阈值的</p>\n<p>对象会被复制到To区。 此时Eden区和From区已经被清空(被GC的对象肯定没了，没有被GC的对象都有了各 自的去处)</p>\n<p>这时候From和To交换角色，之前的From变成了To，之前的To变成了From。</p>\n<p>也就是说无论如何都要保证名为To的Survivor区域是空的。</p>\n<p>Minor GC会一直重复这样的过程，直到To区被填满，然后会将所有对象复制到老年代中。</p>\n</blockquote>\n<p>从上面的分析可以看出，一般Old区都是年龄比较大的对象，或者相对超过了某个阈值的对象。</p>\n<p>在Old区也会有GC的操作，Old区的GC我们称作为Major GC。</p>\n<h3 id=\"_3-4-old区详解\"> 3.4 Old区详解</h3>\n<p>从上面的分析可以看出，一般Old区都是年龄比较大的对象，或者相对超过了某个阈值的对象。 在Old区也会有GC的操作，Old区的GC我们称作为Major GC。</p>\n<h3 id=\"_3-5-对象的一辈子理解\"> 3.5 对象的一辈子理解</h3>\n<div><pre><code>我是一个普通的Java对象,我出生在Eden区,在Eden区我还看到和我长的很像的小兄弟,我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了,我就被迫去了Survivor区的“From”区,自从去了Survivor区,我就开始漂了,有时候在Survivor的“From”区,有时候在Survivor的“To”区,居无定所。直到我18岁的时候,爸爸说我成人了,该去社会上闯闯了。\n于是我就去了年老代那边,年老代里,人很多,并且年龄都挺大的,我在这里也认识了很多人。在年老代里,我生活了20年(每次GC加一岁),然后被回收。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309235221230.png\" alt=\"image-20220309235221230\" /></p>\n<h3 id=\"_3-6-常见问题\"> 3.6 常见问题</h3>\n<ul>\n<li>\n<p>如何理解Minor/Major/Full GC</p>\n<div><pre><code>Minor GC:新生代\nMajor GC:老年代\nFull GC:新生代+老年代\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>\n<li>\n<p>为什么需要Survivor区?只有Eden不行吗？</p>\n<div><pre><code>如果没有Survivor,Eden区每进行一次Minor GC,并且没有年龄限制的话，存活的对象就会被送到老年代。\n这样一来，老年代很快被填满,触发Major GC(因为Major GC一般伴随着Minor GC,也可以看做触发了Full GC)。\n老年代的内存空间远大于新生代,进行一次Full GC消耗的时间比Minor GC长得多。\n执行时间长有什么坏处?频发的Full GC消耗的时间很长,会影响大型程序的执行和响应速度。\n\n可能你会说，那就对老年代的空间进行增加或者较少咯。\n假如增加老年代空间，更多存活对象才能填满老年代。虽然降低Full GC频率，但是随着老年代空间加大,一旦发生Full GC,执行所需要的时间更长。\n假如减少老年代空间，虽然Full GC所需时间减少，但是老年代很快被存活对象填满,Full GC频率增加。\n\n所以Survivor的存在意义,就是减少被送到老年代的对象,进而减少Full GC的发生,Survivor的预筛选保证,只有经历16次Minor GC还能在新生代中存活的对象,才会被送到老年代。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>\n<li>\n<p>为什么需要两个Survivor区?</p>\n<div><pre><code>最大的好处就是解决了碎片化。也就是说为什么一个Survivor区不行?第一部分中,我们知道了必须设置Survivor区。假设现在只有一个Survivor区,我们来模拟一下流程:\n刚刚新建的对象在Eden中,一旦Eden满了,触发一次Minor GC,Eden中的存活对象就会被移动Survivor区。这样继续循环下去,下一次Eden满了的时候,问题来了,此时进行Minor GC,Eden和Survivor各有一些存活对象,如果此时把Eden区的存活对象硬放到Survivor区,很明显这两部分对象所占有的内存是不连续的,也就导致了内存碎片化。\n永远有一个Survivor space是空的,另一个非空的Survivor space无碎片。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>\n<li>\n<p>新生代中Eden:S1:S2为什么是8:1:1？</p>\n<div><pre><code>新生代中的可用内存：复制算法用来担保的内存为9：1\n可用内存中Eden：S1区为8：1\n即新生代中Eden:S1:S2 = 8：1：1\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>\n</ul>\n<h2 id=\"_4-体验与验证\"> 4 体验与验证</h2>\n<h3 id=\"_4-1-使用jvisualvm查看\"> 4.1 使用jvisualvm查看</h3>\n<p>visualgc插件下载链接 ： https://visualvm.github.io/pluginscenters.html ---&gt;选择对应版本链接---&gt;Tools---&gt;Visual GC</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310000015238.png\" alt=\"image-20220310000015238\" /></p>\n<h3 id=\"_4-1-堆内存溢出\"> 4.1 堆内存溢出</h3>\n<h4 id=\"_4-1-1-代码\"> 4.1.1 代码</h4>\n<div><pre><code><span>@RestController</span>\n<span>public</span> <span>class</span> <span>HeapController</span> <span>{</span>\n    <span>List</span><span><span>&lt;</span><span>Person</span><span>></span></span> list<span>=</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Person</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>@GetMapping</span><span>(</span><span>\"/heap\"</span><span>)</span>\n    <span>public</span> <span>String</span> <span>heap</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>{</span>\n        <span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>\n            list<span>.</span><span>add</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>\n<p>记得设置参数比如-Xmx20M -Xms20M</p>\n</blockquote>\n<h4 id=\"_4-1-2-运行结果\"> 4.1.2 运行结果</h4>\n<p>访问-&gt;http://localhost:8080/heap</p>\n<blockquote>\n<p>Exception in thread &quot;http-nio-8080-exec-2&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</p>\n</blockquote>\n<h3 id=\"_4-2-方法区内存溢出\"> 4.2 方法区内存溢出</h3>\n<blockquote>\n<p>比如向方法区中添加Class的信息</p>\n</blockquote>\n<h4 id=\"_4-2-1-asm依赖和class代码\"> 4.2.1 asm依赖和Class代码</h4>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n   <span><span><span>&lt;</span>groupId</span><span>></span></span>asm<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n   <span><span><span>&lt;</span>artifactId</span><span>></span></span>asm<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n   <span><span><span>&lt;</span>version</span><span>></span></span>3.3.1<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>MetaspaceUtil</span> <span>extends</span> <span>ClassLoader</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>List</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> <span>createClasses</span><span>(</span><span>)</span> <span>{</span>\n        <span>List</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> classes <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10000000</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n            <span>ClassWriter</span> cw <span>=</span> <span>new</span> <span>ClassWriter</span><span>(</span><span>0</span><span>)</span><span>;</span>\n            cw<span>.</span><span>visit</span><span>(</span><span>Opcodes</span><span>.</span>V1_1<span>,</span> <span>Opcodes</span><span>.</span>ACC_PUBLIC<span>,</span> <span>\"Class\"</span> <span>+</span> i<span>,</span> <span>null</span><span>,</span>\n                    <span>\"java/lang/Object\"</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n            <span>MethodVisitor</span> mw <span>=</span> cw<span>.</span><span>visitMethod</span><span>(</span><span>Opcodes</span><span>.</span>ACC_PUBLIC<span>,</span> <span>\"&lt;init>\"</span><span>,</span>\n                    <span>\"()V\"</span><span>,</span> <span>null</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n            mw<span>.</span><span>visitVarInsn</span><span>(</span><span>Opcodes</span><span>.</span>ALOAD<span>,</span> <span>0</span><span>)</span><span>;</span>\n            mw<span>.</span><span>visitMethodInsn</span><span>(</span><span>Opcodes</span><span>.</span>INVOKESPECIAL<span>,</span> <span>\"java/lang/Object\"</span><span>,</span>\n                    <span>\"&lt;init>\"</span><span>,</span> <span>\"()V\"</span><span>)</span><span>;</span>\n            mw<span>.</span><span>visitInsn</span><span>(</span><span>Opcodes</span><span>.</span>RETURN<span>)</span><span>;</span>\n            mw<span>.</span><span>visitMaxs</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>;</span>\n            mw<span>.</span><span>visitEnd</span><span>(</span><span>)</span><span>;</span>\n            <span>MetaspaceUtil</span> test <span>=</span> <span>new</span> <span>MetaspaceUtil</span><span>(</span><span>)</span><span>;</span>\n            <span>byte</span><span>[</span><span>]</span> code <span>=</span> cw<span>.</span><span>toByteArray</span><span>(</span><span>)</span><span>;</span>\n            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> exampleClass <span>=</span> test<span>.</span><span>defineClass</span><span>(</span><span>\"Class\"</span> <span>+</span> i<span>,</span> code<span>,</span> <span>0</span><span>,</span> code<span>.</span>length<span>)</span><span>;</span>\n            classes<span>.</span><span>add</span><span>(</span>exampleClass<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> classes<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h4 id=\"_4-2-2-代码\"> 4.2.2 代码</h4>\n<div><pre><code><span>@RestController</span>\n<span>public</span> <span>class</span> <span>NonHeapController</span> <span>{</span>\n    <span>List</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> list<span>=</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>@GetMapping</span><span>(</span><span>\"/nonheap\"</span><span>)</span>\n    <span>public</span> <span>String</span> <span>heap</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>{</span>\n        <span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>\n            list<span>.</span><span>addAll</span><span>(</span><span>MetaspaceUtil</span><span>.</span><span>createClasses</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id=\"_4-2-3-运行结果\"> 4.2.3 运行结果</h4>\n<blockquote>\n<p>访问-&gt;http://localhost:8080/nonheap</p>\n</blockquote>\n<div><pre><code>java.lang.OutOfMemoryError: Metaspace\nat java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_191]\nat java.lang.ClassLoader.defineClass(ClassLoader.java:763) ~[na:1.8.0_191]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_4-3-虚拟机栈\"> 4.3 虚拟机栈</h3>\n<h4 id=\"_4-3-1-代码演示stackoverflow\"> 4.3.1 代码演示StackOverFlow</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>StackOverFlowDemo</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>long</span> count<span>=</span><span>0</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>method</span><span>(</span><span>long</span> i<span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>count<span>++</span><span>)</span><span>;</span>\n        <span>method</span><span>(</span>i<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>method</span><span>(</span><span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id=\"_4-3-2-运行结果\"> 4.3.2 运行结果</h4>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310000555900.png\" alt=\"image-20220310000555900\" /></p>\n<h4 id=\"_4-3-3-理解和说明\"> 4.3.3 理解和说明</h4>\n<div><pre><code>Stack Space用来做方法的递归调用时压入Stack Frame(栈帧)。所以当递归调用太深的时候，就有可能耗尽StackSpace，爆出StackOverflow的错误。\n\n-Xss128k：设置每个线程的堆栈大小。JDK 5以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。\n\n线程栈的大小是个双刃剑，如果设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢出的可能性更大，如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的错误。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309223600414.png",
      "date_published": "2022-05-05T10:22:38.000Z",
      "date_modified": "2022-07-02T17:06:40.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM升华-JVM垃圾回收算法以及垃圾回收器",
      "url": "https://www.moremind.cn/md/java/jvm/JVM-3/",
      "id": "https://www.moremind.cn/md/java/jvm/JVM-3/",
      "content_html": "<h2 id=\"_1-garbage-collect-垃圾回收\"> 1 Garbage Collect(垃圾回收)</h2>\n<p>GC Root:虚拟机栈中的本地变量、static成员、常量引用、本地方法栈[Thread C]中的变量</p>\n<p>类加载器：如果它找到一条路线，能到到达某个对象，也不能称为垃圾。</p>\n<p>Thread:Java进程(线程)</p>\n<h3 id=\"_1-1-如何确定一个对象是垃圾\"> 1.1 如何确定一个对象是垃圾？</h3>\n<h4 id=\"_1-1-1-引用计数法\"> 1.1.1 引用计数法</h4>\n<p>对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任 何指针对其 引用，它就是垃圾。</p>\n<blockquote>\n<p>弊端 :如果AB相互持有引用，导致永远不能被回收。</p>\n</blockquote>\n<h4 id=\"_1-1-2-可达性分析\"> 1.1.2 可达性分析</h4>\n<p>通过GC Root的对象，开始向下寻找，看某个对象是否可达</p>\n<blockquote>\n<p>能作为GC Root:类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法 栈的变量等。</p>\n</blockquote>\n<h3 id=\"_1-2-垃圾收集算法\"> 1.2 垃圾收集算法</h3>\n<h4 id=\"_1-2-1-标记-清除-mark-sweep\"> 1.2.1 标记-清除(Mark-Sweep)</h4>\n<ul>\n<li>标记</li>\n</ul>\n<p>找出内存中需要回收的对象，并且把它们标记出来</p>\n<blockquote>\n<p>此时堆中所有的对象都会被扫描一遍，从而才能确定需要回收的对象，比较耗时</p>\n</blockquote>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004158070.png\" alt=\"image-20220310004158070\" /></p>\n<ul>\n<li>清除</li>\n</ul>\n<p>清除掉被标记需要回收的对象，释放出对应的内存空间</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004225334.png\" alt=\"image-20220310004225334\" /></p>\n<p>缺点：</p>\n<div><pre><code>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n(1)标记和清除两个过程都比较耗时，效率不高\n(2)会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"_1-2-2-复制-copying\"> 1.2.2 复制(Copying)</h4>\n<p>将内存划分为两块相等的区域，每次只使用其中一块，如下图所示：</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004419137.png\" alt=\"image-20220310004419137\" /></p>\n<p>当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存空间一次 清除掉。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004442121.png\" alt=\"image-20220310004442121\" /></p>\n<p>缺点: 空间利用率降低。</p>\n<h4 id=\"_1-2-3-标记-整理-mark-compact\"> 1.2.3 标记-整理(Mark-Compact)</h4>\n<p>标记过程仍然与&quot;标记-清除&quot;算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活 的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004604646.png\" alt=\"image-20220310004604646\" /></p>\n<p>让所有存活的对象都向一端移动，清理掉边界意外的内存。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004633487.png\" alt=\"image-20220310004633487\" /></p>\n<h3 id=\"_1-3-分代收集算法\"> 1.3 分代收集算法</h3>\n<p><strong>Young区：复制算法</strong>(对象在被分配之后，可能生命周期比较短，Young区复制效率比较高)</p>\n<p><strong>Old区：标记清除或标记整理</strong>(Old区对象存活时间比较长，复制来复制去没必要，不如做个标记再清理)</p>\n<h3 id=\"_1-4-垃圾收集器\"> 1.4 垃圾收集器</h3>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004914409.png\" alt=\"image-20220310004914409\" /></p>\n<h4 id=\"_1-4-1-serial收集器\"> 1.4.1 Serial收集器</h4>\n<p>Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯 一选择。</p>\n<p>它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更 重要的是其在进行垃圾收集的时候需要暂停其他线程。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310204357425.png\" alt=\"image-20220310204357425\" /></p>\n<h4 id=\"_1-4-2-parnew收集器\"> 1.4.2 ParNew收集器</h4>\n<div><pre><code>优点：在多CPU时，比Serial效率高。\n缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。\n算法：复制算法\n适用范围：新生代\n应用：运行在Server模式下的虚拟机中首选的新生代收集器\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310204622369.png\" alt=\"image-20220310204622369\" /></p>\n<h4 id=\"_1-4-3-parallel-scavenge收集器\"> 1.4.3 Parallel Scavenge收集器</h4>\n<p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集 器，看上去和ParNew一样，但是<strong>Parallel Scanvenge更关注系统的吞吐量 。</strong></p>\n<div><pre><code>吞吐量=运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)\n比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=(100-1)/100=99%。\n若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code>-XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间，\n-XX:GCTimeRatio直接设置吞吐量的大小。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_1-4-4-serial-old收集器\"> 1.4.4 Serial Old收集器</h4>\n<p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是<strong>采用&quot;标记-整理算 法&quot;</strong>，运行过程和Serial收集器一样。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310205235758.png\" alt=\"image-20220310205235758\" /></p>\n<h4 id=\"_1-4-5-parallel-old收集器\"> 1.4.5 Parallel Old收集器</h4>\n<p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，<strong>使用多线程和&quot;标记-整理算法&quot;进行垃圾 回收。</strong></p>\n<h4 id=\"_1-4-6-cms收集器\"> 1.4.6 CMS收集器</h4>\n<p><strong>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间 为目标的收集器。</strong></p>\n<p>采用的是&quot;标记-清除算法&quot;,整个过程分为4步</p>\n<div><pre><code>(1)初始标记 CMS initial mark \t\t标记GC Roots能关联到的对象 Stop The World---&gt;速度很快\n(2)并发标记 CMS concurrent mark \t进行GC Roots Tracing\n(3)重新标记 CMS remark \t\t\t\t修改并发标记因用户程序变动的内容 Stop The World\n4)并发清除 CMS concurrent sweep\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>\n<p>由于整个过程中，并发标记和并发清除，收集器线程可以与用户线程一起工作，所以总体上来 说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。</p>\n</blockquote>\n<div><pre><code>优点：并发收集、低停顿\n缺点：产生大量空间碎片、并发阶段会降低吞吐量\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310210434471.png\" alt=\"image-20220310210434471\" /></p>\n<h4 id=\"_1-4-7-g1收集器\"> 1.4.7 G1收集器</h4>\n<ul>\n<li>G1特点:</li>\n</ul>\n<div><pre><code>并行与并发\n分代收集（仍然保留了分代的概念）\n空间整合（整体上属于“标记-整理”算法，不会导致空间碎片）\n可预测的停顿（比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>使用G1收集器时，Java堆的内存布局与就与其他收集器有很大差别，它将整个Java堆划分为多个 大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再 是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>\n<ul>\n<li>工作过程分为以下几个阶段：</li>\n</ul>\n<div><pre><code>初始标记（Initial Marking） 标记一下GC Roots能够关联的对象，并且修改TAMS的值，需要暂停用户线程\n并发标记（Concurrent Marking） 从GC Roots进行可达性分析，找出存活的对象，与用户线程并发执行\n最终标记（Final Marking） 修正在并发标记阶段因为用户程序的并发执行导致变动的数据，需暂停用户线程\n筛选回收（Live Data Counting and Evacuation） 对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310211903812.png\" alt=\"image-20220310211903812\" /></p>\n<ul>\n<li>判断是否需要使用G1收集器？</li>\n</ul>\n<div><pre><code>（1）50%以上的堆被存活对象占用\n（2）对象分配和晋升的速度变化非常大\n（3）垃圾回收时间比较长\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"_1-4-8-垃圾收集器分类\"> 1.4.8 垃圾收集器分类</h4>\n<ul>\n<li>串行收集器-&gt;Serial和Serial Old</li>\n</ul>\n<p>只能有一个垃圾回收线程执行，用户线程暂停。 适用于内存比较小的嵌入式设备 。</p>\n<ul>\n<li>并行收集器[吞吐量优先]-&gt;Parallel Scanvenge、Parallel Old</li>\n</ul>\n<p>多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 适用于科学计算、后台处理等若交互场 景 。</p>\n<ul>\n<li>并发收集器[停顿时间优先]-&gt;CMS、G1</li>\n</ul>\n<p>用户线程和垃圾收集线程同时执行(但并不一定是并行的，可能是交替执行的)，垃圾收集线程在执行的 时候不会停顿用户线程的运行。 适用于相对时间有要求的场景，比如Web 。</p>\n<h4 id=\"_1-4-9-理解吞吐量和停顿时间\"> 1.4.9 理解吞吐量和停顿时间</h4>\n<ul>\n<li>停顿时间-&gt;垃圾收集器 进行 垃圾回收终端应用执行响应的时间</li>\n<li>吞吐量-&gt;运行用户代码时间/(运行用户代码时间+垃圾收集时间)</li>\n</ul>\n<div><pre><code>停顿时间越短就越适合需要和用户交互的程序，良好的响应速度能提升用户体验；\n高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_1-4-10-如何选择合适的垃圾收集器\"> 1.4.10 如何选择合适的垃圾收集器</h4>\n<p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28\" target=\"_blank\" rel=\"noopener noreferrer\">Available Collectors (oracle.com)</a></p>\n<ul>\n<li>优先调整堆的大小让服务器自己来选择</li>\n<li>如果内存小于100M，使用串行收集器</li>\n<li>如果是单核，并且没有停顿时间要求，使用串行或JVM自己选</li>\n<li>如果允许停顿时间超过1秒，选择并行或JVM自己选</li>\n<li>如果响应时间最重要，并且不能超过1秒，使用并发收集器 G1收集</li>\n</ul>\n<h4 id=\"_1-4-11-如何开启需要的垃圾收集器\"> 1.4.11 如何开启需要的垃圾收集器</h4>\n<div><pre><code>（1）串行\n    -XX：+UseSerialGC\n    -XX：+UseSerialOldGC\n（2）并行(吞吐量优先)：\n    -XX：+UseParallelGC\n    -XX：+UseParallelOldGC\n（3）并发收集器(响应时间优先)\n    -XX：+UseConcMarkSweepGC\n    -XX：+UseG1GC\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310004158070.png",
      "date_published": "2022-05-05T10:22:38.000Z",
      "date_modified": "2022-07-02T17:06:40.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM实战-JVM性能分析以及调优分析",
      "url": "https://www.moremind.cn/md/java/jvm/JVM-4/",
      "id": "https://www.moremind.cn/md/java/jvm/JVM-4/",
      "content_html": "<h1 id=\"_1-jvm实战篇\"> 1 JVM实战篇</h1>\n<h2 id=\"_1-1-jvm参数\"> 1.1 JVM参数</h2>\n<h4 id=\"_1-1-1-标准参数\"> 1.1.1 标准参数</h4>\n<div><pre><code>-version\n-help\n-server\n-cp\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id=\"_1-1-2-x参数\"> 1.1.2 -X参数</h4>\n<div><pre><code>-Xint 解释执行\n-Xcomp 第一次使用就编译成本地代码\n-Xmixed 混合模式，JVM自己来决定\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"_1-1-3-xx参数\"> 1.1.3 -XX参数</h4>\n<blockquote>\n<p>使用得最多的参数类型 非标准化参数，相对不稳定，主要用于JVM调优和Debug</p>\n</blockquote>\n<div><pre><code>a.Boolean类型\n格式：-XX:[+-]&lt;name&gt; +或-表示启用或者禁用name属性\n比如：-XX:+UseConcMarkSweepGC 表示启用CMS类型的垃圾回收器\n\t -XX:+UseG1GC 表示启用G1类型的垃圾回收器\n\n** b.非Boolean类型\n格式：-XX&lt;name&gt;=&lt;value&gt;表示name属性的值是value\n比如：-XX:MaxGCPauseMillis=500\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id=\"_1-1-4-其他参数\"> 1.1.4 其他参数</h4>\n<div><pre><code>-Xms1000等价于-XX:InitialHeapSize=1000\n-Xmx1000等价于-XX:MaxHeapSize=1000\n-Xss100等价于-XX:ThreadStackSize=100\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id=\"_1-1-5-查看参数\"> 1.1.5 查看参数</h4>\n<blockquote>\n<p><strong>java -XX:+PrintFlagsFinal -version &gt; flags.txt</strong></p>\n</blockquote>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310215001216.png\" alt=\"\" /></p>\n<h4 id=\"_1-1-6-设置参数的方式\"> 1.1.6 设置参数的方式</h4>\n<ul>\n<li>\n<p>开发工具中设置比如IDEA，eclipse</p>\n</li>\n<li>\n<p>运行jar包的时候:java -XX:+UseG1GC xxx.jar</p>\n</li>\n<li>\n<p>web容器比如tomcat，可以在脚本中的进行设置</p>\n</li>\n<li>\n<p><strong>通过jinfo实时调整某个java进程的参数(参数只有被标记为manageable的flags可以被实时修改)</strong></p>\n</li>\n</ul>\n<h4 id=\"_1-1-7-实践和单位换算\"> 1.1.7 实践和单位换算</h4>\n<div><pre><code>1Byte(字节)=8bit(位)\n1KB=1024Byte(字节)\n1MB=1024KB\n1GB=1024MB\n1TB=1024GB\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>(1)设置堆内存大小和参数打印\n\t-Xmx100M -Xms100M -XX:+PrintFlagsFinal\n(2)查询+PrintFlagsFinal的值\n\t:=true\n(3)查询堆内存大小MaxHeapSize\n\t:= 104857600\n(4)换算\n104857600(Byte)/1024=102400(KB)\n102400(KB)/1024=100(MB)\n(5)结论\n\t104857600是字节单位\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id=\"_1-1-8-常用参数含义\"> 1.1.8 常用参数含义</h4>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220309162923416.png\" alt=\"image-20220309162923416\" /></p>\n<h2 id=\"_1-2-常用命令\"> 1.2 常用命令</h2>\n<h3 id=\"_1-2-1-jps\"> 1.2.1 jps</h3>\n<blockquote>\n<p>查看java进程</p>\n</blockquote>\n<h3 id=\"_1-2-2-jinfo\"> 1.2.2 jinfo</h3>\n<p>(1)实时查看和调整JVM配置参数</p>\n<p>(2)查看</p>\n<div><pre><code>jinfo -flag name PID 查看某个java进程的name属性的值\n</code></pre>\n<div><span>1</span><br></div></div><p>(3)修改</p>\n<blockquote>\n<p>参数只有被标记为manageable的flags可以被实时修改</p>\n<p>jinfo -flag [+|-] PID</p>\n<p>jinfo -flag = PID</p>\n</blockquote>\n<p>(4)查看曾经赋过值的一些参数</p>\n<div><pre><code>jinfo -flags PID\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_1-2-3-jstat\"> 1.2.3 jstat</h3>\n<p>(1)查看虚拟机性能统计信息</p>\n<p>(2)查看类装载信息</p>\n<div><pre><code>jstat -class PID 1000 10 查看某个java进程的类装载信息，每1000毫秒输出一次，共输出10次\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310220302064.png\" alt=\"image-20220310220302064\" /></p>\n<p>(3)查看垃圾收集信息</p>\n<div><pre><code>jstat -gc PID 1000 10\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310220241447.png\" alt=\"image-20220310220241447\" /></p>\n<h3 id=\"_1-2-4-jstack\"> 1.2.4 jstack</h3>\n<p>(1)查看线程堆栈信息</p>\n<p>(2)用法</p>\n<div><pre><code>jstack PID\n</code></pre>\n<div><span>1</span><br></div></div><p>(3) 排查死锁</p>\n<ul>\n<li>DeadLockDemo</li>\n</ul>\n<div><pre><code><span>//运行主类</span>\n<span>public</span> <span>class</span> <span>DeadLockDemo</span>\n<span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span>\n    <span>{</span>\n        <span>DeadLock</span> d1<span>=</span><span>new</span> <span>DeadLock</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>DeadLock</span> d2<span>=</span><span>new</span> <span>DeadLock</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>Thread</span> t1<span>=</span><span>new</span> <span>Thread</span><span>(</span>d1<span>)</span><span>;</span>\n        <span>Thread</span> t2<span>=</span><span>new</span> <span>Thread</span><span>(</span>d2<span>)</span><span>;</span>\n        t1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        t2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>//定义锁对象</span>\n<span>class</span> <span>MyLock</span><span>{</span>\n    <span>public</span> <span>static</span> <span>Object</span> obj1<span>=</span><span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n    <span>public</span> <span>static</span> <span>Object</span> obj2<span>=</span><span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>//死锁代码</span>\n<span>class</span> <span>DeadLock</span> <span>implements</span> <span>Runnable</span><span>{</span>\n    <span>private</span> <span>boolean</span> flag<span>;</span>\n    <span>DeadLock</span><span>(</span><span>boolean</span> flag<span>)</span><span>{</span>\n        <span>this</span><span>.</span>flag<span>=</span>flag<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span><span>(</span>flag<span>)</span> <span>{</span>\n            <span>while</span><span>(</span><span>true</span><span>)</span> <span>{</span>\n                <span>synchronized</span><span>(</span><span>MyLock</span><span>.</span>obj1<span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"----if获得obj1锁\"</span><span>)</span><span>;</span>\n                    <span>synchronized</span><span>(</span><span>MyLock</span><span>.</span>obj2<span>)</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"----if获得obj2锁\"</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>else</span> <span>{</span>\n            <span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>\n                <span>synchronized</span><span>(</span><span>MyLock</span><span>.</span>obj2<span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"----否则获得obj2锁\"</span><span>)</span><span>;</span>\n                    <span>synchronized</span><span>(</span><span>MyLock</span><span>.</span>obj1<span>)</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>+</span><span>\"----否则获得obj1锁\"</span><span>)</span><span>;</span>\n\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><ul>\n<li>jstack 分析</li>\n</ul>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310220950543.png\" alt=\"\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310221042830.png\" alt=\"image-20220310221042830\" /></p>\n<h3 id=\"_1-2-5-jmap\"> 1.2.5 jmap</h3>\n<p>(1)生成堆转储快照</p>\n<p>(2)打印出堆内存相关信息</p>\n<div><pre><code>1.设置：-XX:+PrintFlagsFinal -Xms300M -Xmx300M\n2.查看jmap -heap PID\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310221505262.png\" alt=\"image-20220310221505262\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310221521362.png\" alt=\"image-20220310221521362\" /></p>\n<p>(3)dump出堆内存相关信息、</p>\n<div><pre><code>jmap -dump:format=b,file=heap.hprof PID\njmap -dump:format=b,file=heap.hprof 44808\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310221914338.png\" alt=\"image-20220310221914338\" /></p>\n<p>(4)要是在发生堆内存溢出的时候，能自动dump出该文件就好了</p>\n<blockquote>\n<p>一般在开发中，JVM参数可以加上下面两句，这样内存溢出时，会自动dump出该文件</p>\n</blockquote>\n<div><pre><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>设置堆内存大小: -Xms20M -Xmx20M\n启动，然后访问localhost:9090/heap，使得堆内存溢出\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>(5)关于dump下来的文件</p>\n<p>一般dump下来的文件可以结合工具来分析</p>\n<h2 id=\"_1-3-常用工具\"> 1.3 常用工具</h2>\n<h3 id=\"_1-3-1-jconsole\"> 1.3.1 jconsole</h3>\n<p>JConsole工具是JDK自带的可视化监控工具。查看java应用程序的运行概况、监控堆信息、永久区使用 情况、类加载情况等。</p>\n<blockquote>\n<p>启动命令：jconsole</p>\n</blockquote>\n<h3 id=\"_1-3-2-jvisualvm\"> 1.3.2 jvisualvm</h3>\n<blockquote>\n<p>启动命令：jvisualvm</p>\n</blockquote>\n<h4 id=\"_1-3-2-1-监控本地java进程\"> 1.3.2.1 监控本地Java进程</h4>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310222954259.png\" alt=\"image-20220310222954259\" /></p>\n<h4 id=\"_1-3-2-2-监控远端java进程\"> 1.3.2.2 监控远端Java进程</h4>\n<blockquote>\n<p>比如监控远端tomcat，演示部署在阿里云服务器上的tomcat</p>\n</blockquote>\n<p>(1)在visualvm中选中“远程”，右击“添加”</p>\n<p>(2)主机名上写服务器的ip地址，比如31.100.39.63，然后点击“确定”</p>\n<p>(3)右击该主机“31.100.39.63”，添加“JMX”[也就是通过JMX技术具体监控远端服务器哪个Java进程]</p>\n<p>(4)要想让服务器上的tomcat被连接，需要改一下 bin/catalina.sh 这个文件</p>\n<div><pre><code><span>JAVA_OPTS</span><span>=</span><span>\"<span>$JAVA_OPTS</span> -Dcom.sun.management.jmxremote -\nDjava.rmi.server.hostname=31.100.39.63 -Dcom.sun.management.jmxremote.port=8998\n-Dcom.sun.management.jmxremote.ssl=false -\nDcom.sun.management.jmxremote.authenticate=true -\nDcom.sun.management.jmxremote.access.file=../conf/jmxremote.access -\nDcom.sun.management.jmxremote.password.file=../conf/jmxremote.password\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>(5)在 ../conf 文件中添加两个文件jmxremote.access和jmxremote.password</p>\n<blockquote>\n<p>jmxremote.access 文件</p>\n<div><pre><code>guest readonly\nmanager readwrite\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></blockquote>\n<blockquote>\n<p>jmxremote.password 文件</p>\n<div><pre><code>guest guest\nmanager manager\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></blockquote>\n<p>授予权限 : chmod 600 * jmxremot *</p>\n<p>(6)将连接服务器地址改为公网ip地址</p>\n<div><pre><code>hostname -i 查看输出情况\n172.26.225.240 172.17.0.1\nvim /etc/hosts\n172.26.255.240 31.100.39.63\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>(7)设置上述端口对应的阿里云安全策略和防火墙策略</p>\n<p>(8)启动tomcat，来到bin目录</p>\n<div><pre><code>./startup.sh\t\n</code></pre>\n<div><span>1</span><br></div></div><p>(9)查看tomcat启动日志以及端口监听</p>\n<div><pre><code><span>tail</span> -f <span>..</span>/logs/catalina.out\n<span>lsof</span> -i tcp:8080\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>(10)查看8998监听情况，可以发现多开了几个端口</p>\n<div><pre><code>lsof -i:8998 得到PID\nnetstat -antup | grep PID\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>(11)在刚才的JMX中输入8998端口，并且输入用户名和密码则登录成功</p>\n<div><pre><code>端口:8998\n用户名:manager\n密码:manager\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_1-3-3-arthas\"> 1.3.3 Arthas</h3>\n<blockquote>\n<p>github ：https://github.com/alibaba/arthas</p>\n</blockquote>\n<blockquote>\n<p>Arthas 是Alibaba开源的Java诊断工具，采用命令行交互模式，是排查jvm相关问题的利器。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310224532713.png\" alt=\"\" /></p>\n</blockquote>\n<h4 id=\"_1-3-3-1-下载安装\"> 1.3.3.1 下载安装</h4>\n<div><pre><code>curl -O https://alibaba.github.io/arthas/arthas-boot.jar\njava -jar arthas-boot.jar\n# 然后可以选择一个Java进程\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Print usage</p>\n<div><pre><code>java -jar arthas-boot.jar -h\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_1-3-3-2-常用命令\"> 1.3.3.2 常用命令</h4>\n<div><pre><code>version:查看arthas版本号\nhelp:查看命名帮助信息\ncls:清空屏幕\nsession:查看当前会话信息\nquit:退出arthas客户端\n---\ndashboard:当前进程的实时数据面板\nthread:当前JVM的线程堆栈信息\njvm:查看当前JVM的信息\nsysprop:查看JVM的系统属性\n---\nsc:查看JVM已经加载的类信息\ndump:dump已经加载类的byte code到特定目录\njad:反编译指定已加载类的源码\n---\nmonitor:方法执行监控\nwatch:方法执行数据观测\ntrace:方法内部调用路径，并输出方法路径上的每个节点上耗时\nstack:输出当前方法被调用的调用路径\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"_1-3-4-mat\"> 1.3.4 MAT</h3>\n<blockquote>\n<p>Java堆分析器，用于查找内存泄漏\nHeap Dump，称为堆转储文件，是Java进程在某个时间内的快照\n下载地址 ：https://www.eclipse.org/mat/downloads.php</p>\n</blockquote>\n<h4 id=\"_1-3-4-1-dump信息包含的内容\"> 1.3.4.1 Dump信息包含的内容</h4>\n<ul>\n<li>All Objects</li>\n</ul>\n<p>Class, fields, primitive values and references</p>\n<ul>\n<li>All Classes</li>\n</ul>\n<p>Classloader, name, super class, static fields</p>\n<ul>\n<li>Garbage Collection Roots</li>\n</ul>\n<p>Objects defined to be reachable by the JVM</p>\n<ul>\n<li>Thread Stacks and Local Variables</li>\n</ul>\n<p>The call-stacks of threads at the moment of the snapshot, and per-frame information about local objects</p>\n<h4 id=\"_1-3-4-2-获取dump文件\"> 1.3.4.2 获取Dump文件</h4>\n<ul>\n<li>手动</li>\n</ul>\n<div><pre><code>jmap -dump:format=b,file=heap.hprof 44808\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>自动</li>\n</ul>\n<div><pre><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"_1-3-4-3-使用\"> 1.3.4.3 使用</h4>\n<ul>\n<li>Histogram</li>\n</ul>\n<blockquote>\n<p>Histogram可以列出内存中的对象，对象的个数及其大小</p>\n</blockquote>\n<div><pre><code>Class Name:类名称，java类名\nObjects:类的对象的数量，这个对象被创建了多少个\nShallow Heap:一个对象内存的消耗大小，不包含对其他对象的引用\nRetained Heap:是shallow Heap的总和，即该对象被GC之后所能回收到内存的总和\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code>右击类名---&gt;List Objects---&gt;with incoming references---&gt;列出该类的实例\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>右击Java对象名---&gt;Merge Shortest Paths to GC Roots---&gt;exclude all ...---&gt;找到GC Root以及原因\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>Leak Suspects</li>\n</ul>\n<blockquote>\n<p>查找并分析内存泄漏的可能原因</p>\n</blockquote>\n<div><pre><code>Reports---&gt;Leak Suspects---&gt;Details\n</code></pre>\n<div><span>1</span><br></div></div><ul>\n<li>Top Consumers</li>\n</ul>\n<blockquote>\n<p>Top Consumers</p>\n</blockquote>\n<h3 id=\"_1-3-5-gc日志分析工具\"> 1.3.5 GC日志分析工具</h3>\n<div><pre><code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps\n-Xloggc:gc.log\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ul>\n<li>\n<p>在线 http://gceasy.io</p>\n</li>\n<li>\n<p><strong>GCViewer</strong></p>\n</li>\n</ul>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310215001216.png",
      "date_published": "2022-05-05T10:22:38.000Z",
      "date_modified": "2022-07-02T17:06:40.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM终篇-JVM分析",
      "url": "https://www.moremind.cn/md/java/jvm/JVM-5/",
      "id": "https://www.moremind.cn/md/java/jvm/JVM-5/",
      "content_html": "<h1 id=\"_1-jvm终结篇\"> 1 JVM终结篇</h1>\n<h2 id=\"_1-1-重新认知jvm\"> 1.1 重新认知JVM</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232017105.png\" alt=\"image-20220310232017105\" /></p>\n<h2 id=\"_1-2-gc优化\"> 1.2 GC优化</h2>\n<blockquote>\n<p>内存被使用了之后，难免会有不够用或者达到设定值的时候，就需要对内存空间进行垃圾回收。</p>\n</blockquote>\n<h3 id=\"_1-2-1-垃圾收集发生的时机\"> 1.2.1 垃圾收集发生的时机</h3>\n<blockquote>\n<p>GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。 当然，我们可以手动进行垃圾回收， 比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是说 System.gc()只是通知要回收，什么时候回收由JVM决定。 但是不建议手动调用该方法，因为消耗的资源比较 大。</p>\n</blockquote>\n<p>一般以下几种情况会发生垃圾回收:</p>\n<div><pre><code>（1）当Eden区或者S区不够用了\n（2）老年代空间不够用了\n（3）方法区空间不够用了\n（4）System.gc()\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_1-2-2-实验环境准备\"> 1.2.2 实验环境准备</h3>\n<h3 id=\"_1-2-3-gc日志文件\"> 1.2.3 GC日志文件</h3>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232235655.png\" alt=\"image-20220310232235655\" /></p>\n<blockquote>\n<p>要想分析日志的信息，得先拿到GC日志文件才行，所以得先配置一下，之前也看过这些参数。</p>\n</blockquote>\n<div><pre><code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps\n-Xloggc:gc.log\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>然后启动项目，可以看到默认使用的是ParallelGC</p>\n<h4 id=\"_1-2-3-1-parallel-gc日志\"> 1.2.3.1 Parallel GC日志</h4>\n<blockquote>\n<p>【吞吐量优先】</p>\n<div><pre><code>2019-06-10T23:21:53.305+0800: 1.303:\n[GC (Allocation Failure) [PSYoungGen: 65536K[Young区回收前]-&gt;10748K[Young区回收后]\n(76288K[Young区总大小])] 65536K[整个堆回收前]-&gt;15039K[整个堆回收后](251392K[整个堆总大小]),\n0.0113277 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意 如果回收的差值中间有出入，说明这部分空间是Old区释放出来的</p>\n</blockquote>\n<h4 id=\"_1-2-3-2-cms日志\"> 1.2.3.2 CMS日志</h4>\n<blockquote>\n<p>【停顿时间优先】</p>\n<p>参数设置：-XX:+UseConcMarkSweepGC -Xloggc:cms-gc.log</p>\n</blockquote>\n<h4 id=\"_1-2-3-3-g1日志\"> 1.2.3.3 G1日志</h4>\n<blockquote>\n<p>【停顿时间优先】</p>\n<p>参数设置：-XX:+UseG1GC -Xloggc:g1-gc.log</p>\n<p>理解G1日志格式：https://blogs.oracle.com/poonam/understanding-g1-gc-logs</p>\n<div><pre><code>-XX:+UseG1GC <span># 使用了G1垃圾收集器</span>\n<span># 什么时候发生的GC，相对的时间刻，GC发生的区域young，总共花费的时间，0.00478s，</span>\n<span># It is a stop-the-world activity and all</span>\n<span># the application threads are stopped at a safepoint during this time.</span>\n<span>2019</span>-12-18T16:06:46.508+0800: <span>0.458</span>: <span>[</span>GC pause <span>(</span>G1 Evacuation Pause<span>)</span> <span>(</span>young<span>)</span>,\n<span>0.0047804</span> secs<span>]</span>\n<span># 多少个垃圾回收线程，并行的时间</span>\n<span>[</span>Parallel Time: <span>3.0</span> ms, GC Workers: <span>4</span><span>]</span>\n<span># GC线程开始相对于上面的0.458的时间刻</span>\n<span>[</span>GC Worker Start <span>(</span>ms<span>)</span>: Min: <span>458.5</span>, Avg: <span>458.5</span>, Max: <span>458.5</span>, Diff: <span>0.0</span><span>]</span>\n<span># This gives us the time spent by each worker thread scanning the roots</span>\n<span># (globals, registers, thread stacks and VM data structures).</span>\n<span>[</span>Ext Root Scanning <span>(</span>ms<span>)</span>: Min: <span>0.2</span>, Avg: <span>0.4</span>, Max: <span>0.7</span>, Diff: <span>0.5</span>, Sum: <span>1.7</span><span>]</span>\n<span># Update RS gives us the time each thread spent in updating the Remembered Sets.</span>\n<span>[</span>Update RS <span>(</span>ms<span>)</span>: Min: <span>0.0</span>, Avg: <span>0.0</span>, Max: <span>0.0</span>, Diff: <span>0.0</span>, Sum: <span>0.0</span><span>]</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></blockquote>\n<h3 id=\"_1-2-4-gc日志文件分析工具\"> 1.2.4 GC日志文件分析工具</h3>\n<h4 id=\"_1-2-4-1-gceasy\"> 1.2.4.1 gceasy</h4>\n<blockquote>\n<p>官网 ：https://gceasy.io</p>\n<p>可以比较不同的垃圾收集器的吞吐量和停顿时间</p>\n<p>比如打开cms-gc.log和g1-gc.log</p>\n</blockquote>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232816712.png\" alt=\"image-20220310232816712\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232830568.png\" alt=\"image-20220310232830568\" /></p>\n<h4 id=\"_1-2-4-2-gcviewer\"> 1.2.4.2 GCViewer</h4>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232844104.png\" alt=\"image-20220310232844104\" /></p>\n<h3 id=\"_1-2-5-g1调优与最佳指南\"> 1.2.5 G1调优与最佳指南</h3>\n<h4 id=\"_1-2-5-1-调优\"> 1.2.5.1 调优</h4>\n<blockquote>\n<p>是否选用G1垃圾收集器的判断依据</p>\n<p>https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html#use_cases</p>\n<div><pre><code>（1）50%以上的堆被存活对象占用\n（2）对象分配和晋升的速度变化非常大\n（3）垃圾回收时间比较长\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>思考 ：https://blogs.oracle.com/poonam/increased-heap-usage-with-g1-gc</p>\n</blockquote>\n<p>(1)使用G1GC垃圾收集器: -XX:+UseG1GC</p>\n<p>修改配置参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310233115552.png\" alt=\"image-20220310233115552\" /></p>\n<p>(2)调整内存大小再获取gc日志分析</p>\n<div><pre><code>-XX:MetaspaceSize=100M\n-Xms300M\n-Xmx300M\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>比如设置堆内存的大小，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310233227857.png\" alt=\"image-20220310233227857\" /></p>\n<p>(3)调整最大停顿时间</p>\n<div><pre><code>-XX:MaxGCPauseMillis=20 设置最大GC停顿时间指标\n</code></pre>\n<div><span>1</span><br></div></div><p>比如设置最大停顿时间，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310233319130.png\" alt=\"image-20220310233319130\" /></p>\n<p>(4)启动并发GC时堆内存占用百分比</p>\n<div><pre><code>-XX:InitiatingHeapOccupancyPercent=45 G1用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比例。值为 0 则表示“一直执行GC循环)&#39;. 默认值为 45 (例如, 全部的 45% 或者使用了45%).\n</code></pre>\n<div><span>1</span><br></div></div><p>比如设置该百分比参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310233428017.png\" alt=\"image-20220310233428017\" /></p>\n<h4 id=\"_1-2-5-2-最佳指南\"> 1.2.5.2 最佳指南</h4>\n<blockquote>\n<p>官网建议 ：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations</p>\n</blockquote>\n<p><strong>(1)不要手动设置新生代和老年代的大小，只要设置整个堆的大小</strong></p>\n<div><pre><code>G1收集器在运行过程中，会自己调整新生代和老年代的大小其实是通过adapt代的大小来调整对象晋升的速度和年龄，从而达到为收集器设置的暂停时间目标\n\n如果手动设置了大小就意味着放弃了G1的自动调优\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>(2)不断调优暂停时间目标</strong></p>\n<div><pre><code>一般情况下这个值设置到100ms或者200ms都是可以的(不同情况下会不一样)，但如果设置成50ms就不太合理。暂停时间设置的太短，就会导致出现G1跟不上垃圾产生的速度。最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。暂停时间只是一个目标，并不能总是得到满足。\n</code></pre>\n<div><span>1</span><br></div></div><p><strong>(3)使用-XX:ConcGCThreads=n来增加标记线程的数量</strong></p>\n<div><pre><code>IHOP如果阀值设置过高，可能会遇到转移失败的风险，比如对象进行转移时空间不足。如果阀值设置过低，就会使标记周期运行过于频繁，并且有可能混合收集期回收不到空间。\n\nIHOP值如果设置合理，但是在并发周期时间过长时，可以尝试增加并发线程数，调高ConcGCThreads。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>(4)MixedGC调优</strong></p>\n<div><pre><code>-XX:InitiatingHeapOccupancyPercent\n-XX:G1MixedGCLiveThresholdPercent\n-XX:G1MixedGCCountTarger\n-XX:G1OldCSetRegionThresholdPercent\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>(5)适当增加堆内存大小</p>\n<h2 id=\"_1-3-高并发场景分析\"> 1.3 高并发场景分析</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311001043190.png\" alt=\"image-20220311001043190\" /></p>\n<h2 id=\"_1-4-jvm性能优化指南\"> 1.4 JVM性能优化指南</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311001107369.png\" alt=\"image-20220311001107369\" /></p>\n<h2 id=\"_1-5-常见问题思考\"> 1.5 常见问题思考</h2>\n<p><strong>（1）内存泄漏与内存溢出的区别</strong></p>\n<p>内存泄漏：对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。</p>\n<p>内存溢出：内存泄漏到一定的程度就会导致内存溢出，但是内存溢出也有可能是大对象导致的。</p>\n<p><strong>（2）young gc会有stw吗？</strong></p>\n<p>不管什么 GC，都会有 stop-the-world，只是发生时间的长短。</p>\n<p><strong>（3）major gc和full gc的区别</strong></p>\n<p><strong>major gc指的是老年代的gc，而full gc等于young+old+metaspace的gc。</strong></p>\n<p><strong>（4）G1与CMS的区别是什么</strong></p>\n<p>CMS 用于老年代的回收，而 G1 用于新生代和老年代的回收。 G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的产生。</p>\n<p><strong>（5）什么是直接内存</strong></p>\n<p>直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于Java堆。因此出于性能的考 虑，读写频繁的场合可能会考虑使用直接内存。</p>\n<p><strong>（6）不可达的对象一定要被回收吗？</strong></p>\n<p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对 象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此 对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机 将这两种情况视为没有必要执行。 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关 联，否则就会被真的回收。</p>\n<p><strong>（7）方法区中的无用类回收</strong></p>\n<p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满 足下面 3 个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然 被回收。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311003339439.png\" alt=\"image-20220311003339439\" /></p>\n<p><strong>（8）不同的引用</strong></p>\n<p>JDK1.2以后，Java对引用进行了扩充：强引用、软引用、弱引用和虚引用</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311002742261.png\" alt=\"image-20220311002742261\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311002930038.png\" alt=\"image-20220311002930038\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220311003005058.png\" alt=\"image-20220311003005058\" /></p>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220310232017105.png",
      "date_published": "2022-05-05T10:22:38.000Z",
      "date_modified": "2022-07-02T17:06:40.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM内存图谱",
      "url": "https://www.moremind.cn/md/java/jvm/",
      "id": "https://www.moremind.cn/md/java/jvm/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-14T09:08:36.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "Java 字节码反编译成汇编-使用JITWatch",
      "url": "https://www.moremind.cn/md/java/jvm/java-jitwatch/",
      "id": "https://www.moremind.cn/md/java/jvm/java-jitwatch/",
      "content_html": "<h1 id=\"java-字节码反编译成汇编\"> Java 字节码反编译成汇编</h1>\n<blockquote>\n<p>本位以windows环境为前提，JDK版本为Oracle Sun JDK8-64位</p>\n</blockquote>\n<h2 id=\"hsdis环境准备\"> Hsdis环境准备</h2>\n<h3 id=\"_1-下载hsdis-amd64-dylib\"> 1.下载hsdis-amd64.dylib</h3>\n<blockquote>\n<p>下载地址如下：https://github.com/evolvedmicrobe/benchmarks/blob/master/hsdis-amd64.dylib</p>\n</blockquote>\n<h3 id=\"_2-下载hsdis-amd64-dll\"> 2.下载hsdis-amd64.dll</h3>\n<blockquote>\n<p>下载地址如下：https://github.com/atzhangsan/file_loaded</p>\n</blockquote>\n<h3 id=\"_3-配置hsdis-amd64-dylib和hsdis-amd64-dll\"> 3.配置hsdis-amd64.dylib和hsdis-amd64.dll</h3>\n<p>a.将下载好的hsdis-amd64.dll文件放置在JDK路径下<code>\\jre\\bin</code>目录下。</p>\n<blockquote>\n<p>e.g. C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\bin</p>\n</blockquote>\n<p>b.将下载好的hsdis-amd64.dylib文件放置在JDK路径下的<code>\\jre\\lib</code>目录下。</p>\n<blockquote>\n<p>e.g. C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib</p>\n</blockquote>\n<h3 id=\"_4-测试验证是否配置成功\"> 4.测试验证是否配置成功</h3>\n<p>使用命令<code>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -version</code>验证是否配置成功。如果出现如下所示则说明配置成功。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414230849483.png\" alt=\"image-20210414230849483\" /></p>\n<h3 id=\"_5-自行构建hsdis-如果你有兴趣的话\"> 5.自行构建hsdis(如果你有兴趣的话)</h3>\n<p>如果你有兴趣自行编译hsdis的话，可以参考如下的几个链接，然后把编译好的文件放在jdk的jre目录下的如上所<code>3</code>述路径。</p>\n<p>1.http://www.chrisnewland.com/building-hsdis-on-linux-amd64-on-debian-369</p>\n<p>2.http://psy-lob-saw.blogspot.com/2013/01/java-print-assembly.html</p>\n<h2 id=\"jitwatch环境\"> JITWatch环境</h2>\n<h3 id=\"_1-下载jitwatch\"> 1.下载JITWatch</h3>\n<blockquote>\n<p>下载路径如下：https://github.com/AdoptOpenJDK/jitwatch/releases</p>\n</blockquote>\n<p>如果你有兴趣的话，当然也可以参考官方文档进行编译。</p>\n<p>JITWatch链接如下：</p>\n<blockquote>\n<p>https://github.com/AdoptOpenJDK/jitwatch</p>\n</blockquote>\n<p>编译命令如下：</p>\n<div><pre><code>ant编译：\nant clean compile <span>test</span> run\nmaven编译：\nmvn clean compile <span>test</span> exec:java\ngradle编译：\ngradlew clean build run\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_2-配置运行jitwatch\"> 2.配置运行JITWatch</h3>\n<p>a.启动，使用<code>java -jar jitwatch-ui-1.4.0-shaded-win.jar</code>启动jitwatch，启动成功后如下所示</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414232505669.png\" alt=\"image-20210414232505669\" /></p>\n<p>b.配置，点击<code>sandbox</code>按钮打开窗口，再点击<code>Configure Sandbox</code>按钮，配置如下几个参数</p>\n<blockquote>\n<p>1.java classes目录</p>\n<p>2.java 运行目录为你本地的配置使用的JDK路径</p>\n<p>3.java运行参数，添加hsdis的运行参数配置</p>\n</blockquote>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414233652204.png\" alt=\"image-20210414233652204\" /></p>\n<p>c.运行，点击<code>open</code>按钮打开需要编译的java代码，点击<code>Run</code>按钮运行得到下图所示</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414232726380.png\" alt=\"image-20210414232726380\" /></p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414234418226.png\" alt=\"image-20210414234418226\" /></p>\n<h3 id=\"_3-jitwatch简单使用\"> 3.JITwatch简单使用</h3>\n<h4 id=\"模块化查看字节码和汇编码\"> 模块化查看字节码和汇编码</h4>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414234700267.png\" alt=\"image-20210414234700267\" /></p>\n<h4 id=\"使用toplist查看资源占用率\"> 使用topList查看资源占用率</h4>\n<p>在JITWatch窗口点击<code>TopList</code>按钮，即可查看资源占用率。</p>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414235239556.png\" alt=\"image-20210414235239556\" /></p>\n<h4 id=\"更多资料\"> 更多资料</h4>\n<p>1.https://www.chrisnewland.com/images/jitwatch/HotSpot_Profiling_Using_JITWatch.pdf</p>\n<p>2.https://github.com/AdoptOpenJDK/jitwatch/wiki</p>\n<h2 id=\"参考文章\"> 参考文章</h2>\n<p>1.利用hsdis和JITWatch查看分析HotSpot JIT compiler生成的汇编代码.https://blog.csdn.net/hengyunabc/article/details/26898657</p>\n<p>2.JITWatch Wiki.https://github.com/AdoptOpenJDK/jitwatch/wiki</p>\n<blockquote>\n<p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=17nuh698omdi4</p>\n</blockquote>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210414230849483.png",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-07-02T17:06:40.000Z",
      "authors": [
        {
          "name": "finen"
        }
      ],
      "tags": []
    },
    {
      "title": "Java新特性",
      "url": "https://www.moremind.cn/md/java/new-feature/",
      "id": "https://www.moremind.cn/md/java/new-feature/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-New-Feature"
      ]
    },
    {
      "title": "java基础",
      "url": "https://www.moremind.cn/md/java/thread/",
      "id": "https://www.moremind.cn/md/java/thread/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Java-Thread"
      ]
    },
    {
      "title": "线程池基础知识",
      "url": "https://www.moremind.cn/md/java/thread/thread-pool-basic/",
      "id": "https://www.moremind.cn/md/java/thread/thread-pool-basic/",
      "content_html": "<h2 id=\"_1-线程池的创建方式\"> 1.线程池的创建方式</h2>\n<h2 id=\"_2-线程池的关键参数\"> 2.线程池的关键参数</h2>\n<h2 id=\"_3-线程池设计的技巧\"> 3.线程池设计的技巧</h2>\n",
      "date_published": "2022-04-06T13:44:30.000Z",
      "date_modified": "2022-04-06T13:44:30.000Z",
      "authors": [
        {
          "name": "moremind"
        }
      ],
      "tags": [
        "Java-Thread"
      ]
    },
    {
      "title": "到底什么是线程安全和线程不安全？",
      "url": "https://www.moremind.cn/md/java/thread/thread-safety/",
      "id": "https://www.moremind.cn/md/java/thread/thread-safety/",
      "content_html": "<h2 id=\"_1-什么是线程安全\"> 1.什么是线程安全？</h2>\n<p>维基百科给出的定义如下：</p>\n<blockquote>\n<p>线程安全是程式设计中的术语，指<strong>某个函数、函数库</strong>在<strong>多线程环境</strong>中被调用时，能够正确地处理多个线程之间的<strong>共享变量</strong>，使程序功能正确完成。</p>\n</blockquote>\n<p>在《Java并发编程实战》一书中给出如下定义：</p>\n<blockquote>\n<p>一个对象是否需要是线程安全的，取决于它是否被多个线程访问。<strong>这只和对象在程序中是以何种方式被使用的有关，和对象本身具体是做什么的无关。</strong></p>\n</blockquote>\n<p>在《深入Java虚拟机》一书中给出如下定义：</p>\n<blockquote>\n<p>当多个线程访问同一个对象时，**如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，**调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。</p>\n</blockquote>\n<p>线程安全：在多线程同时访问一个资源时，线程间依照某种方式访问资源时，访问的结果总是能获取到正确的结果。</p>\n<h2 id=\"_2-java内存模型-jmm\"> 2.Java内存模型-JMM</h2>\n<p><img src=\"https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/16bf62d8c174d776.jpg\" alt=\"16bf62d8c174d776\" /></p>\n<p>上图描述了一个多线程执行场景。 线程 A 和线程 B 分别对主内存的<code>变量</code>进行读写操作。其中<strong>主内存</strong>中的<code>变量</code>为<code>共享变量</code>,也就是说此变量只此一份，多个线程间共享。但是线程不能直接读写主内存的<code>共享变量</code>，每个线程都有自己的<strong>工作内存</strong>，线程需要读写主内存的<code>共享变量</code>时需要先将该变量拷贝一份副本到自己的工作内存，然后在自己的工作内存中对该变量进行所有操作，线程工作内存对变量副本完成操作之后需要将结果同步至主内存。</p>\n<blockquote>\n<p>线程的工作内存是线程私有内存，线程间无法互相访问对方的工作内存。</p>\n</blockquote>\n<h2 id=\"_3-共享变量-共享资源\"> 3.共享变量(共享资源)</h2>\n<p>所谓共享变量，指的是多个线程都可以操作的变量。进程是分配资源的基本单位，线程是执行的基本单位。所以，多个线程之间是可以共享一部分进程中的数据的。在JVM中，Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可以操作保存在堆或者方法区中的同一个数据。那么，<strong>保存在堆和方法区中的变量就是Java中的共享变量。</strong></p>\n<p>那么，Java中哪些变量是存放在堆中，哪些变量是存放在方法区中，又有哪些变量是存放在栈中的呢？</p>\n<p>Java中共有三种变量，<strong>分别是类变量、成员变量和局部变量。他们分别存放在JVM的方法区、堆内存和栈内存中。</strong>（栈内存是程序线程独占空间）</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Variables</span> <span>{</span>\n\n    <span>/**\n     * 类变量\n     */</span>\n    <span>private</span> <span>static</span> <span>int</span> a<span>;</span>\n\n    <span>/**\n     * 成员变量\n     */</span>\n    <span>private</span> <span>int</span> b<span>;</span>\n\n    <span>/**\n     * 局部变量\n     * @param c\n     */</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>int</span> c<span>)</span><span>{</span>\n        <span>int</span> d<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>上面定义的三个变量中，变量a就是类变量，变量b就是成员变量，而变量c和d是局部变量。</p>\n<p>所以，变量a和b是共享变量，变量c和d是非共享变量。所以如果遇到多线程场景，对于变量a和b的操作是需要考虑线程安全的，而对于线程c和d的操作是不需要考虑线程安全的。</p>\n<h2 id=\"_4-线程安全的实现\"> 4.线程安全的实现</h2>\n<h3 id=\"_4-1-无状态实现\"> 4.1 无状态实现</h3>\n<p>在大多数情况下，多线程应用中的错误是错误地在多个线程之间共享状态的结果。</p>\n<p>因此，我们要研究的第一种方法是 <strong>使用无状态实现</strong>来实现线程安全。</p>\n<p>为了更好地理解这种方法，让我们考虑一个带有静态方法的简单工具类，该方法可以计算数字的阶乘：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MathUtils</span> <span>{</span>\n    \n    <span>public</span> <span>static</span> <span>BigInteger</span> <span>factorial</span><span>(</span><span>int</span> number<span>)</span> <span>{</span>\n        <span>BigInteger</span> f <span>=</span> <span>new</span> <span>BigInteger</span><span>(</span><span>\"1\"</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> number<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            f <span>=</span> f<span>.</span><span>multiply</span><span>(</span><span>BigInteger</span><span>.</span><span>valueOf</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> f<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong><code>factorial</code>方法是一种无状态确定性函数。</strong> 确定性是指：给定特定的输入，它将始终产生相同的输出。</p>\n<p>该方法<strong>既不依赖外部状态，也不维护自身的状态</strong>。因此，它被认为是线程安全的，并且可以同时被多个线程安全地调用。</p>\n<p>所有线程都可以安全地调用 <code>factorial</code> 方法，并且将获得预期结果，而不会互相干扰，也不会更改该方法为其他线程生成的输出。</p>\n<p>因此，<strong>无状态实现是实现线程安全的最简单方法</strong>。</p>\n<h3 id=\"_4-2-不可变的实现\"> 4.2  不可变的实现</h3>\n<p><strong>如果我们需要在不同线程之间共享状态，则可以通过使它们成为不可变对象来创建线程安全类</strong>。</p>\n<p>不变性是一个功能强大，与语言无关的概念，在Java中相当容易实现。</p>\n<p><strong>当类实例的内部状态在构造之后无法修改时，它是不可变的</strong>。</p>\n<p>在Java中创建不可变类的最简单方法是声明所有字段为 <em>private</em> 和 <em>final</em> ，且不提供 setter：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MessageService</span> <span>{</span>\n    \n    <span>private</span> <span>final</span> <span>String</span> message<span>;</span>\n \n    <span>public</span> <span>MessageService</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>message <span>=</span> message<span>;</span>\n    <span>}</span>\n    \n    <span>// 标准 getter</span>\n    \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>一个 <em>MessageService</em> 对象实际上是不可变的，因为它的状态在构造之后不能更改。因此，它是线程安全的。</p>\n<p>此外，如果 <em>MessageService</em> 实际上是<strong>可变</strong>的，但是多个线程仅对其具有<strong>只读</strong>访问权限，那么它也是线程安全的。</p>\n<p>因此，<strong>不变性是实现线程安全的另一种方法</strong>。</p>\n<h3 id=\"_4-3-线程私有-threadlocal-字段\"> 4.3 线程私有 (ThreadLocal) 字段</h3>\n<p>在面向对象编程（OOP）中，对象实际上需要通过字段维护状态并通过一种或多种方法来实现行为。</p>\n<p>如果我们确实需要维护状态，<strong>则可以通过使它们的字段成为线程局部的来创建不在线程之间共享状态的线程安全类。</strong></p>\n<p>通过简单地在 <em><a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html\" target=\"_blank\" rel=\"noopener noreferrer\">Thread</a></em> 类中定义私有字段，我们可以轻松创建其字段为线程局部的类。</p>\n<p>例如，我们可以定义一个存储整数数组的 <em>Thread</em> 类：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadA</span> <span>extends</span> <span>Thread</span> <span>{</span>\n    \n    <span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> numbers <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>)</span><span>;</span>\n    \n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        numbers<span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>而另一个类可能拥有一个字符串数组：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadB</span> <span>extends</span> <span>Thread</span> <span>{</span>\n    \n    <span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> letters <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>\"a\"</span><span>,</span> <span>\"b\"</span><span>,</span> <span>\"c\"</span><span>,</span> <span>\"d\"</span><span>,</span> <span>\"e\"</span><span>,</span> <span>\"f\"</span><span>)</span><span>;</span>\n    \n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        letters<span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><strong>在这两种实现中，这些类都有其自己的状态，但是不与其他线程共享。因此，这些类是线程安全的。</strong></p>\n<p>同样，我们可以通过将 <em><a href=\"https://www.baeldung.com/java-threadlocal\" target=\"_blank\" rel=\"noopener noreferrer\">ThreadLocal</a></em> 实例分配给一个字段来创建线程私有字段。</p>\n<p>例如，让我们考虑以下 <em>StateHolder</em> 类：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>StateHolder</span> <span>{</span>\n    \n    <span>private</span> <span>final</span> <span>String</span> state<span>;</span>\n \n    <span>// 标准的构造函数和 getter</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们可以很容易地使其成为线程局部（ThreadLocal）变量，如下所示：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadState</span> <span>{</span>\n    \n    <span>public</span> <span>static</span> <span>final</span> <span>ThreadLocal</span><span><span>&lt;</span><span>StateHolder</span><span>></span></span> statePerThread <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>StateHolder</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n        \n        <span>@Override</span>\n        <span>protected</span> <span>StateHolder</span> <span>initialValue</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>StateHolder</span><span>(</span><span>\"active\"</span><span>)</span><span>;</span>  \n        <span>}</span>\n    <span>}</span><span>;</span>\n \n    <span>public</span> <span>static</span> <span>StateHolder</span> <span>getState</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> statePerThread<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>线程局部字段与普通类字段非常相似，不同之处在于，每个通过setter / getter访问它们的线程都将获得该字段的独立初始化副本，以便每个线程都有自己的状态。</p>\n<h3 id=\"_4-4-同步集合类\"> 4.4 同步集合类</h3>\n<p>通过使用<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html\" target=\"_blank\" rel=\"noopener noreferrer\">collections框架</a> 中包含的一组同步包装器，我们可以轻松地创建线程安全的<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html\" target=\"_blank\" rel=\"noopener noreferrer\">collections</a>。</p>\n<p>例如，我们可以使用以下<a href=\"https://www.baeldung.com/java-synchronized-collections\" target=\"_blank\" rel=\"noopener noreferrer\">同步包装之一</a>来创建线程安全的集合：</p>\n<div><pre><code>Collection&lt;Integer&gt; syncCollection = Collections.synchronizedCollection(new ArrayList&lt;&gt;());\nThread thread1 = new Thread(() -&gt; syncCollection.addAll(Arrays.asList(1, 2, 3, 4, 5, 6)));\nThread thread2 = new Thread(() -&gt; syncCollection.addAll(Arrays.asList(7, 8, 9, 10, 11, 12)));\nthread1.start();\nthread2.start();\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>让我们记住，同步集合在每种方法中都使用内在锁定（我们将在后面介绍内在锁定）。</p>\n<p>这意味着<strong>该方法一次只能由一个线程访问，而其他线程将被阻塞，直到该方法被第一个线程解锁。</strong></p>\n<p>因此，由于同步访问的基本逻辑，同步会对性能造成不利影响。</p>\n<h3 id=\"_4-5-支持并发的集合\"> 4.5 支持并发的集合</h3>\n<p>除了同步集合，我们可以使用并发集合来创建线程安全的集合。</p>\n<p>Java提供了 <em><a href=\"https://docs.oracle.com/javase/8/docs/api/?java/util/concurrent/package-summary.html\" target=\"_blank\" rel=\"noopener noreferrer\">java.util.concurrent</a></em> 包，其中包含多个并发集合，例如 <em><a href=\"https://docs.oracle.com/javase/8/docs/api/?java/util/concurrent/package-summary.html\" target=\"_blank\" rel=\"noopener noreferrer\">ConcurrentHashMap</a></em> ：</p>\n<div><pre><code>Map&lt;String,String&gt; concurrentMap = new ConcurrentHashMap&lt;&gt;();\nconcurrentMap.put(&quot;1&quot;, &quot;one&quot;);\nconcurrentMap.put(&quot;2&quot;, &quot;two&quot;);\nconcurrentMap.put(&quot;3&quot;, &quot;three&quot;);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>与同步对象不同，<strong>并发集合通过将其数据划分为段来实现线程安全</strong>。例如，在 <em>ConcurrentHashMap</em> 中，多个线程可以获取不同 Map 段上的锁，因此多个线程可以同时访问 <em>Map</em> 。</p>\n<p>由于并发线程访问的先天优势，<strong>并发集合类</strong>具备<strong>远超同步集合类更好的性能</strong>。</p>\n<p>值得一提的是，<strong>同步集合和并发集合仅使集合本身具有线程安全性，而不使content变得线程安全</strong>。</p>\n<h3 id=\"_4-6-原子化对象\"> 4.6 原子化对象</h3>\n<p>使用Java提供的一组<a href=\"https://www.baeldung.com/java-atomic-variables\" target=\"_blank\" rel=\"noopener noreferrer\">原子类</a>（包括 <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html\" target=\"_blank\" rel=\"noopener noreferrer\">AtomicInteger</a>，<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicLong.html\" target=\"_blank\" rel=\"noopener noreferrer\">AtomicLong</a>，<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicBoolean.html\" target=\"_blank\" rel=\"noopener noreferrer\">AtomicBoolean</a> 和 <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html\" target=\"_blank\" rel=\"noopener noreferrer\">AtomicReference</a> )也可以实现线程安全。</p>\n<p><strong>原子类使我们能够执行安全的原子操作，而无需使用同步</strong>。原子操作在单个机器级别的操作中执行。</p>\n<p>要了解解决的问题，让我们看下面的 <em>Counter</em> 类：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Counter</span> <span>{</span>\n    \n    <span>private</span> <span>int</span> counter <span>=</span> <span>0</span><span>;</span>\n    \n    <span>public</span> <span>void</span> <span>incrementCounter</span><span>(</span><span>)</span> <span>{</span>\n        counter <span>+=</span> <span>1</span><span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>int</span> <span>getCounter</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> counter<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>让我们假设在竞争条件下，两个线程同时访问 <code>increasingCounter()</code> 方法。</strong></p>\n<p>从理论上讲， <em>counter</em> 字段的最终值为2。但是我们不确定结果如何，因为线程在同一时间执行同一代码块，并且增量不是原子的。</p>\n<p>让我们使用 <em>AtomicInteger</em> 对象创建 <em>Counter</em> 类的线程安全实现：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>AtomicCounter</span> <span>{</span>\n    \n    <span>private</span> <span>final</span> <span>AtomicInteger</span> counter <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>\n    \n    <span>public</span> <span>void</span> <span>incrementCounter</span><span>(</span><span>)</span> <span>{</span>\n        counter<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>int</span> <span>getCounter</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> counter<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>这是线程安全的，因为在++增量执行多个操作的同时， <code>增量和获取</code> 是原子的</strong>。</p>\n<h3 id=\"_4-7-同步方法\"> 4.7 同步方法</h3>\n<p>尽管较早的方法对于集合和基元非常有用，但有时我们需要的控制权要强于此。</p>\n<p>因此，可用于实现线程安全的另一种常见方法是实现同步方法。</p>\n<p>简而言之，<strong>一次只能有一个线程可以访问同步方法，同时阻止其他线程对该方法的访问</strong>。其他线程将保持阻塞状态，直到第一个线程完成或该方法引发异常。</p>\n<p>我们可以通过使它成为同步方法，以另一种方式创建线程安全版本的 <em>creationCounter()</em> ：</p>\n<div><pre><code>public synchronized void incrementCounter() {\n    counter += 1;\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们通过与前缀的方法签名创建一个同步方法 synchronized 关键字。</p>\n<p>由于一次一个线程可以访问一个同步方法，因此一个线程将执行 <em>crementCounter()</em> 方法，而其他线程将执行相同的操作。任何重叠的执行都不会发生。</p>\n<p><strong>同步方法依赖于“内部锁”或“监视器锁”的使用</strong>。固有锁是与特定类实例关联的隐式内部实体。</p>\n<p>在多线程上下文中，术语 <em>monitor</em> 是指对关联对象执行锁的角色，因为它强制对一组指定的方法或语句进行排他访问。</p>\n<p><strong>当线程调用同步方法时，它将获取内部锁</strong>。线程完成执行方法后，它将释放锁，从而允许其他线程获取锁并获得对方法的访问。</p>\n<p>我们可以在实例方法，静态方法和语句（已同步的语句）中实现同步。</p>\n<h3 id=\"_4-8-同步语句\"> 4.8  同步语句</h3>\n<p>有时，如果我们只需要使方法的一部分成为线程安全的，那么同步整个方法可能就显得过分了。</p>\n<p>为了说明这个用例，让我们重构 <em>increascountCounter</em> 方法：</p>\n<div><pre><code>public void incrementCounter() {\n    // 此处可有额外不需同步的操作\n    // ...\n    synchronized(this) {\n        counter += 1; \n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>该示例很简单，但是它显示了如何创建同步语句。假设该方法现在执行了一些不需要同步的附加操作，我们仅通过将相关的状态修改部分包装在一个<strong>同步</strong>块中来对其进行<strong>同步</strong>。</p>\n<p>与同步方法不同，同步语句必须指定提供内部锁的对象，通常是<code>this</code>引用。</p>\n<p><strong>同步非常昂贵，因此使用此选项，我们尽可能只同步方法的相关部分</strong>。</p>\n<h3 id=\"_4-8-其他对象作为锁\"> 4.8 其他对象作为锁</h3>\n<p>我们可以通过将另一个对象用作监视器锁定，来稍微改善 <em>Counter</em> 类 的线程安全实现。</p>\n<p>这不仅可以在多线程环境中提供对共享资源的协调访问，<strong>还可以使用外部实体来强制对资源进行独占访问</strong>：</p>\n<div><pre><code>public class ObjectLockCounter {\n \n    private int counter = 0;\n    private final Object lock = new Object();\n    \n    public void incrementCounter() {\n        synchronized(lock) {\n            counter += 1;\n        }\n    }\n    \n    // 标准 getter\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>我们使用一个普通的 Object 实例来强制相互排斥。此实现稍好一些，因为它可以提高锁定级别的安全性。</p>\n<p>将 this 用于内部锁定时，<strong>攻击者可能会通过获取内部锁定并触发拒绝服务（DoS）条件来导致死锁。</strong></p>\n<p>相反，在使用其他对象时， <strong>无法从外部访问该私有实体</strong>。这使得攻击者更难获得锁定并导致死锁。</p>\n<h2 id=\"_5-参考文章\"> 5.参考文章</h2>\n<p>1.什么是线程安全?.https://www.jianshu.com/p/44831d1d10d3</p>\n<p>2.深入理解Java并发编程（一）：到底什么是线程安全.https://www.hollischuang.com/archives/3060</p>\n<p>3.Java 并发基础——线程安全性.https://www.cnblogs.com/NeilZhang/p/8682266.html</p>\n<p>4.什么是线程安全以及如何实现？https://segmentfault.com/a/1190000023187634</p>\n<p>5.你真的知道什么是线程安全吗？.https://www.hoohack.me/2020/09/01/what-is-thread-safe</p>\n<p>6.(解释的比较清楚，透彻的)图解 Java 线程安全.https://juejin.cn/post/6844903890224152584</p>\n<p>7.Java进阶（二）当我们说线程安全时，到底在说什么.http://www.jasongj.com/java/thread_safe/</p>\n",
      "image": "https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/16bf62d8c174d776.jpg",
      "date_published": "2022-01-17T14:28:59.000Z",
      "date_modified": "2022-07-02T17:06:40.000Z",
      "authors": [
        {
          "name": "moremind"
        }
      ],
      "tags": [
        "Java-Thread"
      ]
    },
    {
      "title": "Memecache",
      "url": "https://www.moremind.cn/md/middleware/cache/memcache/",
      "id": "https://www.moremind.cn/md/middleware/cache/memcache/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Memcache"
      ]
    },
    {
      "title": "Redis",
      "url": "https://www.moremind.cn/md/middleware/cache/redis/",
      "id": "https://www.moremind.cn/md/middleware/cache/redis/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Redis"
      ]
    },
    {
      "title": "Kafka",
      "url": "https://www.moremind.cn/md/middleware/message/kafka/",
      "id": "https://www.moremind.cn/md/middleware/message/kafka/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Kafka"
      ]
    },
    {
      "title": "RabbitMQ",
      "url": "https://www.moremind.cn/md/middleware/message/rabbitmq/",
      "id": "https://www.moremind.cn/md/middleware/message/rabbitmq/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "RabbitMQ"
      ]
    },
    {
      "title": "RocketMQ",
      "url": "https://www.moremind.cn/md/middleware/message/rocketmq/",
      "id": "https://www.moremind.cn/md/middleware/message/rocketmq/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T16:50:45.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "RocketMQ"
      ]
    },
    {
      "title": "spring 知识图谱",
      "url": "https://www.moremind.cn/md/spring/spring-framework/",
      "id": "https://www.moremind.cn/md/spring/spring-framework/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Spring"
      ]
    },
    {
      "title": "Spring AOP详解",
      "url": "https://www.moremind.cn/md/spring/spring-framework/spring-aop/",
      "id": "https://www.moremind.cn/md/spring/spring-framework/spring-aop/",
      "content_html": "",
      "date_published": "2021-03-26T00:00:00.000Z",
      "date_modified": "2022-01-17T15:11:57.000Z",
      "authors": [
        {
          "name": "moremind"
        }
      ],
      "tags": [
        "Spring"
      ]
    },
    {
      "title": "Spring DI详解",
      "url": "https://www.moremind.cn/md/spring/spring-framework/spring-di/",
      "id": "https://www.moremind.cn/md/spring/spring-framework/spring-di/",
      "content_html": "",
      "date_published": "2021-03-26T00:00:00.000Z",
      "date_modified": "2022-01-17T15:11:57.000Z",
      "authors": [
        {
          "name": "moremind"
        }
      ],
      "tags": [
        "Spring"
      ]
    },
    {
      "title": "Spring IOC详解",
      "url": "https://www.moremind.cn/md/spring/spring-framework/spring-ioc/",
      "id": "https://www.moremind.cn/md/spring/spring-framework/spring-ioc/",
      "content_html": "",
      "date_published": "2021-03-26T00:00:00.000Z",
      "date_modified": "2022-01-17T15:11:57.000Z",
      "authors": [
        {
          "name": "moremind"
        }
      ],
      "tags": [
        "Spring"
      ]
    },
    {
      "title": "springboot",
      "url": "https://www.moremind.cn/md/spring/springboot/",
      "id": "https://www.moremind.cn/md/spring/springboot/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "SpringBoot"
      ]
    },
    {
      "title": "springcloud",
      "url": "https://www.moremind.cn/md/spring/springcloud/",
      "id": "https://www.moremind.cn/md/spring/springcloud/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "SpringCloud"
      ]
    },
    {
      "title": "springwebflux",
      "url": "https://www.moremind.cn/md/spring/springwebflux/",
      "id": "https://www.moremind.cn/md/spring/springwebflux/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-13T09:49:12.000Z",
      "date_modified": "2022-01-14T09:08:36.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "算法",
      "url": "https://www.moremind.cn/md/tools/docker/",
      "id": "https://www.moremind.cn/md/tools/docker/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-14T10:01:55.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Docker"
      ]
    },
    {
      "title": "Git基本简介",
      "url": "https://www.moremind.cn/md/tools/git/",
      "id": "https://www.moremind.cn/md/tools/git/",
      "content_html": "\n<h1 id=\"git与svn的基本介绍\"> git与svn的基本介绍</h1>\n<h2 id=\"git与svn\"> git与svn</h2>\n<h3 id=\"svn\"> svn</h3>\n<p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。一般公司用svn的比较多，至于原因,嘿嘿嘿....</p>\n<h3 id=\"git\"> git</h3>\n<p>git是一个分布式版本控制系统，没有中心服务器，每个人的电脑就是一个版本库，你的电脑上的Gitrepository就是你的版本库，那多人之间是如何合作的呢？这样，</p>\n<blockquote>\n<p>A在A的电脑上修改了A.Gitrepository里面的文件,而B在B的电脑上修改了clone过来的A.Gitrepository，你们两个只要把各自的修改推送给对方就行了，这就是为什么你就是没有网络也能使用版本控制。</p>\n</blockquote>\n<h1 id=\"下载\"> 下载</h1>\n<h2 id=\"网址\"> 网址</h2>\n<p><a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener noreferrer\">git-download</a></p>\n<h2 id=\"选择你的os版本即可\"> 选择你的OS版本即可</h2>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git.png\" alt=\"git\" /></p>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git.png",
      "date_published": "2022-01-14T10:01:55.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "git 进阶操作命令",
      "url": "https://www.moremind.cn/md/tools/git/git-advanced-command/",
      "id": "https://www.moremind.cn/md/tools/git/git-advanced-command/",
      "content_html": "<h1 id=\"工作区与暂存区\"> 工作区与暂存区</h1>\n<h2 id=\"工作区\"> 工作区</h2>\n<div><p>提示</p>\n<p>工作区就是在你电脑上的Repository下的某一个工作目录，比如：F:\\Repository\\test01这个目录。test01这个目录就是工作区，或者你新建的任何一个目录，都是工作区（.git隐藏目录下并非工作区）</p>\n</div>\n\n<h2 id=\"暂存区\"> 暂存区</h2>\n<p>Repository目录下有一个（.git隐藏目录），这个就是控制版本的版本控制库。</p>\n<div><p>提示</p>\n<p>（.git隐藏目录）存储了Git为我们创建的各种信息，包括版本信息，暂存区（这是最重要的），还有分支信息（Git已经为我们创建了一个master分支），还有一些配置信息等。</p>\n</div>\n<p>接下来在Repository目录下新建一个test.txt文件，在里面写入123456，然后进行下面的这些操作。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add_commit3.png\" alt=\"git_add_commit3\" /></p>\n<p>继续在test.txt中添加一行数据，然后使用git status查看信息。git会提示你有文件需要git add 并且git commit。</p>\n<p>继续下面的操作！---把同一个文件提交到同一个暂存区中，并且使用commit提交到一个分支中。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_status_add_commit.png\" alt=\"git_status_add_commit\" /></p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_status_commit.png\" alt=\"git_status_commit\" /></p>\n<p>这次将所有文件提交到一个分支（master分支）中了，可以使用git log查看你提交的所有分支。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_log4.png\" alt=\"git_log4\" /></p>\n<p>这样看起来很碍眼，而且版本较多的话，看起来的确不方便，所有推荐使用</p>\n<div><pre><code>git log --pretty=oneline\n</code></pre>\n<div><span>1</span><br></div></div><p>接下来，你可以使用<a href=\"https://finen.top/git-basic-command/#more\" target=\"_blank\" rel=\"noopener noreferrer\">上一篇git基础教程</a>讲过的方法对版本进行操作。基本命令请点击链接去查看...</p>\n<h1 id=\"撤销修改与删除文件操作\"> 撤销修改与删除文件操作</h1>\n<h2 id=\"撤销修改\"> 撤销修改</h2>\n<h3 id=\"最简单的方法-手动修改\"> 最简单的方法：手动修改</h3>\n<p>在你记得你修改了那些地方的情况下，直接手动撤销那些你不要的东西即可。</p>\n<h3 id=\"使用之前所使用的命令进行版本回滚\"> 使用之前所使用的命令进行版本回滚</h3>\n<p>具体命令如下：</p>\n<div><pre><code>git log --pretty=oneline\n\ngit reset --hard HEAD^\n\ngit reset --hard HEAD~*\n\ngit reflog\n\ngit reset --hard 版本号\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>你可以使用这些办法进行你所需要的回滚。</p>\n<h3 id=\"使用git-checkout-test-txt-一点要带文件名-不然会创建分支\"> 使用git checkout -- test.txt <font color=\"red\">一点要带文件名</font>，不然会创建分支！</h3>\n<p>git checkout --test.txt 分为两种状态</p>\n<div><pre><code>git checkout --test.txt\n</code></pre>\n<div><span>1</span><br></div></div><blockquote>\n<ol>\n<li>test.txt文件修改后，你没有使用git add命令对其进行提交到暂存区。使用git checkout --test.txt会回退到之前的一个版本。<strong>相当于回滚到你最后提交的那个版本。而刚刚修改的内容也将全部丢失。</strong></li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>另一种情况就是你已经使用git add提交文件到暂存区了。那这样使用git checkout --test.txt 就会<strong>保存已经在暂存区的内容。而没有写入暂存区的内容则会全部丢失。</strong></li>\n</ol>\n</blockquote>\n<p>接下来使用git进行操作查看。</p>\n<p>首先在test.txt文件中添加一行数据 654321，然后使用git add命令提交到暂存区。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add2.png\" alt=\"git_add2\" /></p>\n<p>接着再在test.txt文件中添加一行数据 222222，然后我们不使用git add命令提交文件到暂存区。</p>\n<p>最后我们使用git checkout --test.txt命令撤销修改，在查看文件。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_checkout.png\" alt=\"git_checkout\" /></p>\n<p>跟上面的结论是一样的。</p>\n<h2 id=\"删除文件\"> 删除文件</h2>\n<h3 id=\"rm-命令-linux下的软删除命令\"> rm 命令（linux下的软删除命令）</h3>\n<p>假如有人提交了tesxt02.txt的文件，但是这个文件缺失不需要的，我们可以使用rm test02.txt，然后在git commit就可以了。</p>\n<div><pre><code>新建一个test02.txt 文件\ngit add test02.txt\ngit commit -m &quot;提交test02文件&quot;\nrm test02.txt\ngit commit -m &quot;删除test02文件&quot;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add_commit4.png\" alt=\"git_commit4\" /></p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/rm.png\" alt=\"rm\" /></p>\n<p>说明已经删除了文件并且已经commit了，当然假如你删除错误的话，你也可以回滚版本。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_reflog2.png\" alt=\"git_reflog\" /></p>\n<p>假如你已经使用rm test02.txt命令，但是却没有使用git commit命令呢？又改如何恢复文件？你可以使用下面的命令:</p>\n<div><pre><code>git checkout --test02.txt\n</code></pre>\n<div><span>1</span><br></div></div><p>rm之前：</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_rm.png\" alt=\"rm_before\" /></p>\n<p>rm 之后：</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_rm2.png\" alt=\"git_rm_after\" /></p>\n<p>然后我们不使用git commit命令，使用git checkout -- test02.txt</p>\n<p>使用git checkout -- test02.txt之后</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_rm_after.png\" alt=\"git_check_out\" /></p>\n<p>文件又恢复了，恢复多个文件也是同理。</p>\n<hr>\n<div><pre><code> 下面会涉及删除与撤销的操作!请继续浏览！\n</code></pre>\n</div><hr>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add_commit3.png",
      "date_published": "2018-03-28T00:00:00.000Z",
      "date_modified": "2022-01-14T10:01:55.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "git 基本操作命令",
      "url": "https://www.moremind.cn/md/tools/git/git-basic-command/",
      "id": "https://www.moremind.cn/md/tools/git/git-basic-command/",
      "content_html": "<h1 id=\"git基本命令\"> git基本命令</h1>\n<p>0.你必须安装了git才能继续往下看。\n1.新建一个目录(在你磁盘空闲较多的地方，新建一个目录(名称Repository))===&gt;这个Repository就是上面说的你的本地仓库，然后右键选择Git Bash(Git 命令行)，在目录下输入以下命令：</p>\n<div><pre><code>git config <span>-</span><span>-</span>global user.name \"username\"\n\ngit config <span>-</span><span>-</span>global user.email \"youremail\"\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>\n<p>这里的<font color=\"red\">username</font>就是你刚刚注册的用户名，<font color=\"red\">email</font>就是刚刚注册邮箱。</p>\n</blockquote>\n<h2 id=\"git-init\"> git init</h2>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_init.png\" alt=\"git_init\" /></p>\n<p>此时，你就创建了一个本地仓库了。可以在你的本地查看一下：</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_intit2.png\" alt=\"git\" /></p>\n<h2 id=\"git-add-把项目提交到git仓库\"> git add （把项目提交到git仓库）</h2>\n<p>新建一个demo.txt的文件，并且在里面写入123456789</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add.png\" alt=\"git_add\" /></p>\n<p>这样就说明你已经把文件提交到文件暂存区了，接下来使用下一个命令你就可以在本地仓库看到了。</p>\n<h2 id=\"git-commit\"> git commit</h2>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_commit.png\" alt=\"git_commit\" /></p>\n<blockquote>\n<p>这里的<font color=\"red\"> -m</font>就是你提交的注释，记得以后写一定要使用注释！这是一个好习惯！</p>\n</blockquote>\n<h2 id=\"git-status-查看状态\"> git status ---查看状态</h2>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_status.png\" alt=\"git_status\" /></p>\n<blockquote>\n<p>没有什么东西需要提交，别急，我们在刚刚的demo.txt中<font color =\"red\">追加一个0000</font>,记得保存文件。</p>\n</blockquote>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_status_1.png\" alt=\"git_status2\" /></p>\n<blockquote>\n<p>修改之后就已经有了文件修改的信息，并且git提示你需要commit！所以你需要使用上面的git commit 提交！</p>\n</blockquote>\n<h2 id=\"git-diff\"> git diff</h2>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_diff.png\" alt=\"git_diff\" /></p>\n<blockquote>\n<p>git diff就是比对文件，红色的是告诉你，那是原来的，绿色的就是告诉添加了信息。</p>\n</blockquote>\n<blockquote>\n<p>之后你就可以放心的提交你的版本了。</p>\n</blockquote>\n<p><strong>你需要执行git add， git commit -m &quot;xxxx&quot;</strong>，必须通过add提交到文件暂存区。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add_commit.png\" alt=\"git_add_commit1\" /></p>\n<h1 id=\"版本控制-回退\"> 版本控制---回退</h1>\n<h2 id=\"git-log\"> git log</h2>\n<p>在使用git的时候一定要会使用日志功能。</p>\n<p>首先我们在demo.txt中添加一行数据<font color=\"red\">0000123456789</font>,然后git add ，git commit.</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_add_commit2.png\" alt=\"git_diff_add_commit\" /></p>\n<p>接下来使用git log打印日志</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_log.png\" alt=\"git_log\" /></p>\n<h2 id=\"版本回滚-git-reset-hard-head\"> 版本回滚---git reset --hard HEAD^</h2>\n<p>上面提到使用git log打印所有版本，其实有更简单的办法。</p>\n<div><pre><code>git log --pretty=oneline\n</code></pre>\n<div><span>1</span><br></div></div><p>这个可以自己去尝试哟，这个只会提示你的<font color=\"red\">版本号</font>跟<font color=\"red\">提交的信息</font>。</p>\n<div><pre><code>git reset --hard HEAD^\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_hard.png\" alt=\"git_hard\" /></p>\n<blockquote>\n<p>现在可以打开你的demo.txt看看里面还有什么内容了。是不是少了最后添加的一行数据，只有一行数据了。回滚到添加0000的版本了。</p>\n</blockquote>\n<p><strong>超级回滚：</strong></p>\n<p>你需要回滚50个版本，总不能输入50个^号，所以有下面这种更简单的办法。</p>\n<div><pre><code>git reset --hard HEAD~50\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"cat命令\"> cat命令</h2>\n<p>使用cat查看内容。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/cat.png\" alt=\"cat\" /></p>\n<p>然后你可以使用git log 查看一下存在的版本</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_log3.png\" alt=\"git_log3\" /></p>\n<p>加入你要回滚到添加了<font color=\"red\">0000123456789</font>的版本该怎么办呢？使用下一个命令+下下个命令！！！</p>\n<h2 id=\"git-reflog\"> git reflog</h2>\n<blockquote>\n<p>这个命令是告诉你所有操作的版本信息</p>\n</blockquote>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_reflog.png\" alt=\"git_reflog\" /></p>\n<p>看到版本号了---a0ca311，接下来就可以使用这个版本号进行回滚到添加<font color=\"red\">0000123456789</font>的那个版本了。</p>\n<h2 id=\"git-reset-hard-版本号\"> git reset --hard 版本号</h2>\n<p>下面是回滚到我的版本</p>\n<div><pre><code>git reset --hard a0ca311\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_hard.png\" alt=\"git_hard\" /></p>\n<p>接下来，打开你的demo.txt文档看一下是否已经有<font color=\"red\">0000123456789</font>了。</p>\n<p>或者你可以使用以下命令</p>\n<div><pre><code>cat demo.txt\n</code></pre>\n<div><span>1</span><br></div></div><hr>\n<div><pre><code> 下面会涉及删除与撤销的操作!请继续浏览！\n</code></pre>\n</div><hr>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_init.png",
      "date_published": "2018-03-28T00:00:00.000Z",
      "date_modified": "2022-01-14T10:01:55.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "git 分支操作命令",
      "url": "https://www.moremind.cn/md/tools/git/git-branch-command/",
      "id": "https://www.moremind.cn/md/tools/git/git-branch-command/",
      "content_html": "<h1 id=\"git分支操作\"> git分支操作</h1>\n<h2 id=\"创建与合并分支\"> 创建与合并分支</h2>\n<p>在版本回滚与更新中，git都是用master分支作为主线，通过时间顺序进行更新或者回滚。</p>\n<h3 id=\"创建分支\"> 创建分支</h3>\n<div><pre><code>git checkout -b dev \n==（相当于）\ngit branch dev\ngit checkout dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>查看分支信息：</p>\n<div><pre><code>git branch\n</code></pre>\n<div><span>1</span><br></div></div>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_branch.png\" alt=\"git_branch\" /></p>\n<p>现在已经在dev分支目录下，接下来可以在demo.txt中添加信息，我们添加一行数据：1111111111111</p>\n<p>此时，我们在dev目录下添加内容，并且提交到暂存区，然后commit。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_branch3.png\" alt=\"git_branch\" /></p>\n<p>接着，我们将目前分支切换到master主分支，查看文件新添加的内容是否存在。使用以下命令：</p>\n<div><pre><code>git checkout master\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_branch4.png\" alt=\"git_branch4\" /></p>\n<p>然后，发现master分支上并没有我们想要看到的内容，所以我们需要合并两个分支。</p>\n<h3 id=\"合并分支\"> 合并分支</h3>\n<div><pre><code>git merge 分支名\n</code></pre>\n<div><span>1</span><br></div></div><p>在master分之下合并分dev分支。使用以下命令：</p>\n<div><pre><code>git merger dev\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_merge.png\" alt=\"git_merge\" /></p>\n<p>合并完成后即可删除没有用的额分支了，使用以下命令进行删除分支：</p>\n<div><pre><code>git branch -d dev\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_delete.png\" alt=\"git_branch_delete\" /></p>\n<p>所有命令总结：</p>\n<div><pre><code>查看分支：git branch\n创建分支：git branch name\n切换分支：git checkout name\n创建+切换分支：git checkout -b name\n合并某个分支到当前分支：git merge name\n删除某个分支：git branch -d name\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"处理分支矛盾\"> 处理分支矛盾</h3>\n<p>新建一个分支，并且other中添加数据：2222222222222，并且检查文件。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_branch_other.png\" alt=\"git_branch_other\" /></p>\n<p>切换分支到master之中，并且master分支中增加内容：3333333333333，在增加之前使用cat命令，查看master坟之中是否存在2222222222222，增加后是否存在3333333333333。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_checkout1.png\" alt=\"git_checkout2\" /></p>\n<p>master分支数据如上，接下来我们继续合并分支。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_merge2.png\" alt=\"git_merge\" /></p>\n<p>由于我之前在master分支写了一个2222222的信息，，所以这有一个2222222222222222222/33333333333333333这样的信息。不过这样的错误信息也不影响分支是错误。<font color=\"red\">Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存。修改后就是上面的最后一个图。</font></p>\n<p>然后我们就可以git log查看commit后的信息，在此我就截图了哈。</p>\n<h3 id=\"分支策略\"> 分支策略</h3>\n<div><pre><code>1.创建一个dev分支。\n2.修改demo.txt内容。\n3.添加到暂存区。\n4.切换回主分支(master)。\n5.合并dev分支，使用命令 git merge –no-ff -m &quot;注释&quot; dev\n6.查看历史记录\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>具体命令如下：</p>\n<div><pre><code>git checkout -b dev\n在demo.txt文件中添加数据4444444444444\ngit add demo.txt\ngit commit -m &quot;add merge&quot;\ngit merge --no-ff -m &quot;merge with no-ff&quot; dev\ngit log 或者git log --graph --pretty=oneline --abbrev-commit\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_dev.png\" alt=\"git_dev\" /></p>\n<p><strong>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</strong></p>\n<h2 id=\"bug分支\"> Bug分支</h2>\n<p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p>\n<p>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。命令如下：</p>\n<div><pre><code>git checkout -b dev \n修改demo.txt文件添加数据：5555555555555\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_branch5.png\" alt=\"git_branch5\" /></p>\n<p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。</p>\n<p>隐藏分支：</p>\n<div><pre><code>git stash\ngit status\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_stash.png\" alt=\"git_stash\" /></p>\n<p>首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_bug.png\" alt=\"git_bug\" /></p>\n<p>修改后合并分支，然后删除bug分支即可。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_bug2.png\" alt=\"git_bug2\" /></p>\n<p>接着，我们继续回到dev分支下：</p>\n<div><pre><code>git checkout dev\ngit status\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>发现并没有文件，是因为stash隐藏了，所以我们需要从stash恢复。恢复命令如下：</p>\n<div><pre><code>git stash list\ngit stash apply\ngit stash drop\ncat demo.txt\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>或者：</p>\n<div><pre><code>git stash list\ngit stash pop\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_stash3.png\" alt=\"git_stash\" /></p>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_branch.png",
      "date_published": "2018-03-28T00:00:00.000Z",
      "date_modified": "2022-01-14T10:01:55.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "git多人合作开发操作命令",
      "url": "https://www.moremind.cn/md/tools/git/git-cooperate-develop-command/",
      "id": "https://www.moremind.cn/md/tools/git/git-cooperate-develop-command/",
      "content_html": "<h1 id=\"git远程分支操作\"> git远程分支操作</h1>\n<h2 id=\"查看远程仓库信息\"> 查看远程仓库信息</h2>\n<div><pre><code>git remote\ngit remote -v\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>\n<h2 id=\"推送分支\"> 推送分支</h2>\n<div><pre><code>git push origin master\n</code></pre>\n<div><span>1</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_remote3.png\" alt=\"git_remote\" /></p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_push.png\" alt=\"git_push\" /></p>\n<p>也可以推送到其他分支：</p>\n<div><pre><code>git push origin dev\n</code></pre>\n<div><span>1</span><br></div></div><p>那么一般情况下，那些分支要推送呢？</p>\n<blockquote>\n<ol>\n<li>master分支是主分支，因此要时刻与远程同步。</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</li>\n</ol>\n</blockquote>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_push2.png\" alt=\"git_push2\" /></p>\n<h2 id=\"抓取分支\"> 抓取分支</h2>\n<p>多人协作时，大家都会往master分支上推送各自的修改。新建一个目录名字叫testgit3。</p>\n<p>现在我们的伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_clone2.png\" alt=\"git_clone2\" /></p>\n<div><pre><code>git checkout –b dev \ngit reset --hard origin/dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>在dev下重置起点，即可，git checkout -b dev origin/dev 错误的。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_checkout3.png\" alt=\"git\" /></p>\n<p>接下来在demo.txt的文件中添加数据6666666666666数据，然后提交到分支即可。</p>\n<div><pre><code>git add demo.txt\ngit commit -m &quot;添加666的数据&quot;\ngit pusu origin dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_push4.png\" alt=\"git_push3\" /></p>\n<p>小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改,添加了数据6666666666666，也试图推送到远程库:</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_push_dev.png\" alt=\"git_push_dev\" /></p>\n<p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</p>\n<div><pre><code>git pull\ngit branch --set-upstream dev origin/dev\ngit pull\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后此时会出现冲突，所以需要解决冲突，使用前面讲过的分支策略进行解决。然后在执行：</p>\n<div><pre><code>git add demo.txt\ngit commit -m &quot;****&quot;\ngit push origin dev\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>多人协作工作模式一般是这样的：</p>\n<ol>\n<li>\n<p>首先，可以试图用git push origin branch-name推送自己的修改.</p>\n</li>\n<li>\n<p>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。</p>\n</li>\n<li>\n<p>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。</p>\n</li>\n</ol>\n<h2 id=\"推荐阅读\"> 推荐阅读</h2>\n<p><strong><a href=\"https://www.gitbook.com/book/bingohuang/progit2/details\" target=\"_blank\" rel=\"noopener noreferrer\">ProGit中文版</a></strong></p>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_remote3.png",
      "date_published": "2018-03-28T00:00:00.000Z",
      "date_modified": "2022-01-14T10:01:55.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "git 远端操作命令",
      "url": "https://www.moremind.cn/md/tools/git/git-remote-command/",
      "id": "https://www.moremind.cn/md/tools/git/git-remote-command/",
      "content_html": "<h1 id=\"git远程仓库-github\"> git远程仓库-github</h1>\n<h2 id=\"配置远程仓库-创建ssh-key-检查用户目录\"> 配置远程仓库-创建SSH Key-检查用户目录</h2>\n<p>检查用户目录下有没有id_rsa 和 id_rsa.pub，如果没有这两个文件就使用下面的这个命令生成密钥。</p>\n<div><pre><code>ssh-keygen -t rsa –C &quot;youremail@example.com&quot;\n</code></pre>\n<div><span>1</span><br></div></div>\n<h2 id=\"在github中设置ssh\"> 在github中设置ssh</h2>\n<p>登录github，打开settings的SSH and GPG keys，选择New SSH key就可以填充SSH key的相关信息。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/ssh.png\" alt=\"ssh\" /></p>\n<p>填写title，然后将id_rsa.pub里面的密钥复制到Key中，然后点击Add SSH key即可。</p>\n<h2 id=\"选择new-repository-添加仓库\"> 选择New Repository(添加仓库)</h2>\n<p>新建一个目录TestGit,将所有文件复制到TestGit目录下。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_1.png\" alt=\"git_1\" /></p>\n<p>然年使用命令创建一个一个本地仓库</p>\n<div><pre><code>git init\ngit add demo.txt\ngit add test.txt\ngit test02.txt\n\ngit commit -m &quot;新建文件&quot;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_remote.png\" alt=\"git_remote\" /></p>\n<p>现在把你的目录推送到TestGit远程仓库中</p>\n<div><pre><code>git remote add origin https://github.com/hirCodd/TestGit.git\n\ngit push -u origin master\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_upload.png\" alt=\"git_3\" /></p>\n<p>由于远程库是空的，我们第一次推送master分支时，加上了<font color=\"red\"> –u参数</font>，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。使用</p>\n<div><pre><code>git push origin master\n</code></pre>\n<div><span>1</span><br></div></div><p>现在查看远端仓库，如下，已经有相关的文件了。</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_2.png\" alt=\"git_3\" /></p>\n<p>以后你修改了bug，就可以使用git push origin master推送到github，这样你就拥有分布式版本仓库了。</p>\n<h1 id=\"从远端仓库克隆\"> 从远端仓库克隆</h1>\n<p>使用以下命令：</p>\n<div><pre><code>git clone url\n</code></pre>\n<div><span>1</span><br></div></div><p>首先现在远端创建一个仓库</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_clone.png\" alt=\"git_clone\" /></p>\n<p>使用命令即可从远端clone文件下来</p>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/git_clone2.png\" alt=\"git_clone2\" /></p>\n<hr>\n<div><pre><code> 下面会涉及删除与撤销的操作!请继续浏览！\n</code></pre>\n</div><hr>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/images/blog/ssh.png",
      "date_published": "2018-03-28T00:00:00.000Z",
      "date_modified": "2022-01-14T10:01:55.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Git"
      ]
    },
    {
      "title": "算法",
      "url": "https://www.moremind.cn/md/tools/k8s/",
      "id": "https://www.moremind.cn/md/tools/k8s/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-14T10:01:55.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Kubernates"
      ]
    },
    {
      "title": "算法",
      "url": "https://www.moremind.cn/md/tools/linux/",
      "id": "https://www.moremind.cn/md/tools/linux/",
      "content_html": "<p>JVM 内存分析图</p>\n",
      "date_published": "2022-01-14T10:01:55.000Z",
      "date_modified": "2022-01-21T15:41:02.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Linux"
      ]
    },
    {
      "title": "Maven",
      "url": "https://www.moremind.cn/md/tools/maven/",
      "id": "https://www.moremind.cn/md/tools/maven/",
      "content_html": "<h1 id=\"maven知识点\"> Maven知识点</h1>\n<h2 id=\"mavan打包工具的使用\"> Mavan打包工具的使用</h2>\n",
      "date_published": "2022-01-21T15:41:02.000Z",
      "date_modified": "2022-01-21T16:14:37.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Maven"
      ]
    },
    {
      "title": "Maven对Springboot项目配置文件、依赖分离打包",
      "url": "https://www.moremind.cn/md/tools/maven/maven-assembly/",
      "id": "https://www.moremind.cn/md/tools/maven/maven-assembly/",
      "content_html": "<h1 id=\"maven对springboot项目配置文件、依赖分离打包\"> Maven对Springboot项目配置文件、依赖分离打包</h1>\n<h2 id=\"_1-使用maven-assembly-plugin进行配置分离\"> 1.使用maven-assembly-plugin进行配置分离</h2>\n<blockquote>\n<p>assembly.xml配置文件</p>\n</blockquote>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span><span>&lt;</span>assembly</span><span>></span></span>\n    <span>&lt;!-- 可自定义，这里指定的是项目环境 --></span>\n    <span>&lt;!-- xxx.tar.gz  --></span>\n    <span><span><span>&lt;</span>id</span><span>></span></span>${name}<span><span><span>&lt;/</span>id</span><span>></span></span>\n\n    <span>&lt;!-- 打包的类型，如果有N个，将会打N个类型的包 --></span>\n    <span><span><span>&lt;</span>formats</span><span>></span></span>\n        <span><span><span>&lt;</span>format</span><span>></span></span>tar.gz<span><span><span>&lt;/</span>format</span><span>></span></span>\n        <span><span><span>&lt;</span>format</span><span>></span></span>zip<span><span><span>&lt;/</span>format</span><span>></span></span>\n    <span><span><span>&lt;/</span>formats</span><span>></span></span>\n\n    <span><span><span>&lt;</span>includeBaseDirectory</span><span>></span></span>true<span><span><span>&lt;/</span>includeBaseDirectory</span><span>></span></span>\n\n    <span><span><span>&lt;</span>fileSets</span><span>></span></span>\n        <span>&lt;!-- 配置文件打包-打包至config目录下 --></span>\n        <span><span><span>&lt;</span>fileSet</span><span>></span></span>\n            <span><span><span>&lt;</span>directory</span><span>></span></span>src/main/resources/<span><span><span>&lt;/</span>directory</span><span>></span></span>\n            <span><span><span>&lt;</span>outputDirectory</span><span>></span></span>config<span><span><span>&lt;/</span>outputDirectory</span><span>></span></span>\n            <span><span><span>&lt;</span>fileMode</span><span>></span></span>0644<span><span><span>&lt;/</span>fileMode</span><span>></span></span>\n            <span><span><span>&lt;</span>includes</span><span>></span></span>\n                <span><span><span>&lt;</span>include</span><span>></span></span>application.yml<span><span><span>&lt;/</span>include</span><span>></span></span>\n                <span><span><span>&lt;</span>include</span><span>></span></span>*.xml<span><span><span>&lt;/</span>include</span><span>></span></span>\n                <span><span><span>&lt;</span>include</span><span>></span></span>*.properties<span><span><span>&lt;/</span>include</span><span>></span></span>\n            <span><span><span>&lt;/</span>includes</span><span>></span></span>\n        <span><span><span>&lt;/</span>fileSet</span><span>></span></span>\n        <span>&lt;!-- 启动文件目录 --></span>\n        <span><span><span>&lt;</span>fileSet</span><span>></span></span>\n            <span><span><span>&lt;</span>directory</span><span>></span></span>${basedir}/src/main/bin<span><span><span>&lt;/</span>directory</span><span>></span></span>\n            <span><span><span>&lt;</span>outputDirectory</span><span>></span></span>bin<span><span><span>&lt;/</span>outputDirectory</span><span>></span></span>\n            <span><span><span>&lt;</span>fileMode</span><span>></span></span>0755<span><span><span>&lt;/</span>fileMode</span><span>></span></span>\n            <span><span><span>&lt;</span>includes</span><span>></span></span>\n                <span><span><span>&lt;</span>include</span><span>></span></span>**.sh<span><span><span>&lt;/</span>include</span><span>></span></span>\n                <span><span><span>&lt;</span>include</span><span>></span></span>**.bat<span><span><span>&lt;/</span>include</span><span>></span></span>\n            <span><span><span>&lt;/</span>includes</span><span>></span></span>\n        <span><span><span>&lt;/</span>fileSet</span><span>></span></span>\n    <span><span><span>&lt;/</span>fileSets</span><span>></span></span>\n\n    <span><span><span>&lt;</span>dependencySets</span><span>></span></span>\n        <span><span><span>&lt;</span>dependencySet</span><span>></span></span>\n            <span>&lt;!-- 依赖库 --></span>\n            <span><span><span>&lt;</span>outputDirectory</span><span>></span></span>lib<span><span><span>&lt;/</span>outputDirectory</span><span>></span></span>\n            <span><span><span>&lt;</span>scope</span><span>></span></span>runtime<span><span><span>&lt;/</span>scope</span><span>></span></span>\n            <span><span><span>&lt;</span>fileMode</span><span>></span></span>0755<span><span><span>&lt;/</span>fileMode</span><span>></span></span>\n            <span><span><span>&lt;</span>excludes</span><span>></span></span>\n                <span><span><span>&lt;</span>exclude</span><span>></span></span>${project.groupId}:${project.artifactId}<span><span><span>&lt;/</span>exclude</span><span>></span></span>\n            <span><span><span>&lt;/</span>excludes</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependencySet</span><span>></span></span>\n        <span><span><span>&lt;</span>dependencySet</span><span>></span></span>\n            <span><span><span>&lt;</span>outputDirectory</span><span>></span></span>boot<span><span><span>&lt;/</span>outputDirectory</span><span>></span></span>\n            <span><span><span>&lt;</span>fileMode</span><span>></span></span>0755<span><span><span>&lt;/</span>fileMode</span><span>></span></span>\n            <span><span><span>&lt;</span>includes</span><span>></span></span>\n                <span><span><span>&lt;</span>include</span><span>></span></span>${project.groupId}:${project.artifactId}<span><span><span>&lt;/</span>include</span><span>></span></span>\n            <span><span><span>&lt;/</span>includes</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependencySet</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependencySets</span><span>></span></span>\n<span><span><span>&lt;/</span>assembly</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h2 id=\"_2-pom-xml文件build节点的配置\"> 2.pom.xml文件build节点的配置</h2>\n<blockquote>\n<p>pom.xml配置文件</p>\n</blockquote>\n<div><pre><code>    <span><span><span>&lt;</span>build</span><span>></span></span>\n        <span>&lt;!-- 打包后的启动jar名称 --></span>\n        <span><span><span>&lt;</span>finalName</span><span>></span></span>app-name<span><span><span>&lt;/</span>finalName</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span>&lt;!-- 用于排除jar中依赖包 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>layout</span><span>></span></span>ZIP<span><span><span>&lt;/</span>layout</span><span>></span></span>\n                    <span><span><span>&lt;</span>includes</span><span>></span></span>\n                        <span>&lt;!-- 项目启动jar包中排除依赖包 --></span>\n                        <span><span><span>&lt;</span>include</span><span>></span></span>\n                            <span><span><span>&lt;</span>groupId</span><span>></span></span>non-exists<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                            <span><span><span>&lt;</span>artifactId</span><span>></span></span>non-exists<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                        <span><span><span>&lt;/</span>include</span><span>></span></span>\n                    <span><span><span>&lt;/</span>includes</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- 将依赖cp到lib目录下 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-dependency-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>3.1.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;</span>executions</span><span>></span></span>\n                    <span><span><span>&lt;</span>execution</span><span>></span></span>\n                        <span><span><span>&lt;</span>phase</span><span>></span></span>prepare-package<span><span><span>&lt;/</span>phase</span><span>></span></span>\n                        <span><span><span>&lt;</span>goals</span><span>></span></span>\n                            <span><span><span>&lt;</span>goal</span><span>></span></span>copy-dependencies<span><span><span>&lt;/</span>goal</span><span>></span></span>\n                        <span><span><span>&lt;/</span>goals</span><span>></span></span>\n                        <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                            <span>&lt;!--依赖输出目录--></span>\n                            <span><span><span>&lt;</span>outputDirectory</span><span>></span></span>target/lib<span><span><span>&lt;/</span>outputDirectory</span><span>></span></span>\n                            <span><span><span>&lt;</span>overWriteReleases</span><span>></span></span>false<span><span><span>&lt;/</span>overWriteReleases</span><span>></span></span>\n                            <span><span><span>&lt;</span>overWriteSnapshots</span><span>></span></span>false<span><span><span>&lt;/</span>overWriteSnapshots</span><span>></span></span>\n                            <span><span><span>&lt;</span>overWriteIfNewer</span><span>></span></span>true<span><span><span>&lt;/</span>overWriteIfNewer</span><span>></span></span>\n                            <span><span><span>&lt;</span>includeScope</span><span>></span></span>compile<span><span><span>&lt;/</span>includeScope</span><span>></span></span>\n                        <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;/</span>execution</span><span>></span></span>\n                <span><span><span>&lt;/</span>executions</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- maven编译 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-compiler-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span>&lt;!-- 不同版本需要制定具体的版本进行编译 --></span>\n                    <span><span><span>&lt;</span>source</span><span>></span></span>${java.version}<span><span><span>&lt;/</span>source</span><span>></span></span>\n                    <span><span><span>&lt;</span>target</span><span>></span></span>${java.version}<span><span><span>&lt;/</span>target</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- 打包时跳过测试 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-surefire-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>2.22.1<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>skipTests</span><span>></span></span>true<span><span><span>&lt;/</span>skipTests</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- 将项目中代码文件打成jar包 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-jar-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>3.1.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>excludes</span><span>></span></span>\n                        <span>&lt;!-- 打包后的jar包中不包括配置文件 --></span>\n                        <span>&lt;!-- 通常是指classpath下目录下的文件，这样可以避免编写时的找不到相应文件 --></span>\n                        <span><span><span>&lt;</span>exclude</span><span>></span></span>*.xml<span><span><span>&lt;/</span>exclude</span><span>></span></span>\n                        <span><span><span>&lt;</span>exclude</span><span>></span></span>*.properties<span><span><span>&lt;/</span>exclude</span><span>></span></span>\n                        <span><span><span>&lt;</span>exclude</span><span>></span></span>*.yml<span><span><span>&lt;/</span>exclude</span><span>></span></span>\n                    <span><span><span>&lt;/</span>excludes</span><span>></span></span>\n                    <span><span><span>&lt;</span>archive</span><span>></span></span>\n                        <span><span><span>&lt;</span>manifest</span><span>></span></span>\n                            <span>&lt;!-- 项目启动类 --></span>\n                            <span><span><span>&lt;</span>mainClass</span><span>></span></span>cn.moremind.app.SpringBootApplication<span><span><span>&lt;/</span>mainClass</span><span>></span></span>\n                            <span>&lt;!-- 依赖的jar的目录前缀 --></span>\n                            <span><span><span>&lt;</span>classpathPrefix</span><span>></span></span>../lib/<span><span><span>&lt;/</span>classpathPrefix</span><span>></span></span>\n                            <span><span><span>&lt;</span>addClasspath</span><span>></span></span>true<span><span><span>&lt;/</span>addClasspath</span><span>></span></span>\n                        <span><span><span>&lt;/</span>manifest</span><span>></span></span>\n                        <span>&lt;!-- 将config目录加入classpath目录 --></span>\n                        <span><span><span>&lt;</span>manifestEntries</span><span>></span></span>\n                            <span><span><span>&lt;</span>Class-Path</span><span>></span></span>../config/<span><span><span>&lt;/</span>Class-Path</span><span>></span></span>\n                        <span><span><span>&lt;/</span>manifestEntries</span><span>></span></span>\n                    <span><span><span>&lt;/</span>archive</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\n            <span>&lt;!-- 打包插件 --></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-assembly-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>3.1.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>descriptors</span><span>></span></span>\n                        <span><span><span>&lt;</span>descriptor</span><span>></span></span>src/main/assembly/assembly.xml<span><span><span>&lt;/</span>descriptor</span><span>></span></span>\n                    <span><span><span>&lt;/</span>descriptors</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n                <span><span><span>&lt;</span>executions</span><span>></span></span>\n                    <span><span><span>&lt;</span>execution</span><span>></span></span>\n                        <span><span><span>&lt;</span>id</span><span>></span></span>make-assembly<span><span><span>&lt;/</span>id</span><span>></span></span>\n                        <span><span><span>&lt;</span>phase</span><span>></span></span>package<span><span><span>&lt;/</span>phase</span><span>></span></span>\n                        <span><span><span>&lt;</span>goals</span><span>></span></span>\n                            <span><span><span>&lt;</span>goal</span><span>></span></span>single<span><span><span>&lt;/</span>goal</span><span>></span></span>\n                        <span><span><span>&lt;/</span>goals</span><span>></span></span>\n                    <span><span><span>&lt;/</span>execution</span><span>></span></span>\n                <span><span><span>&lt;/</span>executions</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br></div></div><h2 id=\"_3-编写shell脚本或者bat脚本\"> 3.编写shell脚本或者bat脚本</h2>\n<p>1.直接运行 java -jar xxxx.jar即可</p>\n<p>2.编写shell/bash脚本</p>\n<p>在bin目录下编写脚本文件如下：</p>\n<p>shell</p>\n<div><pre><code><span>#! /bin/sh</span>\n\n<span>HOME</span> <span>=</span> <span>'/opt/xxx/boot'</span>\nJAR_HOME <span>=</span> <span>'xxx.jar'</span>\n\n<span>cd</span> <span>$HOME</span>\n<span>nohup</span> java -jar <span>$JAR_HOME</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>bash</p>\n<div><pre><code>@echo off\nrem <span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>\nrem windows startup script\nrem\nrem <span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span><span>==</span>\nrem startup jar\n\njava -jar <span>..</span>/boot/xxx.jar\n\npause\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_4-项目目录如下\"> 4.项目目录如下</h2>\n<p><img src=\"https://finen-1251602255.cos.ap-shanghai.myqcloud.com/blog/images/maven/1565327770486.png\" alt=\"1565327770486\" /></p>\n",
      "image": "https://finen-1251602255.cos.ap-shanghai.myqcloud.com/blog/images/maven/1565327770486.png",
      "date_published": "2022-01-21T16:14:37.000Z",
      "date_modified": "2022-01-21T16:14:37.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": [
        "Maven"
      ]
    },
    {
      "title": "Blog Home",
      "url": "https://www.moremind.cn/",
      "id": "https://www.moremind.cn/",
      "content_html": "\n",
      "date_published": "2022-01-12T12:29:41.000Z",
      "date_modified": "2022-01-18T16:47:42.000Z",
      "authors": [
        {
          "name": "Moremind"
        }
      ],
      "tags": []
    }
  ]
}